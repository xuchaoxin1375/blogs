[toc]

## librosa.load的返回的时间序列如何理解

- `librosa.load` 函数返回的时间序列是一个一维数组，表示音频信号在时间轴上的采样值。在 `librosa` 中，时间轴的方向是沿着数组的第一个轴，即 `axis=0`。
- 因此，数组的每个元素代表了时间轴上的一个采样点。 例如，如果采样率为 22050 Hz，那么每秒会有 22050 个采样点，我们可以将其理解为在时间轴上每隔 $1/22050$ 秒就采集一次音频信号的值。
- 因此，如果音频的长度为 $T$ 秒，那么 `librosa.load` 函数返回的时间序列就是一个长度为 $T \times sr$ 的一维数组，其中 $sr$ 是采样率。 
- 需要注意的是，返回的时间序列并不一定是归一化的，也不一定是整数类型。在后续的处理中，我们通常需要对其进行归一化、类型转换等操作。

## soundFile

- [SoundFile — PySoundFile  documentation](https://pysoundfile.readthedocs.io/en/latest/)

- `with sf.SoundFile(file_title) as audio_recording:` 是使用 `soundfile` 库读取音频文件时的常用语法。

- `soundfile` 是一个 Python 库，用于读取和写入各种音频文件格式，包括 WAV、FLAC、OGG 等。

- 在使用 `soundfile` 读取音频文件时，我们通常使用 `with` 语句来自动管理文件的打开和关闭，避免出现资源泄漏等问题。

-  具体来说，`with` 语句中的 `sf.SoundFile(file_title)` 表示打开一个音频文件，并将其转换为 `SoundFile` 对象。`file_title` 是要读取的音频文件的路径和文件名。

- `as audio_recording` 表示将打开的音频文件对象赋值给 `audio_recording` 变量，以便后续对音频文件进行操作。 

- 例如，以下代码使用 `with` 语句打开一个 WAV 格式的音频文件，并打印音频的采样率和通道数：

  - ```python
    pythonCopy codeimport soundfile as sf
    file_title = 'audio_file.wav'
    with sf.SoundFile(file_title) as audio_recording:
        print('Sample rate:', audio_recording.samplerate)
        print('Channels:', audio_recording.channels)
    ```

- 需要注意的是，`with` 语句中的代码块结束后，`soundfile` 库会自动关闭音频文件对象，无需手动调用 `close()` 方法。

## librosa vs soundFile

- `soundfile` 和 `librosa` 都是用于读取和处理音频文件的 Python 库，但它们之间有一些不同。 `soundfile` 主要用于读取和写入各种音频文件格式，包括 WAV、FLAC、OGG 等。
- 它提供了一些基本的音频文件操作，例如读取音频数据、获取音频采样率、通道数等信息，并提供了一些常用的音频处理函数，例如音频格式转换、音频裁剪、音频合并等。
- `soundfile` 相对于 `librosa` 更加通用，可以处理多种音频格式，并且在**读取音频时速度较快**，但是在音频分析和处理方面功能相对较弱。
-  `librosa` 则更加专注于音频信号处理和分析。它提供了一系列用于特征提取、音频可视化、音频处理等方面的函数，例如计算短时傅里叶变换、梅尔频率倒谱系数等音频特征。
  - `librosa` 也支持多种音频格式，但其主要功能是对音频信号进行分析和处理，因此在读取音频时可能相对较慢。
-  综上所述
  - 如果您需要进行音频文件的读写和基本操作，例如<u>获取采样率、通道数等信息</u>，那么可以使用 `soundfile` 库。
  - 如果您需要进行音频信号的分析和处理，例如计算音频特征、提取音频信息等，则可以使用 `librosa` 库。
  - 当然，两者也可以结合使用，根据具体需求选择不同的库来处理音频文件。

### 音频的声道和通道

- 音频中的通道和声道都是描述声音的参数，但是它们的含义略有不同。
- **声道**(channel)是指声音在录制或播放时在**不同空间位置**<u>采集或回放</u>的相互独立的音频信号，所以**声道数**也就是声音录制时的<u>音源数量</u>或<u>回放时相应的扬声器数量</u>。
- **通道**(track)是指音频信号在<u>传输或处理</u>过程中的<u>路径</u>，每个通道可以有不同的**属性**，如音量、音色、输入/输出端口等。
- 英文中,声道一般用**channel**表示，通道一般用**track**表示。
- 例子，
  - 如果你用一个麦克风录制一段话，那么你就只有一个声道（单声道），也就是一个channel。
  - 如果你用两个麦克风分别录制左右耳的声音，那么你就有两个声道（双声道），也就是两个channel。
  - 如果你把这些录好的声音导入到电脑上的一个软件里进行编辑，那么你就可以看到每个channel对应一个track（通道），你可以对每个track进行调整和处理。
- 通道指的是音频信号传输和处理的路径，通常是指声道的数量。
  - 例如，单声道音频只有一个通道，而立体声音频有两个通道，分别为左声道和右声道。
  - 多声道音频可以有更多的通道，如5.1声道音频有6个通道，分别为左前、右前、中央、低音、左后和右后。
- 声道指的是声音在空间中的位置和方向，是指人耳接收声音的方向。例如，左声道是指声音来自左侧，右声道是指声音来自右侧。
  - 通道和声道之间有联系，多声道音频的不同声道对应着不同的通道。例如，左声道对应着左通道，右声道对应着右通道。在播放多声道音频时，播放设备会根据不同的通道，将声音输出到不同的扬声器中，让听者能够听到立体感更强的音效。
  - 举个例子，当你在听一首音乐时，如果你能听到左声道的吉他声音比右声道的吉他声音更清晰，那么说明左声道和右声道的音频信号在处理过程中出现了不同，也就是说左声道和右声道对应了不同的通道。

- **音源和声道**是音频处理中两个不同的概念，它们之间有一定的联系。
  - 音源是指产生声音的物体或者场景，例如人声、乐器、环境声等，每个音源都有自己的声音特点和音色。在录制音频时，需要选择合适的麦克风和录音位置，以捕捉到音源的声音，并将其转化为电信号。
  - 声道是指声音在空间中的方向和位置，例如左声道、右声道、中声道等。声道的数量和位置不同，会对音频的立体感和空间感产生影响。在录制音频时，需要根据音源的位置和声音特点选择合适的声道处理方式，以达到最佳的录音效果。
  - 在混音和后期处理中，音源和声道的关系更加密切。通过合理选择声道和处理效果，可以让不同音源的声音在空间中合理分布，形成立体的音频效果。同时，也可以通过声道处理，让不同音源的声音互相补充和协调，达到更好的音乐效果。

### 5.1声道

- 5.1声道是一种多声道音频格式，它包括5个正常声道和1个低音炮声道，共6个声道，分别为左前、右前、中央、左后、右后和低音。这种声道格式常用于家庭影院系统、电影院和游戏等领域，可以为听众带来更加真实、逼真的音效体验。
- 5.1声道的命名由来是基于其6个声道的数量。其中的“5”表示正常声道的数量，包括左前、右前、中央、左后和右后，而“1”表示低音炮声道的数量。低音炮声道主要用于增强低频音效，如爆炸声、地震声等，可以让听众感受到更加强烈的低频震撼效果。
- 在5.1声道音频中，左前和右前声道对应于影像中的左前和右前，中央声道用于播放对话和音乐的中心声音，左后和右后声道对应于影像中的左后和右后，可以提供更加立体的环绕音效。低音炮声道则用于播放低频音效，如爆炸声、地震声等，可以带来更加强烈的低频震撼效果。
- 总之，5.1声道是一种常用的多声道音频格式，可以为听众带来更加真实、逼真的音效体验，让观众更好地沉浸在影像中。

### 通道数量

- 一个通道通常只能对应一个声道。通道数量指的是音频信号传输和处理的路径数量，通常是指声道的数量；
- 而声道数量指的是声音在空间中的位置和方向，是指人耳接收声音的方向数量。
- 因此，一个通道通常只能对应一个声道，但是一个声道可以对应多个通道。
- 例如，一个双声道（2.0）音频可以通过复制左声道和右声道的信号，输出到多个通道中，达到立体声的效果。但是这种方式并不是真正的多声道处理，无法达到真正的立体声效果。



## librosa@soundFile常见问题

### 返回值

- 为什么加载同一份音频,librosa.load()返回是一维数组,而sf.read()返回二维数组

- 这是因为 `librosa.load()` 和 `sf.read()` 在处理多声道音频文件时的默认行为不同。

- `librosa.load()` 默认将多声道音频文件转换为单声道，并返回一维数组。如果你需要处理多声道音频文件，可以使用 `mono=False` 参数来保留所有声道，并返回二维数组。
- 而 `sf.read()` 默认会将多声道音频文件的每个声道分别存储在二维数组的不同**列**中，因此返回的是一个二维数组。

### soundFile修改采样率和通道数问题

-  `soundfile.read()` 函数不支持修改已经存在的文件的采样率、通道数、格式、子类型或字节序。

  - 否则遇到如下错误

    - ```python
      TypeError: Not allowed for existing files (except 'RAW'): samplerate, channels, format, subtype, endian
      ```

    - 这是一个与python-soundfile库相关的问题。python-soundfile是一个用于读写音频文件的python包，它支持多种音频格式

    - 当你使用soundfile.read函数来读取一个已存在的音频文件时，你不能指定samplerate（采样率）、channels（声道数）、format（格式）、subtype（子类型）和endian（字节序）这些参数，因为这些参数是从文件本身获取的，除非你读取的是RAW文件。

    - RAW文件是一种没有头部信息的音频文件，所以你需要手动指定这些参数才能正确地读取它。

    - 如果你想要改变已存在文件的这些参数，你可以使用soundfile.write函数来写入一个新的音频文件，并指定你想要的参数。
    
    - 总的来讲,可以用`librosa.load`的情况下,有先用`librosa.load`
    
      - `librosa.load`内部也用到`soundFile`的接口
    

### 域

- 在信号处理中，域（domain）是指信号所在的空间或空间范围。常见的域包括时域（time domain）、频域（frequency domain）、空间域（space domain）等。
- 时域是指信号在时间上的变化，通常是指信号在时间轴上的表示。在时域中，信号通常表示为时间序列或波形，描述信号随时间变化的过程。
- 频域是指信号在频率上的变化，通常是指信号在频率轴上的表示。在频域中，信号通常表示为频率成分或频谱，描述信号中各个频率成分的相对强度。
- 空间域通常用于描述信号在空间上的分布和变化，如图像处理中的像素和空间坐标。在空间域中，信号通常表示为二维或三维数组，描述信号在空间上的分布。
- 在信号处理中，不同的域通常用于描述信号的不同方面，如时域用于描述信号的波形和时序特征，频域用于描述信号的频率成分和频率特征，空间域用于描述信号在空间上的分布和结构特征。常用的信号处理技术如傅里叶变换、小波变换等也通常在不同的域中进行。

### 窗口和帧

- 在数字信号处理中，窗口和帧是两个重要的概念，通常与傅里叶变换相关。
- 窗口是一个**函数**，它在一定时间范围内具有非零值，而在其他时间范围内为零。
  - 在信号处理中，窗口通常用于对信号进行局部化处理，将信号分割成较小的部分进行处理。常见的窗口函数包括汉明窗、黑曼窗等。
- 帧是一种对信号进行**分段**的方法，通常是将长信号分成多个等长的部分。
  - 在傅里叶变换中，信号通常被分成多个帧，每个帧内的信号可以看作是在时间和频率上具有一定宽度的频域成分。
  - 通过将多个帧进行傅里叶变换，可以得到信号在时频域内的表示。
- 在短时傅里叶变换（STFT）中，窗口和帧通常是一起使用的。通过将长信号分成多个帧，并使用窗口对每个帧内的信号进行加权，可以得到在时频域内的表示。由于使用窗口函数对信号进行局部化处理，可以在频域上减少频率泄漏，同时在时域上减少信号突变的影响。

### 时域段

- 时域段指的是信号在时间轴上被分成的一段一段的时间窗口，每个时间窗口的长度是一定的，通常称为**帧长**。
- 在信号处理中，将信号分成时域段是为了方便进行频域分析，因为信号的频域特性在时间上是不稳定的，而在短时间内则相对稳定。因此，将信号分成时域段，对每个时域段进行频域分析，可以更好地分析信号的频域特性。
- 时域段的长度通常是通过窗口函数进行控制的，窗口函数可以控制时域段内信号的平滑度和频域分辨率。



### 短时傅里叶变换🎈stft

- [librosa.stft — librosa 0.10.0 documentation](https://librosa.org/doc/latest/generated/librosa.stft.html)

- librosa.stft()是一个用于计算短时傅里叶变换（STFT）的函数，它将一个时间序列分解成一系列频率域表示。STFT是一种将一个信号分解成一系列时域段的方法，每个时域段被转换成频域表示。

- Short-time Fourier transform (STFT).

  - The STFT represents a signal in the time-frequency domain by computing discrete Fourier transforms (DFT) over short overlapping windows.

  - This function returns a complex-valued matrix D such that

  - `np.abs(D[..., f, t])` is the magnitude of frequency bin `f` at frame `t`, and
  - `np.angle(D[..., f, t])` is the phase of frequency bin `f` at frame `t`.

  - The integers `t` and `f` can be converted to physical units by means of the utility functions [`frames_to_samples`](https://librosa.org/doc/latest/generated/librosa.frames_to_samples.html#librosa.frames_to_samples) and [`fft_frequencies`](https://librosa.org/doc/latest/generated/librosa.fft_frequencies.html#librosa.fft_frequencies).

- Short-time Fourier transform (STFT)是一种信号处理技术，它通过在短时间窗口上进行离散傅里叶变换（DFT）来将信号表示为时频域。

- 在STFT中，将信号分成多个时域段，并对每个时域段进行DFT变换，得到它们在频域的表示。这样可以更好地分析信号的频域特性，因为信号的频域特性在时间上是不稳定的，而在短时间内则相对稳定。

- STFT函数返回一个复数矩阵D，其中：

  - np.abs(D[..., f, t])表示在时间t和频率f处的幅度（即振幅），可以使用此信息进行频谱分析和音频可视化。
  - np.angle(D[..., f, t])表示在时间t和频率f处的相位，可以用于音频合成和相位调制等应用。

  通过使用frames_to_samples和fft_frequencies这两个实用程序函数，可以将整数t和f转换为物理单位，以便更好地理解它们的意义。其中frames_to_samples函数将帧数转换为样本数，而fft_frequencies函数将频率索引转换为频率值。这些函数可以帮助我们更好地理解STFT的输出结果。

#### bin f

- 在短时傅里叶变换（STFT）中，信号被分成了许多个窗口，每个窗口内的信号长度相同，通常是几毫秒。
- 在每个窗口内，进行离散傅里叶变换（DFT），将信号在频域上表示为一系列频率成分。这些频率成分被称为频率“bin”，在数学上可以看作是DFT输出中的离散频率点。

- 在STFT中，我们用帧来描述每个窗口，并用时间轴和频率轴来表示这些帧内的信号。这里的“bin f at frame t”指的是在时刻t和频率bin f处的幅度和相位。因此，通过计算STFT，我们可以得到一系列在时频域内描述信号特征的“幅度-相位矩阵”，可以用于分析和处理信号。

#### 例

- ```python
  y, sr = librosa.load(librosa.ex('trumpet'))
  S = np.abs(librosa.stft(y))
  S
  array([[5.395e-03, 3.332e-03, ..., 9.862e-07, 1.201e-05],
         [3.244e-03, 2.690e-03, ..., 9.536e-07, 1.201e-05],
         ...,
         [7.523e-05, 3.722e-05, ..., 1.188e-04, 1.031e-03],
         [7.640e-05, 3.944e-05, ..., 5.180e-04, 1.346e-03]],
        dtype=float32)
  ```

- 这段代码使用了Librosa库来加载一个小号音频文件，并对其进行短时傅里叶变换（STFT）得到了一个复数型的STFT谱S。

具体的解释如下：

- `librosa.load()`函数用于加载音频文件，并返回两个值：音频信号`y`和采样率`sr`。
- `np.abs()`函数用于计算复数STFT谱的模值，也就是将复数谱的实部和虚部分别平方相加后再取平方根。
- `librosa.stft()`函数用于计算音频信号的短时傅里叶变换（STFT），它可以将时域信号转换成频域信号，并将信号分成多个窗口进行变换。STFT的输出结果是一个复数型矩阵，包含了信号在不同时间和频率上的能量分布。

- 因此，`S`是一个形状为`(n_fft/2+1, t)`的实数型矩阵，其中`n_fft`是STFT中的FFT窗口大小，`t`是STFT中窗口的数量。

#### 输出结果

- `S`的每一列代表一个时间窗口内的频率能量分布，它的每一行代表一个频率的能量。
- 可以使用`np.angle()`函数计算`S`的相角部分，得到一个复数型的STFT谱。

### hop_length

- hop_length是指在进行短时傅里叶变换（STFT）时，每一帧之间的采样点数间隔。
  - hop是英语单词“hop”的名词形式，意为“跳跃”的意思，通常用于描述动物或人类跳跃的动作。
  - 在音频信号处理中，hop_length（也可以简称为“hop”）是指进行短时傅里叶变换（STFT）时相邻两帧之间的采样点数间隔，因此也有“帧移”或“跳跃长度”的意思。
- 在计算STFT时，将音频信号分成多个短时帧，
  - 每一帧的大小由n_fft参数指定，
  - hop_length指定了每一**帧之间**的采样点数间隔。
  - 例如，如果hop_length=512，则每相邻两帧之间间隔512个采样点。
- hop_length的值越大，每一帧之间的**重叠部分就越少**，特征提取的时间分辨率就降低，但是计算速度会更快。
- 相反，如果hop_length的值越小，每一帧之间的重叠部分就越多，时间分辨率也就越高，但是计算速度会更慢。因此，选择适当的hop_length值可以平衡时间分辨率和计算速度，得到最好的特征提取效果。



### 幅度和振幅

- 在信号处理中，幅度和振幅是两个相关但不同的概念。
- **幅度**(magnitude)是指**信号**在**某一时刻的大小**，通常用于描述**连续信号**的变化。
  - 在数字信号处理中，幅度通常表示为离散时间点上的采样值。
- **振幅**(apmlitude)是指信号在某一时刻的振动强度，通常用于描述<u>周期性信号的强度和波形</u>。
  - 振幅通常被定义为**幅度的最大值**，即信号振动的最大幅度。
  - **振幅**（amplitude）是在[波动](https://zh.wikipedia.org/wiki/波動)或[振动](https://zh.wikipedia.org/wiki/振动)中距离[振荡](https://zh.wikipedia.org/wiki/振荡)中心的最大[位移](https://zh.wikipedia.org/wiki/位移)；其数值称为**振幅值**、**幅值**。
- 在傅里叶变换中，幅度和振幅都是重要的概念。
- **幅度谱**表示了信号在频域上的幅度大小，而**振幅谱**表示了信号在**频域**上的振动强度。
  - 通常，幅度谱用于分析信号的频率分量，而振幅谱用于分析信号的周期性和波形。
  - 幅度和振幅都是**非负实数**
- [符号](https://zh.wikipedia.org/wiki/符号) A;振幅属于[标量](https://zh.wikipedia.org/wiki/标量_(物理学))，振幅值永为非负值（≥0）

#### 概念辨析

- “振幅”是专有名词，是术语，概念明确，清晰唯一；
  -  “振幅”是位移最大值（中心算起），并非完全是“振动幅度”（起点不明）。或者说：（词义）“振幅” =（词义）“振动幅度”；但是，（术语）“振幅”≠（词组）“振动幅度”；
  - 词语升格为术语，必定是限定条件下更为严格的语义（例如：参考点必须言明是上下限还是中心点）；即同一名词作为术语，必定是原本一般词义的子集，其意义缩小、严格化，且仅为专用。
- “幅度”是一般名词，生活用词，概念宽泛，所指不一。
- “幅度”是范围，未指明参考点，<u>常默指最大范围</u>，即包络区域。
- 其可指“两倍振幅”（按包络区域算），亦可指“振幅”（振荡中心算起）。 教学及工作时，应对“幅度”一词高度敏感，且弃用。注意辨别，防止言者所说和听者所解不一而导致误解，甚至更严重后果。 “幅值”则是振幅的数值，永为非负值；而“峰值”则是以振荡中心点为基准的极值，有正有负。

### 包络

### 包络线

#### 数学包络

- [包络线  (wikipedia.org)](https://zh.wikipedia.org/zh-cn/包絡線)
- **包络线**（Envelope）是[几何学](https://zh.wikipedia.org/wiki/幾何學)里的概念，代表一条[曲线](https://zh.wikipedia.org/wiki/曲线)与某个[曲线族](https://zh.wikipedia.org/w/index.php?title=曲線族&action=edit&redlink=1)中的每条线都有至少一点[相切](https://zh.wikipedia.org/wiki/相切)。（[曲线族](https://zh.wikipedia.org/w/index.php?title=曲線族&action=edit&redlink=1)即一些曲线的[无穷集](https://zh.wikipedia.org/wiki/无限集合)，它们有一些特定的关系。
  - 设一个曲线族的每条曲线$C_{s}$可表示为$t\mapsto (x(s,t),y(s,t))$，其中$s$是曲线族的参数，$t$是特定曲线的参数。
    - 若包络线存在，它是由$s\mapsto (x(s,h(s)),y(s,h(s)))$得出，其中$h(s)$以以下的方程求得：
    - ${\frac  {\partial y}{\partial h}}{\frac  {\partial x}{\partial s}}={\frac  {\partial y}{\partial s}}{\frac  {\partial x}{\partial h}}$
  - 若曲线族以隐函数形式 $F(x,y,s)=0$ 表示，其包络线的隐方程，便是以下面两个方程消去$s$得出。
    - ${\begin{cases}F(x,y,s)=0\\
      	{\frac  {\partial F(x,y,s)}{\partial s}}=0\end{cases}}$
- 包络线（Envelope）是指一组曲线的最外侧的连续曲线，可以用于描述这组曲线的整体形态。
- 在数学中，包络线可以用一组函数的极值点来表示，也可以用微积分的方法求得。在工程和物理学中，包络线常常用于描述振动、波动等现象中的幅度或能量的变化规律。
- 例如，一组正弦波的包络线是一个正弦曲线，它描述了这组正弦波的振幅随时间的变化规律。另一个例子是机械振动中的包络线，它描述了振动幅度随时间的变化规律，可以用于分析机械设备的寿命和可靠性等问题。在信号处理和通信中，包络线也是一个重要的概念，可以用于分析和设计调制、解调等电路和算法。

#### 信号处理中的包络

- 在信号处理中，包络通常指原始信号振幅的快速变化部分，也就是信号的“外壳”，它可以被视为原始信号在时间上的慢变化，而快速变化的部分可以被视为噪声或干扰。
- 包络提取是一种在信号处理中常用的技术，它可以将原始信号中的高频部分滤波掉，从而提取出信号的慢变化部分，也就是信号的包络。
- 包络可以被用来分析信号的振幅、频率和相位等特征，同时也可以用于信号的压缩、去噪和调制等应用。
- 在实际应用中，包络提取通常使用的方法包括振幅调制（AM）、希尔伯特变换（Hilbert transform）和小波变换等。
  - 其中，希尔伯特变换是一种非常常用的包络提取方法，它可以将信号分解成正交的实部和虚部信号，并提取出信号的包络。
  - 小波变换也是一种常用的包络提取方法，它可以将信号分解成不同尺度和频率的小波系数，从而提取出信号的包络和细节信息。
- 总之，包络线是一种非常有用的数学工具，可以用于描述各种现象中的整体规律和特征。

#### 包络区域

- 包络区域（envelope）是指一个信号或波动在时间或空间上的变化趋势，即它的最大振幅随时间或空间变化的曲线。在信号处理和通信中，包络区域通常用于分析和描述信号的动态特性，例如信号的幅度调制或解调、信号的频谱分析等。

- 包络区域的构成通常需要对信号进行调制或滤波处理。
- 在调幅（AM:amplitude modulation）信号中，包络区域是调制信号的幅度变化；
- 在调频（FM:frequency modulation）信号中，包络区域是调制信号的频率变化。
- 包络区域可以用图像或数学函数的形式表示，例如通过绘制信号波形的最大值或平均值曲线，或使用包络检测算法提取信号的包络函数。

- 在实际应用中，包络区域广泛应用于无线通信、音频信号处理、地震波分析等领域。

### MFCC

- [librosa.feature.mfcc — librosa 0.10.0 documentation](https://librosa.org/doc/latest/generated/librosa.feature.mfcc.html)

- librosa.feature.mfcc函数是一个用于提取音频信号的Mel频率倒谱系数（MFCC）特征的函数。

- MFCC是目前用于音频信号处理和语音识别的最常用特征之一，它可以有效地表示音频信号的语音特征。

- 该函数的输入参数包括音频信号y和采样率sr，以及一些可选参数，如窗口大小、帧移等。

- 它的输出是一个矩阵，其中每行是一个时间段的MFCC特征向量。

- MFCC特征的计算过程包括以下几个步骤：

  1. 分帧：将音频信号分成若干个固定长度的帧。
  2. 加窗：对每帧信号进行加窗操作，以消除边缘效应。
  3. 傅里叶变换：对每个帧信号进行快速傅里叶变换（FFT），将时域信号转换为频域信号。
  4. Mel滤波器组：将频域信号通过一组Mel滤波器，以模拟人耳的听觉特性。
  5. 对数运算：对每个Mel滤波器输出进行对数运算，以增强低频信号的表征能力。
  6. DCT变换：对对数能量谱进行离散余弦变换（DCT），得到MFCC系数。

  MFCC特征具有以下几个优点：

  1. 可以有效地表示音频信号的语音特征，如音调、声音颤动、共振峰等。
  2. 具有较好的抗噪性能，能够有效地抑制噪声和杂音。
  3. 可以通过降维操作，将高维的MFCC特征向量转换为低维度的特征向量，以便于后续的分类和识别。

  因此，MFCC特征在语音识别、声纹识别、音乐信息检索等领域得到了广泛的应用。

### librosa绘图

- [librosa.display.specshow — librosa 0.10.0 documentation](https://librosa.org/doc/latest/generated/librosa.display.specshow.html)
- [librosa.amplitude_to_db — librosa 0.10.0 documentation](https://librosa.org/doc/latest/generated/librosa.amplitude_to_db.html)
- [librosa.power_to_db — librosa 0.10.0 documentation](https://librosa.org/doc/latest/generated/librosa.power_to_db.html)
- `librosa.power_to_db()` 是 Librosa 库中的一个工具函数，用于将功率谱转换为分贝（dB）刻度。
  - 在音频处理中，功率谱代表了音频信号的短时傅里叶变换（STFT）的幅度平方，给出了每个时间点的信号的每个频率成分的功率估计。
  - 然而，功率谱通常太大而难以处理，分贝刻度更常用于表示音频信号的幅度。`librosa.power_to_db()` 函数将功率谱作为输入，并返回分贝比例尺的谱图。
  - 该函数对功率谱应用对数缩放，并将其归一化到参考值。默认情况下，参考值设置为输入谱图的最大值，这会导致 dB 刻度，其中 0 dB 对应于输入谱图中的最大功率值。这个函数对于音频信号的可视化和分析非常有用，因为分贝比例尺比原始功率谱更直观和易于解释。
- 具体来说，`power_to_db` 函数将输入频谱图转换为 dB 刻度，计算公式为：
  - $S_{\text{dB}}(f, t) = 10 \log_{10}\left(\frac{|S(f, t)|}{\text{ref}}\right)$
  - 其中，$S_{dB}(f,t)$ 表示转换后的频谱图;$S(f,t)$表示输入的频谱图，ref 表示参考值。
- 由于分贝（dB）的计算是相对于某个参考值的，因此选择一个合适的参考值可以使得频谱图的动态范围更适合人眼观察。
- 在这里，选择使用最大值作为参考值是因为最大值能够反映频谱图的整体动态范围，同时也能够保证不会出现负数的情况，方便后续计算和绘图。

