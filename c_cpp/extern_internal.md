- C 语言程序可以看成**由一系列的外部对象(广义对象)构成**，这些**外部对象**可能是**变量或函数**。
- 形容词external 与internal 相对的，internal 用于描述定义在函数内部的函数参数及变量。
- 外部变量定义在函数之外，因此可以在许多函数中使用。
  - 由于C 语言不允许在一个函数中定义其它函数，因此**函数本身是“外部的”。**
- 默认情况下，**外部变量与函数**具有下列性质：通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数）实际上都是引用同一个对象（标准中把这一性质称为外部链接）

- 在C 语言中，`所有变量`(变量有多种分类)都必须先`声明`(但是未必要定义,可以是在外部定义)后使用。
  - 声明通常放在`函数起始处`，(在`任何可执行语句之前`)。
  - 声明用于说明`变量的属性`，它由一个`类型名和一个变量表`组成，例如：

- 如果要**在外部变量的定义之前**使用该变量，或者<u>外部变量的定义</u>与<u>变量的使用</u>**不在同一个源文件中**，则必须在相应的变量声明中<u>强制性地使用关键字extern</u>。 
- 将`外部变量`(非局部变量)的`声明`与`定义`严格区分开来很重要。

### 定义外部变量

- 变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此以外还将引起存储器的分配。

  - 如果将下列语句放在所有函数的`外部`： (这种形式同时完成了变量的声明和定义(分配内存单元))

  > -    int sp; 
  > -    double val[MAXVAL]; 

- 那么这两条语句将`定义外部变量sp与val`，并为之`分配存储单元`，同时这两条语句`还可以`作为**该源文件中其余部分的声明。**

### 声明外部变量

- 下面的两行语句： 

  > -    extern int sp; 
  > -    extern double val[]; 

- 为源文件的`其余部分`**声明**了一个int 类型的`外部变量sp` 以及一个`double 数组类型的外部变量val`（该数组的长度在其它地方确定），但这两个声明<u>并没有建立变量或为它们分配存储单元</u>。 

### 组织外部变量

- 在一个**源程序**的所有**源文件**中，一个外部变量只能在某个文件中**定义一次**，而其它文件可以**通过 extern 声明来访问它**
  - （定义外部变量的源文件中也可以包含**对该外部变量的extern 声明**）。
- 外部变量的**定义中必须指定数组的长度**，但extern 声明则不一定要指定数组的长度。 
- 外部变量的**初始化**只能出现**在其定义中(执行初始化)**。 

## 自动变量

- 函数可以返回基本类型、结构、联合或指针类型的值。
- 任何函数都可以递归调用。
- `局部变量`通常是“自动的”，即在`每次函数调用时重新创建`。
- 函数定义可以不是嵌套的，但可以`用块结构的方式`声明变量。
- (构成)一个完整C 语言程序的`不同函数`可以出现(分散)在多个单独编译的`不同源文件`中。
- 变量可以只在函数内部有效，也可以在函数外部但仅在一个源文件中有效，还可以在整个程序中都有效。

## 静态变量(限定变量的作用域)

### static 外部变量

- 某些变量，比如文件stack.c中定义的变量sp与val以及文件getch.c中定义的变量buf 与bufp，它们仅供其所在的源文件中的函数使用，其它函数不能访问。
- 用static声明限定外部变量与函数，可以<u>将其后声明的对象的作用域限定为被编译源文件</u>的**剩余部分**。
- 通过static **限定外部对象**，可以达到**隐藏外部对象**的目的，
  - 比如，getch-ungetch 复合结构需要共享buf与bufp两个变量，这样buf与bufp必须是外部变量，
  - 但这两个对象不应该被getch与ungetch函数的**调用者**所访问。 

### static 内部变量

- static也可用于声明内部变量。static类型的内部变量同自动变量一样，是某个特定函数的局部变量，只能在该函数中使用，
- 但它与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。
- 换句话说，static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。 

## 初始化

- 在不进行<u>显式初始化</u>的情况下，**外部变量和静态变量**都将被初始化为0，
- 而**自动变量和寄存器变量**的初值则没有定义（即初值为无用的信息）。 

- 对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次
  - （从概念上讲是在程序开始执行前进行初始化）。
- 对于自动变量与寄存器变量，则在每次进入函数或程序块时都将被初始化。 
  - 对于自动变量与寄存器变量来说，初始化表达式可以不是常量表达式：
    - 表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用，

### 初始化vs赋值

- 实际上，自动变量的初始化等效于简写的赋值语句。
  - 究竟采用哪一种形式，还得看个人的习惯。考虑到变量声明中的初始化表达式容易被人忽略，且距使用的位置较远，我们一般使用显式的赋值语句。

#### 数组的初始化

- 可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号括起来，各初始化表达式之间通过逗号分隔。
  - 例如，如果要用一年中各月的天数初始化数组days，其变量的定义如下： int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
  - 当省略数组的长度时，编译器将把花括号中初始化表达式的个数作为数组的长度，在本例中数组的长度为12。 
  - 如果初始化表达式的个数比数组元索数少，则<u>对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0，</u>
  - 如果初始化表达式的个数比数组元素数多，则是错误的。
  - 不能一次将一个初始化表达式指定给多个数组元素，也不能跳过前面的数组元素而直接初始化后面的数组元素。 

### 初始化字符数组

- 字符数组的初始化比较特殊：可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列。
  - `char pattern[] = "ould"; `
  - 同下面的声明是等价的： 
    - ​	`char pattern[] = { 'o', 'u', 'l', 'd'}; `
    - 这种情况下，数组的长度是5（4 个字符加上一个字符串结束符'\0'）。 

### C 预处理器 

- C 语言通过预处理器提供了一些语言功能。
- 从概念上讲，预处理器是编译过程中单独执行的第一个步骤。
- 两个最常用的预处理器指令是：
  - #include 指令（用于在编译期间把指定文件的内容包含进当前文件中）和
  - #define指令（用任意字符序列替代一个标记）。
- 本节还将介绍预处理器的其它一些特性，如条件编译与带参数的宏。 

#### #include

- 文件包含指令（即#include指令）使得处理大量的#define指令以及声明更加方便。
- 在源文件中，任何形如： 
  - #include "文件名" 或 #include <文件名> 
  - 的行都将被替换为**由文件名指定的文件的内容**。
  - 如果文件名用**引号("")**引起来，则在<u>源文件所在位置查找该文件</u>；
    - 如果在该位置没有找到文件，
    - 或者如果文件名是用**尖括号<与>**括起来的，
    - 则将根据相应的规则查找该文件，这个规则**同具体的实现有关**。
    - 被包含的文件本身也可包含#include指令。 
- 在大的程序中，#include 指令是**将所有声明捆绑在一起**的较好的方法。
  - 它保证所有的**源文件都具有相同的定义与变量声明**，这样可以避免出现一些不必要的错误。
  - 很自然，如果某个包含文件的<u>内容发生了变化，那么所有依赖于该包含文件的源文件都必须重新编译</u>。 





#### 宏替换 

宏定义的形式如下： 
`#define 名字 替换文本` 
这是一种最简单的宏替换——后续所有出现名字记号的地方都将被替换为替换文本。

- `#define`指令中的名字与变量名的命名方式相同，替换文本可以是任意字符串。
- 通常情况下，`#define`指令占一行，替换文本是#define指令行尾部的所有剩余部分内容，但也可以把一
- 个较长的宏定义分成若干行，这时需要在待续的行末尾加上一个反斜杠符`\`。
- *#define* 指令定义的名字的**作用域**从其定义点开始，到被编译的源文件的末尾处结束。
- 宏定义中也可以使用前面出现的宏定义。
- 替换只对记号进行，对括在引号中的字符串不起作用。
  - 例如，如果YES是一个通过#define指令定义过的名字，则在`printf("YES")`或YESMAN中将不执行替换。 
- 替换文本可以是任意的，例如： 
  - `#define  forever  for (;;)    /* infinite loop */` 
  - 该语句为无限循环定义了一个新名字forever。 
- 宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。
- 例如，下列宏定义定义了一个宏max： 
  - `#define  max(A, B)  ((A) > (B) ? (A) : (B))` 
  - 使用宏max 看起来很像是函数词用，但宏调用直接将替换文本插入到代码中。
  - 形式参数（在此为A或B）的每次出现都将被替换成对应的实际参数。
  - 因此，语句： 
    - `x = max(p+q, r+s);` 
    - 将被替换为下列形式： 
    - `x = ((p+q) > (r+s) ? (p+q) : (r+s));` 
- 如果对各种类型的参数的处理是一致的，则可以将同一个宏定义应用于任何数据类型，而无需针对不同的数据类型需要定义不同的max函数。 



- 仔细考虑一下max 的展开式，就会发现它存在一些缺陷。
  - 其中，作为参数的表达式要重复计算两次，如果表达式存在副作用（比如含有自增运算符或输入／输出），则会出现不正确的情况。例如： 
    - `max(i++, j++)  /* WRONG */` 
    - 它将对每个参数执行两次自增操作。
- 同时还必须注意，要适当使用圆括号以保证计算次序的正确性。考虑下列宏定义： 
  - `#define square(x)  x * x  /* WRONG */` 
  - 当用squrare(z+1)调用该宏定义时会出现什么情况呢？ 

宏还是很有价值的。

- <stdio.h>头文件中有一个很实用的例子：getchar 与putchar 函数在实际中常常被定义为宏，这样可以避免处理字符时调用函数所需的运行时开销。
- <ctype.h>头文件中定义的函数也常常是通过宏实现的。 

#### #undef

- 可以通过#undef指令取消名字的宏定义，这样做可以保证后续的调用是函数调用，而不是宏调用： 
  - `#undef getchar` 
  - `int getchar(void) { ... }` 
- 形式参数不能用带引号的字符串替换。
  - 但是，如果在替换文本中，参数名以#作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串。例如，可以将它与字符串连接运算结合起来编写一个调试打印宏： 
    - `#define  dprint(expr)   printf(#expr " = %g\n", expr)` 
      - 使用语句 `dprint(x/y)` 
        - 调用该宏时，该宏将被扩展为： `printf("x/y" " = &g\n", x/y);` 
          - 其中的字符串被连接起来了，这样，该宏调用的效果等价于 `printf("x/y = &g\n", x/y);` 
    - 在实际参数中，每个双引号"将被替换为\"，反斜杠\将被替换为\\，因此替换后的字符串是合法的字符串常量。 

#### 预处理器运算符##

- 预处理器运算符`##`为宏扩展提供了一种连接实际参数的手段。
- 如果替换文本中的参数与`#`相邻，则该参数将被实际参数替换，`##`与前后的空白符将被删除，并对替换后的结果重新扫描。
  - 例如，下面定义的宏paste用于连接两个参数 
    - `#define  paste(front, back)  front ## back` 
    - 因此，宏调用paste(name, 1)的结果将建立记号`name1`。  

### 条件包含 

- 还可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行的过程中进行计算。
  - 这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了一种手段。 
  - `#if`语句对其中的常量整型表达式（其中不能包含sizeof、类型转换运算符或enum常量）进行求值，
  - 若该表达式的值不等于0，则包含其后的各行，直到遇到#endif、#elif或#else 语句为止（预处理器语句#elif 类似于else if）。
  - 在`#if` 语句中可以使用`表达式defined(名字)`，该表达式的值遵循下列规则：
    - 当名字已经定义时，其值为1；
    - 否则，其值为0。 例如，为了保证hdr.h文件的内容只被包含一次，可以将该文件的内容包含在下列形式的条件语句中：

```c
#if !defined(HDR) 	
#define HDR 
/* hdr.h文件的内容放在这里 */ 
#endif 
```

- 第一次包含头文件hdr.h时，将定义名字HDR；
  - 此后再次包含该头文件时，会发现该名字已经定义，这样将直接跳转到#endif处。
  - 类似的方式也可以用来避免多次重复包含同一文件。
  - 如果多个头文件能够一致地使用这种方式，那么，每个头文件都可以将它所依赖的任何头文件包含进来，用户不必考虑和处理头文件之间的各种依赖关系。
  - 下面的这段预处理代码首先**测试系统变量SYSTEM**，然后**根据该变量的值**确定包含哪个版本的头文件： 

```c
   #if SYSTEM == SYSV 
       #define HDR "sysv.h" 
   #elif SYSTEM == BSD 
       #define HDR "bsd.h" 
   #elif SYSTEM == MSDOS 
       #define HDR "msdos.h" 
   #else 
       #define HDR "default.h" 
   #endif 
   #include HDR *



```

##### #ifdef与#ifndef

- C 语言专门定义了两个预处理语句#ifdef与#ifndef，它们用来测试某个名字是否已经定义。上面有关#if的第一个例子可以改写为下列形式： 

  - ```c
    #ifndef HDR 
    #define EDR 
    /* hdr.h文件的内容放在这里 */ 
    #endif 
    ```

    

  





 