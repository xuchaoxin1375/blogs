为了克服忙等待需要，可以这样修改信号量操作wait。和signalO的定义：当一个进程执行操作wait。并且发现信号量值不为正时，它必须等待。然而，该进程不是忙等待而是阻塞自己。阻塞操作将一个进程放到与信号量相关的等待队列中，并且将该进程状态切换成等待状态。然后，控制转到CPU调度程序，以便选择执行另一个进程。等待信号量S而阻塞的进程，在其他进程执行操作signal()后，应被重新执行。进程的重新执行是通过操作wakeup()来进行的，它将进程从等待状态改为就绪状态。然而，进程被添加到就绪队列.(取决于CPU调度算法，CPU可能会也可能不会从正在运行的进程切换到新的就绪进程。)操作block()挂起调用它的进程。操作wakeup(P)重新启动阻塞进程P的执行。这两个操作都是由操作系统作为基本系统调用来提供的。注意，这样实现的信号量的值可以是负数，而在具有忙等待的信号量经典定义下，信号量的值不能为负。如果信号量的值为负，那么它的绝对值就是等待它的进程数。出现这种情况源于，在实现操作waitO时互换了递减和测试的顺序。通过每个进程控制块PCB的一个链接字段，等待进程的链表可以轻松实现。每个信号最包括一个整数和一个PCB链表指针。向链表中增加和删除进程以便确保有限等待的一种方法采用FIFO队列，这里的信号量包括队列的首指针和尾指针。然而，一般来说，链表可以使用任何排队策略。信号量的正确使用不依赖于信号量链表的特定排队策略关键的是，信号量操作应原子执行。我们应保证：对同一信号最，没有两个进程可以同时执行操作wait。和signal()o这是一个临界区问题。对于单处理器环境，在执行操作wait。和signal()时，可以简单禁止中断。这种方案在单处理器环境下能工作，这是因为一旦中断被禁用，不同进程指令不会交织在一起。只有当前运行进程一直执行，直到中断被重新启用并且调度程序重新获得控制。对于多处理器环境，每个处理器的中断都应被禁止；否则，在不同处理器上不同的运行进程可能会以任意不同方式一起交织执行。每个处理器中断的禁止会很困难，也会严重影响性能。因此，SMP系统应提供其他加锁技术，如compare_and_swap()或自旋锁，以确保waitO与signal()原子执行。重要的是要承认，对于这里定义的操作wait()和signal(),我们并没有完全取消忙等待。我们只是将忙等待从进入区移到临界区。此外，我们将忙等待限制在操作wait()和signal()的临界区内，这些区比较短(如经合理编码，它们不会超过10条指令)。因此，临界区几乎不被占用，忙等待很少发生，而且所需时间很短。对于应用程序，存在一种完全不同的情况，即临界区可能很长(数分钟或数小时)或几乎寂是被占用在这种情况下，忙等待极为低效。