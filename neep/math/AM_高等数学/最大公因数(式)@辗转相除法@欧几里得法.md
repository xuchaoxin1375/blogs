[toc]

## 简介

- [Euclidean algorithm - Wikipedia](https://en.wikipedia.org/wiki/Euclidean_algorithm)

- **辗转相除法**，也被称为**欧几里得算法**，是一种用于求两个整数最大公约数的算法。
- 这种算法基于以下原理：两个整数的最大公约数等于**其中较小的数**和**两数的差**的最大公约数。
  - 设两个整数$a,b\in\mathbb{Z}$,令$M=\max(a,b);m=\min(a,b)$;$d=M-m$
  - 那么$gcd(a,b)=gcd(m,d)$

## 算法步骤

- 以下是辗转相除法的步骤：

1. 将两个数中较大M的数除以较小的数m，得到余数$c_0$。
2. 将较小的数m和第一步得到的余数$c_0$进行同样的操作，即用较小的数m除以余数$c_0$，再得到一个新的余数$c_1$。
3. 重复第二步，直到余数为0。此时，最后一个非零余数就是两个原数的最大公约数。

- 例如，我们要求 48 和 18 的最大公约数：

  - 48 ÷ 18 = 2余12

  - 18 ÷ 12 = 1余6

  - 12 ÷ 6 = 2余0

  - 因此，48 和 18 的最大公约数是 6。

## 证明

- 设数$a,b$的公约数为$m$
- 则$a=xm,b=ym$,$m,x,y\in{\mathbb{Z}}$
- 设$a=kb+c$,
  - 即$xm=kym+c$,$c=(x-ky)m$
  - 其中$c=a\%b$,$k\in\mathbb{Z}$
- $\frac{c}{m}=\frac{(x-ky)m}{m}=(x-ky)\in\mathbb{Z}$
- $\frac{a}{m}=x\in\mathbb{Z}$
- 若用$f|g$表示$f$整除$g$,则$m|a,m|b,m|c$
- 可见,$a,b$的公因子也是$c=a\%b$的公因子
- $a,b$的最大公因子是公因子中最大的一个,其仍然是被$c$整除的因子
- 设$a,b$的最大公因子表示为$gcd(a,b)$,则$gcd(a,b)=gcd(a,c)=gcd(b,c)$

### 算法特点

- 在小学阶段,我们已经学过短除法来求解两个整数的最大公因子,这种方法在两个数都比较大的情况下效率较低
- 而使用欧几里得算法,可以大大提高效率,特别是两个数大小接近的时候,即便它们都很大,算法也可以快速求解最大公因子

### 应用

- 假设有2个数$a,b$,$(a>b)$
  - 则大小关系上有$a>b>c$
  - 约定数对$(a,b)>(m,n)$的条件是$a\geqslant{b}\geqslant{m}\geqslant{n}$
  - 结合规律$gcd(a,b)=gcd(b,c)$,我们把一组较大的数$a,b$的最大公因式求解问题转换为较小的$b,c$
  - 记$c_1=b\%c$
  - $gcd(b,c)=gcd(c,c_1)$
  - 类似的,最大公因子$G=gcd(a,b)=gcd=(b,c)=gcd(c,c_1)=\cdots=gcd(c_{t-1},c_t)$,其中$c_{t-1}\%c_{t}=0$;且最大公因子就是$c_t$

### C语言

```c
/* gcd函数(低级的短除法) */
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <string.h>
int gcd_Euler(int, int);
int gcd(int,int);
int main(){
    int a,b;
    //printf("test_1:\n");
    while (scanf("%d%d", &a, &b) != EOF)
    {
        printf("短除法版:%d\n", gcd(a, b));
        printf("Euler版:%d\n", gcd_Euler(a, b));
    }
    

    return 0;
}
//gcd_Euler()
int gcd_Eucilidien(int a,int b)
{
    /*Euler版的递归写法简单,但递归入口的操作数顺序可以举个例子来检验正确性.
    eg. 对同一组a,b
    ((a>b)时):gcd(8,6) = gcd(6,8%6 = 2) = 2;
    ((a<b)时):gcd(6,8) = gcd(8,6) 发现回到了a>b的情况.*/
    if (a % b == 0)
    {
        return b;
    }
    else
    {
        return gcd_Euler(b, a % b);
    }
}
//(短除法gcd函数:)
int gcd(int a,int b)
{
    int s = 1;
    for (int i = 2; i <= a && i <= b;/*因子i不可超过a,b中任一操作数*/ )
    {

        if (a % i == 0 && b % i == 0)/*i同时整除操作数a,b*/
        {
            //gcd *= i;
            s *= i;/*累乘*/
            /*更新两个操作数*/
            a /= i;
            b /= i;

        }
        else
        {
            i++;
        }

    }
    return s;
} 

```

## python

### 朴素版

```python
def gcd(a, b):
    """使用递归的方式利用欧几里得算法计算两个数的最大公约数(gcd(a,))
    其中,M,m的计算可以还这样实现
    M = a if a > b else b
    m = a if a < b else b

    Parameters
    ----------
    a : int
        第1个数
    b : int
        第2个数

    Returns
    -------
    int
        最大公约数
    """
    M,m=max(a,b),min(a,b)
    c = M % m
    # [info]
    # print(f"{M=},{m=},{c=}")
    if c==0:
        return m
    else:
        return gcd(m, c)

##
gcd(18,48)#6
##
gcd(102,170)#34 
## 
gcd(88,64)#8

```

### 优化版

-   依然采用递归的方式实现
-   通过分析欧几里得算法的停止条件可知,只有遇到整除的情况下才会结束算法
- 对于c=a%b($b\neq{0}$),如果c=0,只可能是$a>b$且$b|a$;
  - 因为若$a<b$,则c=a%b=a

###  打印计算过程和示例






```python
gcd(77,70)
```

​    M=77,m=70,c=7
​    M=70,m=7,c=0
​    




​    7




```python
gcd(75,72)
```

​    M=75,m=72,c=3
​    M=72,m=3,c=0
​    




​    3




```python
gcd(102,170)
```

​    M=170,m=102,c=68
​    M=102,m=68,c=34
​    M=68,m=34,c=0
​    




​    34




```python
gcd(102,102)
```

​    M=102,m=102,c=0
​    




​    102




```python
gcd(16,102)
```

​    M=102,m=16,c=6
​    M=16,m=6,c=4
​    M=6,m=4,c=2
​    M=4,m=2,c=0
​    




​    2




```python
gcd(17,102)
```

​    M=102,m=17,c=0
​    




​    17



