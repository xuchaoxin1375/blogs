[toc]

## 转置行列式

- $$
  A=\begin{vmatrix}
  	a_{11}  &a_{12}  &\cdots  &a_{1n}  	\\
  	a_{21}  &a_{22}  &\cdots  &a_{2n}  	\\
  	\vdots  &\vdots  &        &\vdots  	\\
  	a_{n1}  &a_{n2}  &\cdots  &a_{nn}  	\\
  \end{vmatrix}
  \\
  B=\begin{vmatrix}  
    b_{11}& b_{12}& \cdots  & b_{1n} \\  
    b_{21}& b_{22}& \cdots  & b_{2n} \\  
    \vdots & \vdots &  & \vdots \\  
    b_{n1}& b_{n2}& \cdots  & b_{nn}  
  \end{vmatrix}
  =\begin{vmatrix}
    	a_{11}  &a_{21}  &\cdots  &a_{n1}  	\\
    	a_{12}  &a_{22}  &\cdots  &a_{n2}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	a_{1n}  &a_{2n}  &\cdots  &a_{nn}  	\\
    \end{vmatrix}
  $$

  - 行列式$B$称为$A$的转置行列式,记为$B=A^T$
  - 并且$b_{ij}=a_{ji}$,$i,j=1,2,\cdots,n$

## 矩阵的转置

- 转置（transpose）是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像,这条从左上角到右下角的对角线被称为 主对角线（main diagonal）

- 一个简单的矩阵转置定义:把矩阵A的**行**换成同序数的**列**,得到的新矩阵$B$称为$A$的转置矩阵,记为$B=A^\rm{T}$

  - $$
    A=\begin{pmatrix}
    	a_{11}  &a_{12}  &\cdots  &a_{1n}  	\\
    	a_{21}  &a_{22}  &\cdots  &a_{2n}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	a_{m1}  &a_{m2}  &\cdots  &a_{mn}  	\\
    \end{pmatrix}
    \\
    B=\begin{pmatrix}
      	b_{11}  &b_{12}  &\cdots  &b_{1m}  	\\
      	b_{21}  &b_{22}  &\cdots  &b_{2m}  	\\
      	\vdots  &\vdots  &        &\vdots  	\\
      	b_{n1}  &b_{n2}  &\cdots  &b_{nm}  	\\
      \end{pmatrix}
      =\begin{pmatrix}
      	a_{11}  &a_{21}  &\cdots  &a_{m1}  	\\
      	a_{12}  &a_{22}  &\cdots  &a_{m2}  	\\
      	\vdots  &\vdots  &        &\vdots  	\\
      	a_{1n}  &a_{2n}  &\cdots  &a_{mn}  	\\
      \end{pmatrix}
    $$

  - 称$B$为$A$的转置矩阵,且记$B=A^T$

  - 符号描述:我们将矩阵 $A\in\mathbb{R}^{m\times{n}}$ 的转置表示为 $A^T\in\mathbb{R}^{n\times{m}}$，$b_{ij}=a_{ji}$

    - $i=1,2,\cdots,n$
    - $j=1,2,\cdots,m$


## 向量与标量的转置

- 向量:可以看作只有一列的矩阵。对应地，向量的转置可以看作是只有一行的矩阵。有时，我们通过将向量元素作为行矩阵写在文本行中，然后使用转置操作将其变为标准的列向量，来定义一个向量，比如 $x = [x1_,\cdots, x_n]^⊤$.
- 标量:可以看作是只有一个元素的矩阵。因此，标量的转置等于它本身，$a^⊤=a$

## 转置运算性质

- $(A^T)^T=A$

- $(\lambda{A})^T=\lambda{}A^T$

  - $B=\lambda{A}$,$b_{ij}=\lambda{a_{ij}}$

  - $C=B^T,c_{ij}=b_{ji}=\lambda{a_{ji}}$

  - $D=\lambda{A^T}$,$d_{ij}=\lambda{a_{ji}}$

  - $\therefore{c_{ij}=d_{ij}}$,即$(\lambda{A})^T=\lambda{A^T}$

- $(A+B)^T=A^T+B^T$(转置分配律)

  - $A^T+B^T=(A+B)^T$(逆分配律)

  - $(\lambda E+B^T)=((\lambda{E})^T+B^T)=(\lambda E+B)^T$
    - 因为$E^T=E$,$(\lambda{E})^T=\lambda{E^T}=\lambda{E}$

- $(AB)^T=B^TA^T$(注意位置的调换)

  - 转置对矩阵乘法的**逆序分配律**

- $$
  (A_1A_2\cdots{A_m})^T=A_m^TA_{m-1}^T\cdots{A_1^T}
  \\或(\prod_{i=1}^{m}A_i)^T=\prod_{i=1}^{m}A_{m-i+1}^T
  $$

#### 矩阵加法的转置分配律

- $$
  A=\begin{pmatrix}
  	a_{11}  &a_{12}  &\cdots  &a_{1n}  	\\
  	a_{21}  &a_{22}  &\cdots  &a_{2n}  	\\
  	\vdots  &\vdots  &        &\vdots  	\\
  	a_{m1}  &a_{m2}  &\cdots  &a_{mn}  	\\
  \end{pmatrix}
  \\
  B=\begin{pmatrix}
  	b_{11}  &b_{12}  &\cdots  &b_{1n}  	\\
  	b_{21}  &b_{22}  &\cdots  &b_{2n}  	\\
  	\vdots  &\vdots  &        &\vdots  	\\
  	b_{m1}  &b_{m2}  &\cdots  &b_{mn}  	\\
  \end{pmatrix}
  \\
  C=A^T
    =\begin{pmatrix}
    	c_{11}  &c_{12}  &\cdots  &c_{1m}  	\\
    	c_{21}  &c_{22}  &\cdots  &c_{2m}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	c_{n1}  &c_{n2}  &\cdots  &c_{nm}  	\\
    \end{pmatrix}
    =\begin{pmatrix}
    	a_{11}  &a_{21}  &\cdots  &a_{m1}  	\\
    	a_{12}  &a_{22}  &\cdots  &a_{m2}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	a_{1n}  &a_{2n}  &\cdots  &a_{mn}  	\\
    \end{pmatrix}
  $$

- $P=A+B$,$p_{ij}=a_{ij}+b_{ij}$

- $Q=P^T,q_{ij}=p_{ji}=a_{ji}+b_{ji}$

- $R=A^T+B^T,r_{ij}=a_{ji}+b_{ji}$

- 容易知道$R,P$都是n行m列,且$q_{ij}=r_{ij}$,从而转置运算满足加法分配律

#### 关于矩阵乘法转置逆序分配律🎈

- 令$C=AB$,$c_{ij}=\prod_{k=1}^{n}a_{ik}b_{kj}$
- 令$D=C^{T},d_{ij}=c_{ji}=\prod_{k=1}^{n}a_{jk}b_{ki}$
- $E=B^{T}A^T$,$e_{ij}=\prod_{k=1}^{n}b'_{ik}a'_{kj}$=$\prod_{k=1}^{n}b_{ki}a_{jk}$
- 可见$D=E$,从而$(AB)^T=B^TA^T$

- 推广:$(\prod_{i}^{n}A_{i})^T=\prod_{i=1}^{n}A_{n-i+1}^T$(即:$(A_1A_2\cdots{A_n})^T=A_n^TA_{n-1}^T\cdots{A_{1}^T}$)



## 矩阵转置python代码

### 基础实现

```python
##

import numpy as np
rng = np.random.default_rng()
##
nrow=3
ncol=5
c=rng.random(size=(nrow,ncol))
# 保留三位小数(可以确保打印的时候每个元素的小数位数不超过3位)
d=c.round(3)
 
for i in d:
    # print(i)
    for j in i:
        print(j,end="\t")
    print()
print("transposing...","-"*10)

#转置后的矩阵规格为(ncol,nrow)
# 采用逐列读取的方式打印原矩阵,打印结果就是原矩阵的转置(第i列被打印为第i行)
#假设转置后的矩阵记为B
for i in range(ncol):
    # 则i用来表示B中元素的列号
    for j in range(nrow):
        # j用来表示B中元素的行号
        print(d[j,i],end="\t")
    print()

```

- ```bash
  0.111	0.287	0.346	0.403	0.059	
  0.302	0.112	0.565	0.393	0.975	
  0.693	0.724	0.834	0.907	0.034	
  transposing... ----------
  0.111	0.302	0.693	
  0.287	0.112	0.724	
  0.346	0.565	0.834	
  0.403	0.393	0.907	
  0.059	0.975	0.034
  ```

### numpy实现矩阵转置

- 随机生成一个4x5的矩阵

  ```python
  In [18]: a
  Out[18]:
  array([[15, 16, 17, 18, 19],
         [ 0,  1,  2,  3,  4],
         [ 5,  6,  7,  8,  9],
         [10, 11, 12, 13, 14]])
  ```

- 方式transpose方法:

  ```python
  In [20]: np.transpose(a)
  Out[20]:
  array([[15,  0,  5, 10],
         [16,  1,  6, 11],
         [17,  2,  7, 12],
         [18,  3,  8, 13],
         [19,  4,  9, 14]])
  ```

- 访问T属性:

  ```python
  In [21]: a.T
  Out[21]:
  array([[15,  0,  5, 10],
         [16,  1,  6, 11],
         [17,  2,  7, 12],
         [18,  3,  8, 13],
         [19,  4,  9, 14]])
  ```

### numpy计算方阵的行列式

- ```python
  #随机生成方阵
  In [22]: rng=np.random.default_rng()
  
  In [23]: a=rng.integers(100,size=(4,4))
  
  In [24]: a
  Out[24]:
  array([[89, 43, 25,  7],
         [81, 34, 56, 46],
         [ 2, 38, 78, 47],
         [93, 82, 15, 84]], dtype=int64)
  #调用线性代数模块linalg中的det方法求解
  In [25]: np.linalg.det(a)
  Out[25]: -17794497.0
  ```

  
