[toc]

- 余子式@代数余子式@伴随矩阵@方阵与行列式

## refs

- [Minor (linear algebra) - Wikipedia](https://en.wikipedia.org/wiki/Minor_(linear_algebra))
- [子式和余子式 (wikipedia.org)](https://zh.wikipedia.org/wiki/子式和余子式)

## 余子式@代数余子式🎈

- 设n阶行列式:

  - $$
    \begin{vmatrix}  
      a_{11}&   \cdots  & a_{1n} \\  
      \vdots   &   & \vdots \\  
      a_{n1}&   \cdots  & a_{nn}  
    \end{vmatrix}
    $$

- 子式和余子式都是行列式(即,他们(的计算结果)都是一个值)

- **子式**:在[线性代数](https://zh.wikipedia.org/wiki/线性代数)中，一个<u>矩阵</u>**A**的**子式**是指将**A**的某些行与列的交点组成的[方阵](https://zh.wikipedia.org/wiki/方块矩阵)的[行列式](https://zh.wikipedia.org/wiki/行列式)；

- **余子式**:具体指方阵的余子式,**A**的**余子式**（又称**余因式**，英语：minor）是指将<u>方阵</u>**A**的某一行与列去掉之后所余下(元素按原位置排法构成)的<u>方阵</u>的**行列式**

  - 其相应的**方阵**有时被称为**余子阵**。
  - 可以对n阶方阵和n阶行列式取余子式
  - 但注意非方阵(行数和列数不等的矩阵)是没有余子式!
  - (由余子式的定义可知,原矩阵去掉某行某列后剩余的部分要计算**行列式**,如果$m\neq{n}$,$m-1\neq{n-1}$,无法计算行列式)


- 元素$a_{ij}$的**余子式**(minor),通常记为$M(a_{ij})=M_{ij}$

  - $$
    M_{ij}= 
    \begin{vmatrix}  
      a_{11}& \cdots & a_{1,j-1}& a_{1,j+1}& \cdots  & a_{1n} \\ 
       \vdots&    & \vdots &\vdots & & \vdots \\
      a_{i-1,1}& \cdots & a_{i-1,j-1}& a_{i-1,j+1}& \cdots  & a_{i-1,n} \\  
       a_{i+1,1}& \cdots & a_{i+1,j-1}& a_{i+1,j+1}& \cdots  & a_{i+1,n} \\  
      \vdots&   & \vdots & \vdots && \vdots \\  
      a_{n1}& \cdots & a_{n,j-1}& a_{n,j+1}& \cdots  & a_{nn}  
    \end{vmatrix}_{n-1}
    $$

- 将方阵**A**的一行与一列去掉之后所得到的余子式可用来获得相应的**代数余子式**（英语：cofactor），后者在可以通过降低多阶矩阵的阶数来简化矩阵计算，并能和[转置矩阵](https://zh.wikipedia.org/wiki/转置矩阵)的概念一并用于[逆矩阵](https://zh.wikipedia.org/wiki/逆矩阵)计算。

- 元素$a_{ij}的$**代数余子式**(cofactor)可以记为:$C_{ij}=(-1)^{i+j}M_{ij}$,有时也记为$A_{ij}$(Algebraic cofactor).

- 余子式和代数余子式都是一个**数**

- (方阵的)**伴随矩阵**是由**代数余子式**构成的

### 代数余子式和余子式的区别

- **余子式**只计算去掉某行某列之后<u>剩余行列式的值</u>，
- 而**代数余子式**则需要考虑去掉的这一个元素对最后值<u>正负所产生的影响</u>。

- 对于**n阶行列式**而言,其包含的$n\times{n}$个元素都有各自的<u>余子式和代数余子式</u>


- In [linear algebra](https://en.wikipedia.org/wiki/Linear_algebra), a **minor** of a [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)) **A** is the [determinant](https://en.wikipedia.org/wiki/Determinant) of some smaller [square matrix](https://en.wikipedia.org/wiki/Square_matrix), cut down from **A** by removing one or more of its rows and columns. Minors obtained by removing just one row and one column from square matrices (**first minors**) are required for calculating matrix **cofactors**, which in turn are useful for computing both the determinant and [inverse](https://en.wikipedia.org/wiki/Inverse_matrix) of square matrices.

### 行列式的展开

- 对于n阶行列式$|A|$,行列式按行展开(第i行展开)

  - $$
    |A|=\sum_{k=1}^{n}a_{ik}C_{ik},i=1,2,\cdots,n
    $$

    - 其中$i$表示n阶行列式$|A|$的n每一行都满足该等式的意思
    - k表示第i行的第1个元素到第n个元素的指标
    - $a_{ik}$是行列式第i行第k列的**元素**
    - $C_{ik}$(或者写作$A_{ik}$)是"$a_{ik}$关于行列式|A|的**代数余子式**",是一个**数**
      - $C_{ik}=(-1)^{i+k}M_{ik}$

- 按列展开类似

  - $$
    |A|=\sum_{k=1}^{n}a_{kj}C_{kj},j=1,2,\cdots,n
    $$

    

#### 展开性质推广🎈

- 向量展开指的是用矩阵的第i个向量和第j个向量的代数余子式向量进行**点积**(内积)计算

  - 第i个向量记为$\alpha_i=(a_{i1},\cdots,a_{in})$

  - 第j个向量的代数余子式记为$\beta_{j}=(C_{j1},\cdots,C_{jn})$,是向量$\alpha_{j}=(a_{j1},\cdots,a_{jn})$各元素的代数余子式构成的

  - $\alpha_{i}\cdot\beta_{j}=\sum_{k=1}^{n}a_{ik}C_{jk}$

  - $$
    \alpha_{i}
    $$

    

- 融合上述写法:

- $$
  T=\sum_{k=1}^{n}a_{ik}C_{jk}=\sum_{k=1}^{n}a_{ki}C_{kj}
  =\delta(i,j)|A|
  =\begin{cases}
  0,i\neq{j}
  \\|A|,i=j
  \end{cases}
  \\i,j=1,2,\cdots,n
  \\Note:a_{ik}C_{jk}和a_{ki}C_{kj}下标k位置是对应的
  $$



## 伴随矩阵和可逆矩阵🎈

- $$
  A_{n\times{n}}=  
  \begin{pmatrix}  
    a_{11}& a_{12}& \cdots  & a_{1n} \\  
    a_{21}& a_{22}& \cdots  & a_{2n} \\  
    \vdots & \vdots & \ddots & \vdots \\  
    a_{n1}& a_{n2}& \cdots  & a_{nn}  
  \end{pmatrix}
  \\A^*_{n\times{n}}=(A_{ij})^T_{n\times{n}}
  =\begin{pmatrix}  
    A_{11}& A_{21}& \cdots  & A_{n1} \\  
    A_{12}& A_{22}& \cdots  & A_{n2} \\  
    \vdots & \vdots & \ddots & \vdots \\  
    A_{1n}& A_{2n}& \cdots  & A_{nn}  
  \end{pmatrix}
  \\A_{ij}表示a_{ij}关于方阵A=(a_{ij})_{n\times{n}}的代数余子式
  \\(A_{ij})_{n\times{n}}表示方阵A的代数余子式矩阵
  $$

  - $(A_{ij})^T_{n\times{n}}$是方阵A的**伴随矩阵**,简称**伴随阵**

- $$
  AA^*=\begin{pmatrix}  
    a_{11}& a_{12}& \cdots  & a_{1n} \\  
    a_{21}& a_{22}& \cdots  & a_{2n} \\  
    \vdots & \vdots & \ddots & \vdots \\  
    a_{n1}& a_{n2}& \cdots  & a_{nn}  
  \end{pmatrix}
  \begin{pmatrix}  
    A_{11}& A_{21}& \cdots  & A_{n1} \\  
    A_{12}& A_{22}& \cdots  & A_{n2} \\  
    \vdots & \vdots & \ddots & \vdots \\  
    A_{1n}& A_{2n}& \cdots  & A_{nn}  
  \end{pmatrix}
  \\=\begin{pmatrix}  
    |A|& 0& \cdots  &0 \\  
    0& |A|& \cdots  & 0 \\  
    \vdots & \vdots & \ddots & \vdots \\  
    0& 0& \cdots  & |A|  
  \end{pmatrix}=|A|E
  \\
  A^*A=\begin{pmatrix}  
    A_{11}& A_{21}& \cdots  & A_{n1} \\  
    A_{12}& A_{22}& \cdots  & A_{n2} \\  
    \vdots & \vdots & \ddots & \vdots \\  
    A_{1n}& A_{2n}& \cdots  & A_{nn}  
  \end{pmatrix}\begin{pmatrix}  
    a_{11}& a_{12}& \cdots  & a_{1n} \\  
    a_{21}& a_{22}& \cdots  & a_{2n} \\  
    \vdots & \vdots & \ddots & \vdots \\  
    a_{n1}& a_{n2}& \cdots  & a_{nn}  
  \end{pmatrix}=|A|E
  \\AA^*=A^*A=|A|E
  $$

- $$
  设A可逆,AA^{-1}=E,AA^*=A^*A=|A|E
  \\(\frac{1}{|A|}A^*)A=(A\frac{1}{|A|})A^*=E
  \\
  \boxed{A^{-1}=\frac{1}{|A|}A^*
  }
  \\\boxed{(A^*)^{-1}=\frac{1}{|A|}A}
  $$

- 矩阵A是可逆的充要条件是$|A|\neq{0}$,当A可逆时,$A^{-1}=\frac{1}{|A|}A^*$

  - 若A可逆,则存在$B=A^{-1}$,使得$AB=E$
    - 两边同取行列式:$|AB|=|E|,即|A||B|=1$
    - 可见$|A|,|A^{-1}|\neq{0}$

  - 若$|A|\neq{0}$,则由$AA^*=A^*A=|A|E$可知
    - $A(\frac{1}{|A|}A^*)=(\frac{1}{|A|}A^*)A=E$,即矩阵A可逆,且$A^{-1}=\frac{1}{|A|}A^*$

- 若$A,B$都是n阶矩阵,且$AB=E$,则A,B均可逆(且A,B互为逆矩阵:$A^{-1}=B,B^{-1}=A$)

  - 对$AB=E$两边同取行列式,得到$|A||B|=|E|=1$,说明$|A|,|B|\neq{0}$,A,B均可逆($A^{-1},B^{-1}$均存在)
  - 对$AB=E$同时左乘$A^{-1}$,得到$B=A^{-1}$
  - 对$AB=E$同时右乘$B^{-1}$,得到$A=B^{-1}$
  - 所以$A^{-1}=B,B^{-1}=A$


### 例

- 对于可逆矩阵,可用一下公式求解二阶矩阵的可逆矩阵的逆矩阵

  - $$
    A=\begin{pmatrix}
      a  & b \\  
      c & d   
    \end{pmatrix}
    \\A^{-1}=\frac{1}{|A|}A^*=\frac{1}{ad-bc}
    \begin{pmatrix}
      d  & -b \\  
      -c & a   
    \end{pmatrix}
    \\其中A^*由A将主对角线对调,取副对角线的相反数得到
    $$

    

- 对于三阶以及更高阶的可逆方阵,采用初等变换法求解逆矩阵!


### numpy计算伴随矩阵

- [python - Why is the adjoint of a matrix in numpy obtained by np.matrix.getH() - Stack Overflow](https://stackoverflow.com/questions/39771056/why-is-the-adjoint-of-a-matrix-in-numpy-obtained-by-np-matrix-geth)
- numpy.linalg.det方法可以用来求方阵行列式
- numpy.linalg.inv方法可以用来求逆(行列式非0)
- 而伴随矩阵和逆矩阵的关系为$AA^*=|A|E$,$A^*=|A|A^{-1}$

## 符号矩阵计算方阵伴随矩阵的计算🎈

### 符号矩阵

- 对于n阶方阵:

  - **余子式**方阵记为$M_m$

  - **代数余子式方阵**记为$M_{c}$

  - $M_{c}$可以由两个同型方阵:**符号方阵S**和**余子式方阵**$M_m$元素对应乘积再转置(记为$M_{ac}=(S\odot M_{m})^T$得到

    - $$
      S
      =\begin{pmatrix}
      +1&-1&+1\\
      -1&+1&-1\\
      +1&-1&+1\\
      \end{pmatrix}
      $$

    - 所谓结合$\odot$,就是元素对应乘积(Hadamard product)

      - $M_{c}=c_{ij}=s_{ij}\cdot{r_{ij}},i,j=1,2,\cdots,{n}$

#### 符号矩阵的扩张规则

- $s_{ij}=(-1)^{i+j}$

- 构造符号矩阵的时候可以批量进行

  - 所有同阶的符号矩阵都是一致的
  - 高阶符号矩阵的右上角就是低阶符号矩阵
  - 只要确定第一个元素为1,后面的所有元素就都唯一地被确定下来
    - 利用`相邻元素取符号`这个规则张开符号矩阵
    - 可以逐行构造符号矩阵
      - 首先确定第一列的各个元素
        - $s_{i,1}=s_{i-1,1}$
      - 然后逐行填写每行元素
        - 填写$s_{i,j}=-s_{i,j-1}$
        - 也即是说,填写一个元素时,可以统一看它的前一个元素是什么,取相反数即可

- |  1   |  -1  |  1   |  -1  |
  | :--: | :--: | :--: | :--: |
  |  -1  |  1   |  -1  |  1   |
  |  1   |  -1  |  1   |  -1  |
  |  -1  |  1   |  -1  |  1   |


- 通常不超过3阶的矩阵我们才考虑使用伴随矩阵法来求解(否则计算量过大)
- 从表格可以看出,4阶可逆方阵的伴随矩阵的各个元素的符号($\pm$)矩阵
- 由于其对称性,转置之后表格不发生改变

#### 小结

- 表格中的元素的相邻元素符号取反
  - 这很有用,由于这个规律,我们可以一行行的从表格的第一个元素推导出来
    - 可以先确定首行和首列
    - 其他元素随意选定一个方向,一列列补全或者一行行补全
- 主对角线上的元素的符号全部为正
  - 因为住对角线上的元素的位置序对有j=i,即(i,i),所以i+j=i+i=2i(偶数)

- 计算完符号矩阵,开始计算各个元素的余子式部分的值,并填充到相应的位置.



## n阶方阵@行列式性质🎈

### 方阵取行列式操作

- 若A是n阶矩阵:

  - $A^{T}$是A的转置矩阵,则$|A^T|=|A|$
  - $|kA|=k^n|A|$

- 若A,B是n阶矩阵,$|AB|=|A||B|$:

  - 由于上述等式对$A,B$求行列式,并且两者可以进行矩阵乘法,因此它们是同阶行列式

  - 特别的:$|A^2|=|A|^2$

  - 对于可逆矩阵A,$AA^{-1}=E$,对其两边去行列式:$|A||A^{-1}|=|E|=1$,从而$|A^{-1}|=\frac{1}{|A|}=|A|^{-1}$

  - 更一般的:$|A^n|=|A|^n$

    - $$
      |A_1A_2\cdots{A_n}|=|A_1||A_2|\cdots{|A_n|}
      \\
      或\prod_{i=1}^{n}A_i=\prod_{i=1}^{n}|A_{i}|
      $$

  - 以n=2阶的情况为例

    - 考虑到特殊的拉普拉斯展开:

      - $$
        \begin{vmatrix}
        A_m& O_{m\times{n}}\\
        C_{n\times{m}}&B_n
        \end{vmatrix}
        =|A_m|\cdot|B_n|
        $$

      - 可以试图构造一个类似的$2n$阶行列式(m=n),记为D,使得D经过若干变换后向矩阵乘$AB$靠近(D中的某部分(某个子式)恰好是AB)

      - $c_{ij}=\sum_{k=1}^{n}a_{ik}b_{kj}$

      - 为简单起见,以n=2情况进行讨论,则$c_{ij}=a_{i1}b_{1j}+a_{i2}b_{2j}$

        - $c_{11}=a_{11}b_{11}+a_{12}b_{21}$
        - $c_{21}=a_{21}b_{11}+a_{22}b_{21}$
        - $c_{12}=a_{11}b_{12}+a_{12}b_{22}$
        - $c_{22}=a_{21}b_{12}+a_{22}b_{22}$

      - 为此,尝试执行变换:

        - $c_3+b_{11}c_1+b_{21}c_2$
        - $c_4+b_{12}c_1+b_{22}c_2;$

      - $$
        D
        =\begin{vmatrix}
        A&\mathcal{{0}}\\
        R&B
        \end{vmatrix}
        =\begin{vmatrix}
        a_{11}&a_{12}&0&0\\
        a_{21}&a_{22}&0&0\\
        r_{11}&r_{12}&b_{11}&b_{12}\\
        r_{21}&r_{22}&b_{21}&b_{22}
        \end{vmatrix}
        \\
        \xlongequal{c_3+b_{11}c_1+b_{21}c_2}
        \begin{vmatrix}
        a_{11}&a_{12}&a_{11}b_{11}+a_{12}b_{21}&0\\
        a_{21}&a_{22}&a_{21}b_{11}+a_{22}b_{21}&0\\
        r_{11}&r_{12}&b_{11}+r_{11}b_{11}+r_{12}b_{21}&b_{12}\\
        r_{21}&r_{22}&b_{11}+r_{21}b_{11}+r_{22}b_{21}&b_{22}
        \end{vmatrix}
        \\\\
        \xlongequal{c_4+b_{12}c_1+b_{22}c_2}
        \begin{vmatrix}
        a_{11}&a_{12}&a_{11}b_{11}+a_{12}b_{21}&
        a_{11}b_{12}+a_{12}b_{22}\\
        a_{21}&a_{22}&a_{21}b_{11}+a_{22}b_{21}&
        a_{21}b_{12}+a_{22}b{22}\\
        r_{11}&r_{12}&
        b_{11}+r_{11}b_{11}+r_{12}b_{21}&
        b_{12}+r_{11}b_{12}+r_{12}b_{22}\\
        r_{21}&r_{22}&
        b_{21}+r_{21}b_{11}+r_{22}b_{21}&
        b_{22}+r_{21}b_{12}+r_{22}b_{22}
        \end{vmatrix}
        $$

      - 然而,我们希望D的下面两行中有一个为全0分块方阵,并且应该是右下角的4个元素构成的子块方阵是全0的,以便使用拉普拉斯展开公式

      - 记右下加的矩阵为G:

      - $$
        G=
        \begin{pmatrix}
        b_{11}+r_{11}b_{11}+r_{12}b_{21}&
        b_{12}+r_{11}b_{12}+r_{12}b_{22}\\
        b_{21}+r_{21}b_{11}+r_{22}b_{21}&
        b_{22}+r_{21}b_{12}+r_{22}b_{22}
        \end{pmatrix}
        \\=\begin{pmatrix}
        b_{11}(1+r_{11})+r_{12}b_{21}&b_{12}(1+r_{11})+r_{12}b_{22}\\
        b_{21}(1+r_{22})+r_{21}b_{11}&b_{22}(1+r_{22})+r_{21}b_{12}
        \end{pmatrix}
        $$

        - 欲使G=0,则一组简单的解是

        - $$
          \begin{pmatrix}
          r_{11}&r_{12}\\
          r_{21}&r_{22}
          \end{pmatrix}
          =\begin{pmatrix}
          -1&0\\
          0&-1
          \end{pmatrix}
          $$

          

    - $$
      D=\begin{vmatrix}
      A&\mathcal{0}\\
      R&B
      \end{vmatrix}
      =\begin{vmatrix}
      A&X\\
      -E&\mathcal{0}
      \end{vmatrix}
      \\
      =\begin{vmatrix}
      a_{11}&a_{12}&a_{11}b_{11}+a_{12}b_{21}&
      a_{11}b_{12}+a_{12}b_{22}\\
      a_{21}&a_{22}&a_{21}b_{11}+a_{22}b_{21}&
      a_{21}b_{12}+a_{22}b{22}\\
      -1&0&0&0\\
      0&-1&0&0
      \end{vmatrix}
      $$

      - $D=|A||B|$
      - $D=(-1)^{2\times{2}}|X||-E|=|X|$
        - 其中$X=AB$
      - 因此$|D|=|X|=|AB|=|A||B|$

    - 对于n>2的情况,推到类似





