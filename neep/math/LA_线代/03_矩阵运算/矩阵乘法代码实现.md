[toc]



## 矩阵乘法代码实现

### C语言版

```
有2×3的矩阵a和3×2的矩阵b，求这两个矩阵相乘后的2×2矩阵c，并打印。

要求用函数实现   Multi(int a[][3],int b[][2],int c[][2])
矩阵a，b的值在主函数中输入。


输入
2×3的矩阵a和3×2的矩阵b

输出
这两个矩阵相乘后的2×2矩阵c，并打印。

样例输入
1 2 3
3 2 1

1 2
3 1
2 3
样例输出
13 13
11 11
 
```

```c
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
//在此下方插入自定义函数的声明:
void Multi(int a[][3], int b[][2], int c[][2]);
//主函数main
int main()
{

    int a[2][3], b[3][2], c[2][2];
    /* 两个二重循环读入数据 */
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            scanf("%d", &a[i][j]);
        }
    }
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            scanf("%d", &b[i][j]);
        }
    }
/* 调用执行矩阵计算的函数 */
    Multi(a, b, c);
    /* 将处理结果打印出来 */
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            /* 该行的最后一个元素索引是2,那就是在2之前的元素可以跟一个空格 */
            printf("%d", c[i][j]);
            if (j < 1)
            {
                printf(" ");
            }
        }
        //printf("%d\n");//发生了趣事:打印旧值
        printf("\n");
    }

    return 0;
}
//主函数结束.
//在下方编写自定义函数:
void Multi(int a[][3], int b[][2], int c[][2])
{

    /* mxk , kxn ;结果矩阵因该是mxn*/
    int m = 2; /* 矩阵A的行数 */
    int n = 2; /* 矩阵B的列数 */

    int p = 3; /* 矩阵A的列数必须和矩阵B的行数相同,该数值记为k */
    /* 结果矩阵的每一个元素值是一个k项式的和 */

    /* 记得用c中的元素累计值之前初始化c  */
    /* 由结果矩阵C的规格m*n可知,应该用连个循环来填充矩阵C而且行和列分别是m,n */
    for (int i = 0; i < m; i++) /* 控制行遍历(矩阵A的) */
    {
        for (int j = 0; j < n; j++) /* 控制列遍历(矩阵B的列) */
        {
            c[i][j] = 0;                //初始化累加计数器
            for (int k = 0; k < p; k++) /* k作为遍历元素的驱动器(为两个矩阵所共用(具体是,矩阵A横向遍历,矩阵B纵向遍历)) */
            {
                c[i][j] += a[i][k] * b[k][j]; //后者是b 矩阵
            }
        }
    }
}
```



### python 实现

- 对A逐行遍历

  - A的每一行都要对B逐列遍历

  - ```python
    ##
    import numpy as np
    rng = np.random.default_rng()
    m,l,n=3,4,5
    m,l,n=3,1,4
    A=rng.integers(1,10,size=(m,l))
    B=rng.integers(1,10,size=(l,n))
    #使用.dot()方法计算矩阵乘法(内积)
    ##
    C=A.dot(B)
    # 对于二维数组（矩阵）还可以用下列方式计算
    # np.matmul(A,B)
    # A@B
    A,B,C
    ##
    for i in range(m):
        for j in range(n):
            c_ij=0
            for k in range(l):
                # for p in range()
                c_ij+=A[i,k]*B[k,j]
            print("%s\t"%c_ij,end=" ")
        print()
    ##
    for i in range(m):
        for j in range(n):
            c_ij=A[i]*B[:,j]
            print("%s\t"%c_ij[0],end=" ")
            # print("%s\t"%c_ij,end=" ")
        print()
            
    ```

  - 矩阵乘法的三种计算方式的内容都是相同的



### numpy中的乘法

- [numpy.dot — NumPy v1.24 Manual](https://numpy.org/doc/stable/reference/generated/numpy.dot.html)

  - 多用途乘法(根据参数类型有不同的行为)
  - Dot product of two arrays. Specifically,
    - 低维数组和标量的行为:
      - If both *a* and *b* are 1-D arrays, it is inner product of vectors (without complex conjugation).
      - If both *a* and *b* are 2-D arrays, it is matrix multiplication, but using [`matmul`](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html#numpy.matmul) or `a @ b` is preferred.
      - If either *a* or *b* is 0-D (scalar)标量乘法, it is equivalent to [`multiply`](https://numpy.org/doc/stable/reference/generated/numpy.multiply.html#numpy.multiply) and using `numpy.multiply(a, b)` or `a * b` is preferred.
    - 高维数组行为:
      - If *a* is an N-D array and *b* is a 1-D array, it is a sum product over the last axis of *a* and *b*.
      - If *a* is an N-D array and *b* is an M-D array (where `M>=2`), it is a sum product over the last axis of *a* and the second-to-last axis of *b*:

- [numpy.matmul — NumPy  Manual](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html#numpy.matmul)

  - 矩阵乘法
  - 多维数组乘法

- [numpy.multiply — NumPy  Manual](https://numpy.org/doc/stable/reference/generated/numpy.multiply.html#numpy.multiply)

  - Multiply arguments element-wise.逐元素将参数相乘,参数可以是array_like

  - Parameters:

    - **x1, x2**array_like
    - Input arrays to be multiplied. If `x1.shape != x2.shape`, they must be broadcastable to a common shape (which becomes the shape of the output).它们必须可扩展到一个共同的形状（即输出的形状）

  - 按元素相乘参数。

  - ```python
    import numpy as np
    rng = np.random.default_rng()
    
    x1 = np.arange(9.0).reshape((3, 3))
    x2 = np.arange(3.0)
    x3=np.array([x2,x2,x2])
    x1, x2, np.multiply(x1, x2),np.multiply(x1, x3)
    ##
    y1=(10*rng.random((3,4))).round(1)
    y2=(10*rng.random(4,)).round(1)
    y1,y2,np.multiply(y1, y2)
    ##np.multiply可以用*号简写
    print("x1*x2=\n%s,\ny1*y2=\n%s"%(x1*x2,y1*y2))
    ```

  - ```bash
    (array([[0., 1., 2.],
            [3., 4., 5.],
            [6., 7., 8.]]),
     array([0., 1., 2.]),
     array([[ 0.,  1.,  4.],
            [ 0.,  4., 10.],
            [ 0.,  7., 16.]]),
     array([[ 0.,  1.,  4.],
            [ 0.,  4., 10.],
            [ 0.,  7., 16.]]))
            
    (array([[4.8, 0.6, 8.4, 1.5],
            [8.6, 6.6, 8.8, 6.1],
            [7.9, 6.7, 2.2, 2.1]]),
     array([4. , 0.5, 4.8, 8.6]),
     array([[19.2 ,  0.3 , 40.32, 12.9 ],
            [34.4 ,  3.3 , 42.24, 52.46],
            [31.6 ,  3.35, 10.56, 18.06]]))
    x1*x2=
    [[ 0.  1.  4.]
     [ 0.  4. 10.]
     [ 0.  7. 16.]],
    y1*y2=
    [[12.6  14.7  32.68 53.94]
     [38.43  0.63 11.18 64.38]
     [27.09 15.54 39.56 55.68]]
    ```

### broadcasting

- 在深度学习中，我们也使用一些不那么常规的符号。我们允许矩阵和向量相加，产生另一个矩阵：$C = A + b$，其中 $C_{i,j} = A_{i,j} + b_j$。换言之，向量 b 和矩阵A 的每一行相加。
  - 这个简写方法使我们无需在加法操作前定义一个将向量 b 复制到每一行而生成的矩阵。
  - 这种隐式地复制向量 b 到很多位置的方式，被称为 广播（broadcasting）。

- 相乘的两个矩阵可以是相同规格的,或者其中一个规格较小,但可以通过broadcasting操作得到可以相乘的规格[Broadcasting — NumPy v1.24 Manual](https://numpy.org/doc/stable/user/basics.broadcasting.html)
  - [General Broadcasting Rules](https://numpy.org/doc/stable/user/basics.broadcasting.html#general-broadcasting-rules)
  - [Broadcastable arrays](https://numpy.org/doc/stable/user/basics.broadcasting.html#broadcastable-arrays)
  - [A Practical Example: Vector Quantization](https://numpy.org/doc/stable/user/basics.broadcasting.html#a-practical-example-vector-quantization)
- The term broadcasting describes how NumPy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, <u>the smaller array is “broadcast” across the larger array so that they have compatible shapes.</u>
- Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. 
- It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.

#### 示例代码(矩阵内积)

- 内积,即2个矩阵(广播之后),执行对应元素乘法

- ```python
  ##
  import numpy as np
  rng = np.random.default_rng()
  m=3
  n=4
  A=rng.integers(1,9,size=(m,1))
  B=rng.integers(1,9,size=(1,n))
  print("%s@A;\n%s@B;\n%s@A*B;\n"%(A,B,A*B))
  
  ## matrix broadcasting (m,1)&(1,n)->(m,n)
  Amn=np.array([[A[l][0] for c in range(n)] for l in range(m)])
  Bmn=np.array([[B[0][c] for c in range(n)] for l in range(m)])
  # Bmn=np.array([B[0] for i in range(m)])
  print("%s@Amn\n%s@Bmn\n%s@Amn*Bmn\n"%(Amn,Bmn,Amn*Bmn))
  ```

- ```
  [[8]
   [4]
   [6]]@A;
  [[1 5 4 2]]@B;
  [[ 8 40 32 16]
   [ 4 20 16  8]
   [ 6 30 24 12]]@A*B;
  
  [[8 8 8 8]
   [4 4 4 4]
   [6 6 6 6]]@Amn
  [[1 5 4 2]
   [1 5 4 2]
   [1 5 4 2]]@Bmn
  [[ 8 40 32 16]
   [ 4 20 16  8]
   [ 6 30 24 12]]@Amn*Bmn
  ```



### pytorch中的乘法

- [torch.mm — PyTorch  documentation](https://pytorch.org/docs/stable/generated/torch.mm.html)