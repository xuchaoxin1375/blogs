

- C@python#矩阵乘法#numpy中的乘法#矩阵运算@矩阵乘法@矩阵转置@点积@内积@迹运算

## 矩阵乘法@矩阵标准乘积🎈



- 给定$m\times{l}$矩阵$A=(a_{ij})_{m\times{l}}$和$l\times{n}$矩阵$B=(b_{ij})_{l\times{n}}$

- 记A,B的乘积为$C=AB=(c_{ij})_{m\times{n}}$,C中的元素$c_{ij}$计算公式如下

  - $$
    c_{ij}=\sum\limits_{k=1}^{l}a_{ik}b_{kj}
    $$

  - A,B的规格保证了A的列数等于B的行数,<u>A的**行向量**中包含的元素数和B的**列向量**包含的元素都是$l$个</u>

  - 矩阵乘积的结果是一个矩阵,且规格(行数和列数)分别由第一个矩阵的行数和第二个矩阵的列数决定
  - 特别的,如果是两个向量(行向量乘以相同维数的列向量),结果是一个仅包含一个元素的矩阵(一般可以视为一个标量)
  - 如果两个同n维向量(列向量乘以行向量),结果是一个n阶方阵
  

### 代码实现

#### C语言版

```
有2×3的矩阵a和3×2的矩阵b，求这两个矩阵相乘后的2×2矩阵c，并打印。

要求用函数实现   Multi(int a[][3],int b[][2],int c[][2])
矩阵a，b的值在主函数中输入。


输入
2×3的矩阵a和3×2的矩阵b

输出
这两个矩阵相乘后的2×2矩阵c，并打印。

样例输入
1 2 3
3 2 1

1 2
3 1
2 3
样例输出
13 13
11 11
 
```

```c
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>
//在此下方插入自定义函数的声明:
void Multi(int a[][3], int b[][2], int c[][2]);
//主函数main
int main()
{

    int a[2][3], b[3][2], c[2][2];
    /* 两个二重循环读入数据 */
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            scanf("%d", &a[i][j]);
        }
    }
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            scanf("%d", &b[i][j]);
        }
    }
/* 调用执行矩阵计算的函数 */
    Multi(a, b, c);
    /* 将处理结果打印出来 */
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 2; j++)
        {
            /* 该行的最后一个元素索引是2,那就是在2之前的元素可以跟一个空格 */
            printf("%d", c[i][j]);
            if (j < 1)
            {
                printf(" ");
            }
        }
        //printf("%d\n");//发生了趣事:打印旧值
        printf("\n");
    }

    return 0;
}
//主函数结束.
//在下方编写自定义函数:
void Multi(int a[][3], int b[][2], int c[][2])
{

    /* mxk , kxn ;结果矩阵因该是mxn*/
    int m = 2; /* 矩阵A的行数 */
    int n = 2; /* 矩阵B的列数 */

    int p = 3; /* 矩阵A的列数必须和矩阵B的行数相同,该数值记为k */
    /* 结果矩阵的每一个元素值是一个k项式的和 */

    /* 记得用c中的元素累计值之前初始化c  */
    /* 由结果矩阵C的规格m*n可知,应该用连个循环来填充矩阵C而且行和列分别是m,n */
    for (int i = 0; i < m; i++) /* 控制行遍历(矩阵A的) */
    {
        for (int j = 0; j < n; j++) /* 控制列遍历(矩阵B的列) */
        {
            c[i][j] = 0;                //初始化累加计数器
            for (int k = 0; k < p; k++) /* k作为遍历元素的驱动器(为两个矩阵所共用(具体是,矩阵A横向遍历,矩阵B纵向遍历)) */
            {
                c[i][j] += a[i][k] * b[k][j]; //后者是b 矩阵
            }
        }
    }
}
```



#### python 实现

- 对A逐行遍历

  - A的每一行都要对B逐列遍历

  - ```python
    ##
    import numpy as np
    rng = np.random.default_rng()
    m,l,n=3,4,5
    m,l,n=3,1,4
    A=rng.integers(1,10,size=(m,l))
    B=rng.integers(1,10,size=(l,n))
    #使用.dot()方法计算矩阵乘法(内积)
    ##
    C=A.dot(B)
    # 对于二维数组（矩阵）还可以用下列方式计算
    # np.matmul(A,B)
    # A@B
    A,B,C
    ##
    for i in range(m):
        for j in range(n):
            c_ij=0
            for k in range(l):
                # for p in range()
                c_ij+=A[i,k]*B[k,j]
            print("%s\t"%c_ij,end=" ")
        print()
    ##
    for i in range(m):
        for j in range(n):
            c_ij=A[i]*B[:,j]
            print("%s\t"%c_ij[0],end=" ")
            # print("%s\t"%c_ij,end=" ")
        print()
            
    ```

  - 矩阵乘法的三种计算方式的内容都是相同的



#### numpy中的乘法

- [numpy.dot — NumPy v1.24 Manual](https://numpy.org/doc/stable/reference/generated/numpy.dot.html)

  - 多用途乘法(根据参数类型有不同的行为)
  - Dot product of two arrays. Specifically,
    - 低维数组和标量的行为:
      - If both *a* and *b* are 1-D arrays, it is inner product of vectors (without complex conjugation).
      - If both *a* and *b* are 2-D arrays, it is matrix multiplication, but using [`matmul`](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html#numpy.matmul) or `a @ b` is preferred.
      - If either *a* or *b* is 0-D (scalar)标量乘法, it is equivalent to [`multiply`](https://numpy.org/doc/stable/reference/generated/numpy.multiply.html#numpy.multiply) and using `numpy.multiply(a, b)` or `a * b` is preferred.
    - 高维数组行为:
      - If *a* is an N-D array and *b* is a 1-D array, it is a sum product over the last axis of *a* and *b*.
      - If *a* is an N-D array and *b* is an M-D array (where `M>=2`), it is a sum product over the last axis of *a* and the second-to-last axis of *b*:

- [numpy.matmul — NumPy v1.24 Manual](https://numpy.org/doc/stable/reference/generated/numpy.matmul.html#numpy.matmul)

  - 矩阵乘法
  - 多维数组乘法

- [numpy.multiply — NumPy v1.24 Manual](https://numpy.org/doc/stable/reference/generated/numpy.multiply.html#numpy.multiply)

  - Multiply arguments element-wise.逐元素将参数相乘,参数可以是array_like

  - Parameters:

    - **x1, x2**array_like
    - Input arrays to be multiplied. If `x1.shape != x2.shape`, they must be broadcastable to a common shape (which becomes the shape of the output).它们必须可扩展到一个共同的形状（即输出的形状）

  - 按元素相乘参数。

  - ```python
    import numpy as np
    rng = np.random.default_rng()
    
    x1 = np.arange(9.0).reshape((3, 3))
    x2 = np.arange(3.0)
    x3=np.array([x2,x2,x2])
    x1, x2, np.multiply(x1, x2),np.multiply(x1, x3)
    ##
    y1=(10*rng.random((3,4))).round(1)
    y2=(10*rng.random(4,)).round(1)
    y1,y2,np.multiply(y1, y2)
    ##np.multiply可以用*号简写
    print("x1*x2=\n%s,\ny1*y2=\n%s"%(x1*x2,y1*y2))
    ```

  - ```bash
    (array([[0., 1., 2.],
            [3., 4., 5.],
            [6., 7., 8.]]),
     array([0., 1., 2.]),
     array([[ 0.,  1.,  4.],
            [ 0.,  4., 10.],
            [ 0.,  7., 16.]]),
     array([[ 0.,  1.,  4.],
            [ 0.,  4., 10.],
            [ 0.,  7., 16.]]))
            
    (array([[4.8, 0.6, 8.4, 1.5],
            [8.6, 6.6, 8.8, 6.1],
            [7.9, 6.7, 2.2, 2.1]]),
     array([4. , 0.5, 4.8, 8.6]),
     array([[19.2 ,  0.3 , 40.32, 12.9 ],
            [34.4 ,  3.3 , 42.24, 52.46],
            [31.6 ,  3.35, 10.56, 18.06]]))
    x1*x2=
    [[ 0.  1.  4.]
     [ 0.  4. 10.]
     [ 0.  7. 16.]],
    y1*y2=
    [[12.6  14.7  32.68 53.94]
     [38.43  0.63 11.18 64.38]
     [27.09 15.54 39.56 55.68]]
    ```

#### pytorch中的乘法

- [torch.mm — PyTorch 2.0 documentation](https://pytorch.org/docs/stable/generated/torch.mm.html)

## Hadamard 乘积

- [Hadamard product (matrices) - Wikipedia](https://en.wikipedia.org/wiki/Hadamard_product_(matrices))

- 需要注意的是，两个矩阵的**标准乘积**不是指两个矩阵中对应元素的乘积。

- 不过，那样的矩阵操作确实是存在的，被称为 **元素对应乘积**（element-wise product）或者 Hadamard 乘积（Hadamard product），记为 $A\odot B$,其结果是一个与连个因子同型的矩阵。

  - $$
    c_{ij}=a_{ij}b_{ij}
    $$

    

## 向量点积@内积🎈

### 点积(内积)

- 两个同维数(规格)的n维<u>列向量</u>**向量** a 和 b 的 **点积**（dot product）可看作是矩阵乘积 $a^Tb$。

  - 有时也成为**内积**
  - 此处,维数指向量包含的元素个数

- $$
  {\displaystyle \mathbf {\color {red}a} \cdot \mathbf {\color {blue}b}
  =\sum _{i=1}^{n}{\color {red}a}_{i}{\color {blue}b}_{i}
  ={\color {red}a}_{1}{\color {blue}b}_{1}+{\color {red}a}_{2}{\color {blue}b}_{2}+\cdots +{\color {red}a}_{n}{\color {blue}b}_{n}}
  \\
  内积还常记为(a,b),即(a,b)=a\cdot{b}
  $$

  - 或$a\cdot{b}=\sum\limits_{i=1}^{n}(a\odot{b})_{i}$
    - $a\odot{b}$是向量a,b的hadamard积(向量)

- 向量点积的结果是一个**标量**

#### 性质

- 点积满足交换律(而一般的矩阵乘法是不满足交换律的)

- $(\alpha,\beta)=(\beta,\alpha)$

- $(k\alpha,{\beta})=(\alpha,k\beta)=k(\alpha,\beta)$

  - $$
    \sum_ik\alpha_i\beta_i
    =\sum_{i}\alpha_ik\beta_i
    =k\sum_{i}\alpha_{i}\beta_i
    $$

- $(\alpha+\beta,\gamma)=(\alpha,\gamma)+(\beta,\gamma)$

  - $$
    \sum_{i}(\alpha+\beta)_i\gamma_i
    =\sum_{i}(\alpha_i\gamma_i+\beta_i\gamma_i)
    =\sum_{i}\alpha_i\gamma_i+\sum_{i}\beta_i\gamma_i
    \\
    $$

- $(\sum\alpha_i,\beta)=\sum(\alpha_i,\beta)$

  - 是上一条结论的tui'gua
    $$
    \sum_{i}\left((\sum_{j}\alpha_j)\gamma_i\right)
    =\sum_{i}(\sum_{j}\alpha_j\gamma_i)
    $$
    

- $(\alpha,\alpha)\geqslant 0$当且仅当$\alpha=0$时,$(\alpha,\alpha)=0$

  - $$
    \sum_{i}(\alpha_i)^2\geqslant{0}
    $$

    



### 矩阵乘积和向量点积的关系

- 我们可以把矩阵乘积 C = AB 中计算 $c_{ij}=\sum\limits_{k=1}^{l}a_{ik}b_{kj}$ 的步骤看作是 A 的第 i 行和 B 的第 j 列之间的点积。

### 内积补充

- 内积是一个数学概念，也叫标量积、点积或数量积。它是一种将两个向量映射为一个实数的运算。它可以用来计算向量的夹角和长度。在英语中，内积叫做inner product.
  - by chatgpt
- **内积空间**（英语：Inner product space）是[数学](https://zh.wikipedia.org/wiki/数学)中的[线性代数](https://zh.wikipedia.org/wiki/线性代数)里的基本概念，是增添了一个额外的结构的[向量空间](https://zh.wikipedia.org/wiki/向量空间)。这个额外的结构叫做**[内积](https://zh.wikipedia.org/wiki/内积)**或[标量积](https://zh.wikipedia.org/wiki/标量积)。
- 内积将一对[向量](https://zh.wikipedia.org/wiki/向量)与一个标量连接起来，允许我们严格地谈论[向量](https://zh.wikipedia.org/wiki/向量)的“[夹角](https://zh.wikipedia.org/wiki/角)”和“[长度](https://zh.wikipedia.org/wiki/长度)”，并进一步谈论向量的[正交性](https://zh.wikipedia.org/wiki/正交)。
- 内积空间由[欧几里得空间](https://zh.wikipedia.org/wiki/欧几里得空间)抽象而来（内积是点积的抽象）

- 内积空间有时也叫做**准希尔伯特空间**（pre-Hilbert space）

## broadcasting

- 在深度学习中，我们也使用一些不那么常规的符号。我们允许矩阵和向量相加，产生另一个矩阵：$C = A + b$，其中 $C_{i,j} = A_{i,j} + b_j$。换言之，向量 b 和矩阵A 的每一行相加。
  - 这个简写方法使我们无需在加法操作前定义一个将向量 b 复制到每一行而生成的矩阵。
  - 这种隐式地复制向量 b 到很多位置的方式，被称为 广播（broadcasting）。

- 相乘的两个矩阵可以是相同规格的,或者其中一个规格较小,但可以通过broadcasting操作得到可以相乘的规格[Broadcasting — NumPy v1.24 Manual](https://numpy.org/doc/stable/user/basics.broadcasting.html)
  - [General Broadcasting Rules](https://numpy.org/doc/stable/user/basics.broadcasting.html#general-broadcasting-rules)
  - [Broadcastable arrays](https://numpy.org/doc/stable/user/basics.broadcasting.html#broadcastable-arrays)
  - [A Practical Example: Vector Quantization](https://numpy.org/doc/stable/user/basics.broadcasting.html#a-practical-example-vector-quantization)
- The term broadcasting describes how NumPy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, <u>the smaller array is “broadcast” across the larger array so that they have compatible shapes.</u>
-  Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. 
- It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.

### 示例代码(矩阵内积)

- 内积,即2个矩阵(广播之后),执行对应元素乘法

- ```python
  ##
  import numpy as np
  rng = np.random.default_rng()
  m=3
  n=4
  A=rng.integers(1,9,size=(m,1))
  B=rng.integers(1,9,size=(1,n))
  print("%s@A;\n%s@B;\n%s@A*B;\n"%(A,B,A*B))
  
  ## matrix broadcasting (m,1)&(1,n)->(m,n)
  Amn=np.array([[A[l][0] for c in range(n)] for l in range(m)])
  Bmn=np.array([[B[0][c] for c in range(n)] for l in range(m)])
  # Bmn=np.array([B[0] for i in range(m)])
  print("%s@Amn\n%s@Bmn\n%s@Amn*Bmn\n"%(Amn,Bmn,Amn*Bmn))
  ```
  
- ```
  [[8]
   [4]
   [6]]@A;
  [[1 5 4 2]]@B;
  [[ 8 40 32 16]
   [ 4 20 16  8]
   [ 6 30 24 12]]@A*B;
  
  [[8 8 8 8]
   [4 4 4 4]
   [6 6 6 6]]@Amn
  [[1 5 4 2]
   [1 5 4 2]
   [1 5 4 2]]@Bmn
  [[ 8 40 32 16]
   [ 4 20 16  8]
   [ 6 30 24 12]]@Amn*Bmn
  ```

## 矩阵乘法各种形式小结👌👌

- 矩阵乘法运算具有相当的重要性,为此从向量的角度再描述它

- 设矩阵A为$m\times{n}$的

  - $$
    A=\begin{pmatrix}
    	a_{11}  &a_{12}  &\cdots  &a_{1n}  	\\
    	a_{21}  &a_{22}  &\cdots  &a_{2n}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	a_{m1}  &a_{m2}  &\cdots  &a_{mn}  	\\
    \end{pmatrix}
    \\记\alpha_j
    =\begin{pmatrix}
    	a_{1j}  	\\
    	a_{2j}  	\\
    	\vdots		\\
    	a_{mj}  	\\
    \end{pmatrix},j=1,2,\cdots,n
    \\A=\begin{pmatrix}
    	\alpha_{1}&\alpha_{2}&\cdots&\alpha_{n}	\\
    \end{pmatrix}
    $$

  - $$
    记
    \beta_i=(a_{i1},a_{i2},\cdots,a_{in})
    \\
    A=
    \begin{pmatrix}
    	\beta_{1}\\
    	\beta_{2}\\
    	\vdots		\\
    	\beta_{m}	\\
    \end{pmatrix}
    $$

  - 注意$\alpha_i$和$\beta_i$不是转置关系

- 将矩阵写作行向量组和列向量组的分块矩阵形式:

  - $$
    A=
    \begin{pmatrix}
    	\alpha_{1}&\alpha_{2}&\cdots&\alpha_{n}	\\
    \end{pmatrix}
    =\begin{pmatrix}
    	\beta_{1}	\\
    	\beta_{2}	\\
    	\vdots		\\
    	\beta_{m}	\\
    \end{pmatrix}
    $$

- 类似的,设矩阵B为$n\times{s}$的矩阵

  - $$
    B=\begin{pmatrix}
    	b_{11}  &b_{12}  &\cdots  &b_{1s}  	\\
    	b_{21}  &b_{22}  &\cdots  &b_{2s}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	b_{n1}  &b_{n2}  &\cdots  &b_{ns}  	\\
    \end{pmatrix}
    \\
    B=(\gamma_1,\gamma_2,\cdots,\gamma_s)
    =\begin{pmatrix}
    	\theta_{1}\\
    	\theta_{2}\\
    	\vdots		\\
    	\theta_{n}	\\
    \end{pmatrix}
    \\\\
    $$

    

- 乘积:

  - $$
    C_{m\times{s}}=A_{m\times{n}}B_{n\times{s}},
    \\
    c_{ij}=\sum\limits_{k=1}^{n}a_{ik}b_{kj},(i=1,2,\cdots,m;j=1,2,\cdots,s)
    \\矩阵C记为C=(c_{ij})_{m\times{s}}
    $$

    - ```python
      for i in range_inclusive(1,m):
      	for j in range_inclusive(1,s):
              c_ij=0
              for k in range(l):
                  c_ij+=A[i][k]*B[k][j]
              print("%s\t"%c_ij,end=" ")
              
      #其中range_inclusive(a,b)表示生成[a,b]范围内的整数(包括边界在内)
      def range_inclusive(a,b)
      	return range(a,b+1)
      ```

      

  - $$
    C=AB=\begin{pmatrix}
    	\alpha_{1}&\alpha_{2}&\cdots&\alpha_{n}	\\
    \end{pmatrix}
    \begin{pmatrix}
    	\theta_{1}\\
    	\theta_{2}\\
    	\vdots		\\
    	\theta_{n}	\\
    \end{pmatrix}
    =\sum\limits_{i=1}^{n}\alpha_i\theta_i
    \\C,\alpha_i\theta_i都是m\times{s}的矩阵
    \\
    $$

    - 整个过程是手工计算时的过程
    - $\alpha_i\theta_i=\alpha_i\cdot{\theta_i}$相当于点积运算
    
  - $$
    C=AB=
    \begin{pmatrix}
    	\beta_{1}\\
    	\beta_{2}\\
    	\vdots		\\
    	\beta_{m}	\\
    \end{pmatrix}
    (\gamma_1,\gamma_2,\cdots,\gamma_s)
    =\begin{pmatrix}
    \beta_1\gamma_1&\beta_1\gamma_2&\cdots&\beta_1\gamma_s	\\
    \beta_2\gamma_1&\beta_2\gamma_2&\cdots&\beta_2\gamma_s	\\
    \vdots&\vdots&&\vdots\\
    \beta_m\gamma_1&\beta_m\gamma_2&\cdots&\beta_m\gamma_s	\\
    \end{pmatrix}_{m\times{s}}
    \\
    \\矩阵C的元素:c_{ij}
    =\beta_{i}\gamma_j
    =\sum\limits_{k=1}^{n}a_{ik}b_{kj},(i=1,2,\cdots,m;j=1,2,\cdots,s)
    \\\beta_{i}和\gamma_j分别是1\times{n},n\times{1}的矩阵(向量),
    \\他们的乘积\beta_{i}\gamma_j是一个仅含有一个数值元素的矩阵,
    \\C可以视为\beta_{i}\gamma_j构成的分块矩阵
    $$
  

### 使用点积的形式描述矩阵乘法

- 在掌握点积和矩阵-向量积的知识后，那么**矩阵-矩阵乘法**（matrix-matrix multiplication）应该很简单。


- 假设有两个矩阵$\mathbf{A} \in \mathbb{R}^{n \times k}$和$\mathbf{B} \in \mathbb{R}^{k \times m}$：

  - $$
    \mathbf{A}=\begin{bmatrix}
     a_{11} & a_{12} & \cdots & a_{1k} \\
     a_{21} & a_{22} & \cdots & a_{2k} \\
    \vdots & \vdots & \ddots & \vdots \\
     a_{n1} & a_{n2} & \cdots & a_{nk} \\
    \end{bmatrix},\quad
    \mathbf{B}=\begin{bmatrix}
     b_{11} & b_{12} & \cdots & b_{1m} \\
     b_{21} & b_{22} & \cdots & b_{2m} \\
    \vdots & \vdots & \ddots & \vdots \\
     b_{k1} & b_{k2} & \cdots & b_{km} \\
    \end{bmatrix}.
    $$

    

- 用行向量$\mathbf{a}^\top_{i} \in \mathbb{R}^k$表示矩阵$\mathbf{A}$的第$i$行，并让列向量$\mathbf{b}_{j} \in \mathbb{R}^k$作为矩阵$\mathbf{B}$的第$j$列。要生成矩阵积$\mathbf{C} = \mathbf{A}\mathbf{B}$，最简单的方法是考虑$\mathbf{A}$的行向量和$\mathbf{B}$的列向量:

  - $$
    \mathbf{A}=
    \begin{bmatrix}
    \mathbf{a}^\top_{1} \\
    \mathbf{a}^\top_{2} \\
    \vdots \\
    \mathbf{a}^\top_n \\
    \end{bmatrix},
    \quad \mathbf{B}=\begin{bmatrix}
     \mathbf{b}_{1} & \mathbf{b}_{2} & \cdots & \mathbf{b}_{m} \\
    \end{bmatrix}
    $$

    

- 当我们简单地将每个元素$c_{ij}$计算为点积$\mathbf{a}^\top_i \mathbf{b}_j$:
  $$
  \mathbf{C} = \mathbf{AB} = \begin{bmatrix}
  \mathbf{a}^\top_{1} \\
  \mathbf{a}^\top_{2} \\
  \vdots \\
  \mathbf{a}^\top_n \\
  \end{bmatrix}
  \begin{bmatrix}
   \mathbf{b}_{1} & \mathbf{b}_{2} & \cdots & \mathbf{b}_{m} \\
  \end{bmatrix}
  = \begin{bmatrix}
  \mathbf{a}^\top_{1} \mathbf{b}_1 & \mathbf{a}^\top_{1}\mathbf{b}_2& \cdots & \mathbf{a}^\top_{1} \mathbf{b}_m \\
   \mathbf{a}^\top_{2}\mathbf{b}_1 & \mathbf{a}^\top_{2} \mathbf{b}_2 & \cdots & \mathbf{a}^\top_{2} \mathbf{b}_m \\
   \vdots & \vdots & \ddots &\vdots\\
  \mathbf{a}^\top_{n} \mathbf{b}_1 & \mathbf{a}^\top_{n}\mathbf{b}_2& \cdots& \mathbf{a}^\top_{n} \mathbf{b}_m
  \end{bmatrix}.
  $$

- [**我们可以将矩阵-矩阵乘法$\mathbf{AB}$看作简单地执行$m$次矩阵-向量积，并将结果拼接在一起，形成一个$n \times m$矩阵**]。

### 对角阵的乘积🎈



- $$
  设矩阵P按列分块为:P=(\alpha_1,\cdots,\alpha_n)
  \\n阶对角阵\Lambda=diag(\lambda_1,\cdots,\lambda_n)
  \\
  P\Lambda
  =(\alpha_1,\cdots,\alpha_n)
  \begin{pmatrix}
     {{\lambda _1}} & {} & {} & {}  \cr 
     {} & {{\lambda _2}} & {} & {}  \cr 
     {} & {} &  \ddots  & {}  \cr 
     {} & {} & {} & {{\lambda _n}}  \cr 
  \end{pmatrix}
  =(\lambda_{1}\alpha_1,\cdots,\lambda_n\alpha_n)
  \\
  \\记Q=P^T
  \\
  \Lambda{Q}
  =\begin{pmatrix}
     {{\lambda _1}} & {} & {} & {}  \cr 
     {} & {{\lambda _2}} & {} & {}  \cr 
     {} & {} &  \ddots  & {}  \cr 
     {} & {} & {} & {{\lambda _n}}  \cr 
  \end{pmatrix}
  \begin{pmatrix}
  	\alpha_{1}\\
  	\alpha_{2}\\
  	\vdots		\\
  	\alpha_{n}	\\
  \end{pmatrix}
  =\begin{pmatrix}
  	\lambda_1\alpha_{1}\\
  	\lambda_2\alpha_{2}\\
  	\vdots		\\
  	\lambda_n\alpha_{n}	\\
  \end{pmatrix}
  $$
  
- $$
  \begin{pmatrix}
     {{a _1}} & {} & {} & {}  \cr 
     {} & {{a _2}} & {} & {}  \cr 
     {} & {} &  \ddots  & {}  \cr 
     {} & {} & {} & {{a _n}}  \cr 
  \end{pmatrix}
  \begin{pmatrix}
     {{b_1}} & {} & {} & {}  \cr 
     {} & {{b _2}} & {} & {}  \cr 
     {} & {} &  \ddots  & {}  \cr 
     {} & {} & {} & {{b _n}}  \cr 
  \end{pmatrix}
  =\begin{pmatrix}
     {{a_1b _1}} & {} & {} & {}  \cr 
     {} & {{a_2b _2}} & {} & {}  \cr 
     {} & {} &  \ddots  & {}  \cr 
     {} & {} & {} & {{a_nb _n}}  \cr 
  \end{pmatrix}
  $$

  - 也就是说,两个同型对角阵的矩阵乘法和hadamard运算结果一致$\Lambda_1\Lambda_2=\Lambda\odot\Lambda_2$

### 分块乘法

- $$
  P=(\alpha_1,\cdots,\alpha_n)
  \\
  A\in{\mathbb{R}^{n\times{n}}},P\in\mathbb{R}^{n\times{n}}
  ,AP\in\mathbb{R}^{n\times{n}},
  A\alpha_i\in\mathbb{R}^{n\times{1}}
  \\根据矩阵分块乘法:
  \\
  AP=A(\alpha_1,\cdots,\alpha_n)=(A\alpha_1,\cdots,A\alpha_n)
  $$

  

## 方阵的幂及其运算🎈

- $A^m=\underbrace{AA\cdots{A}}_{m个A}$
- $A^0=E$
- $A^kA^l=A^{k+l}$
- $(A^k)^l=A^{kl}$
- Note:一般的$(AB)^k=\underbrace{(AB)(AB)\cdots{(AB)}}_{k个(A)B}\neq{A^kB^k}$

## 矩阵乘法相关性质🎈🎈

### 矩阵乘法运算律

- 结合律:$(AB)C=A(BC)$
- **分配律**:(B,C同型时才成立)
  - 左乘分配律:$A(B+C)=AB+AC$
  - 右乘分配律:$(B+C)A=BA+CA$
  - Note:提取公共矩阵的时候也要求同型,否者不可以提取
- $\lambda{(AB)}=(\lambda{A})B=A(\lambda{B})$
- 限定消去律
  - $当方阵A可逆时,AB=AC\Rightarrow{B=C}$
    - 对$AB=AC$左乘$A^{-1}$,得到$B=C$
  - 对一般的矩阵A,不满足消去律$AB=AC\nRightarrow{B=C}$

#### 结合律@说明

- 结合律是值得多关注的一种矩阵乘法运算律
- 特别是标量和矩阵乘法的时候,假设矩阵$A\in{\mathbb{R}^{1\times{n}}}$,$B\in{R^{n\times{1}}}$,$C\in{\mathbb{R}^{n\times1}}$
  - 那么T=AB的结果是一个标量($T\in{R}$)
  - 从而(AB)C=TC
  - $A(BC)$是否和$(AB)C$相等?
    - 观察发现,矩阵$B$和$C$是无法相乘的,它们的形状制止了这一点
  - 这是为什么?
    - 通常,对于一个矩阵乘法链,要求$\prod_{i=1}A_i$,我们要求$A_i$的列数和$A_{i+1}$的行数要相等
    - 但是有一种情况是例外,也就是标量(矩阵形状为$1\times{1}$)的情况,这相当矩阵数乘
    - 这种情况下,就不能简单的讨论用结合律,要将乘积为标量的矩阵整体化
- 如果矩阵连中没有向量(或说没有那一部分乘积为标量),那么可以放心使用结合律

#### 证明结合律

- 设$A\in{\mathbb{R}^{m\times{n}}}$,$B\in{\mathbb R^{n\times{u}}}$,$C\in{\mathbb{R}^{u\times{v}}}$
- 记$M=AB$,$N=BC$
- $L=(AB)C=MC$
- $R=A(BC)=AN$
- 容易验证,$L,R\in{R^{m\times{v}}}$
- $M_{ij}=\sum_{k=1}^{n}A_{ik}B_{kj}$
- $N_{ij}=\sum_{k=1}^{u}B_{ik}C_{kj}$

- $L_{pq}=\sum_{r=1}^{u}M_{pr}C_{rq}=\sum_{r=1}^{u}\sum_{k=1}^{n}A_{pk}B_{kr}C_{rq}$

- $R_{pq}=\sum_{r=1}^{n}A_{pr}N_{rq}=\sum_{r=1}^{n}A_{pr}\sum_{k=1}^{u}B_{rk}C_{kq}$

  - 由于双重求和号调换顺序后结果不变:

    - $$
      R_{pq}
      =\sum_{r=1}^{n}\sum_{k=1}^{u}A_{pr}B_{rk}C_{kq}
      =\sum_{k=1}^{u}\sum_{r=1}^{n}A_{pr}B_{rk}C_{kq}
      $$

  - 同时求和号的指标字母不影响结果,对求和指标$r,k$进行原地翻转:

    - $$
      R_{pq}=\sum_{r=1}^{u}\sum_{k=1}^{n}A_{pk}B_{kr}C_{rq}
      $$

    - 可见$L_{pq}=R_{pq}$

      - $p=1,\cdots,m$;$q=1,\cdots,v$

    - 所以(AB)C=A(BC)



### 矩阵多项式

- $$
  设关于x的m次多项式:f(x)=\sum\limits_{i=0}^{m}a_ix^i
  \\则f(\bold{A})=\sum\limits_{i=0}^{m}a_i\bold{A}^i称为矩阵A的m次多项式
  $$

  

## 矩阵的转置🎈

- 转置（transpose）是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像,这条从左上角到右下角的对角线被称为 主对角线（main diagonal）。

- 我们将矩阵 $A\in\mathbb{R}^{m\times{n}}$ 的转置表示为 $A^T\in\mathbb{R}^{n\times{m}}$，定义如下(从$A^T$中的元素和$A$的关系描述)

  - $$
    (A^T)_{ij}=A_{ji}
    $$

    - $i=1,2,\cdots,n$
    - $j=1,2,\cdots,m$

- 向量:可以看作只有一列的矩阵。对应地，向量的转置可以看作是只有一行的矩阵。有时，我们通过将向量元素作为行矩阵写在文本行中，然后使用转置操作将其变为标准的列向量，来定义一个向量，比如 $x = [x1_,\cdots, x_n]^⊤$.
- 标量:可以看作是只有一个元素的矩阵。因此，标量的转置等于它本身，$a^⊤=a$

### 运算性质🎈🎈

- $(A^T)^T=A$

- $(\lambda{A})^T=\lambda{}A^T$

- $(A+B)^T=A^T+B^T$😊

  - $A^T+B^T=(A+B)^T$

  - $(\lambda E+B^T)=((\lambda{E})^T+B^T)=(\lambda E+B)^T$
    - 因为$E^T=E$,$(\lambda{E})^T=\lambda{E^T}=\lambda{E}$

- $(AB)^T=B^TA^T$(注意位置的调换)

- $$
  (A_1A_2\cdots{A_m})^T=A_m^TA_{m-1}^T\cdots{A_1^T}
  \\或(\prod_{i=1}^{m}A_i)^T=\prod_{i=1}^{m}A_{m-i+1}^T
  $$

### python实现矩阵转置🎈

- ```python
  import numpy as np
  rng = np.random.default_rng()
  ##
  m,n=4,5
  c = rng.random(size=(m,n))
  d=c.round(3)
  
  for i in d:
      # print(i)
      for j in i:
          print(j,end="\t")
      print()
  print("translating...","-"*10)
  l=len(d)
  for i in range(n):
      # print(i)
      for j in range(m):
          print(d[j,i],end="\t")
      print()
  ```
  
- ```
  0.502	0.208	0.014	0.633	0.065	
  0.035	0.117	0.387	0.086	0.369	
  0.181	0.328	0.649	0.76	0.225	
  0.741	0.432	0.881	0.795	0.597	
  translating... ----------
  0.502	0.035	0.181	0.741	
  0.208	0.117	0.328	0.432	
  0.014	0.387	0.649	0.881	
  0.633	0.086	0.76	0.795	
  0.065	0.369	0.225	0.597
  ```

#### 直接使用numpy提供的转置函数

- ```python
  np.transpose(d)
  ```

  - ```
    array([[0.502, 0.035, 0.181, 0.741],
           [0.208, 0.117, 0.328, 0.432],
           [0.014, 0.387, 0.649, 0.881],
           [0.633, 0.086, 0.76 , 0.795],
           [0.065, 0.369, 0.225, 0.597]])
    ```
  
  
  

##  迹运算🎈

- $Tr(A)=\sum_{i}A_{ii}$

  - 使用迹运算可以代替掉表达式中的某些求和号

- 迹运算可以让许多运算清楚的表示:

  - 例如描述矩阵的Frobenius 范数:

  - $$
    ||A||_F=\sqrt{\sum_{i,j}(a_{ij})^2}=\sqrt{Tr(AA^T)}
    $$

  - 迹运算在转置运算下是不变的:$Tr(A)=Tr(A^T)$

- 设$A_1,\cdots,A_n$可以连续相乘,且$A_{i_1},\cdots,A_{i_n}$也是可以连续乘的,那么$Tr(\prod_{i=1}A_i)=Tr(\prod_{j=1}A_{i_j})$

  - 其中$i_1,\cdots,i_n$表示$1,\cdots,n$的一种排列(共有$n!$中可能)
  - 对于本情景,可能远没有$n!$那么多,应为不是所有的排列后能够依然能够执行连续乘法

- 类似的矩阵乘法

  - $$
    Tr(\prod_{i=1}^{n}F^{(i)})
    =Tr(F^{(1)}\prod_{i=2}^{n}F^{(i)})
    =Tr(F^{(n)}\prod_{i=1}^{n-1}F^{(i)})
    \\
    F^{(i)}中的i表示第i个矩阵
    $$

    - $A\in\mathbb{R}^{m\times{n}}$,
    - $B\in{\mathbb{R}^{n\times{m}}}$
    - $Tr(AB)=Tr(BA)$


#### 交换律

- 即使循环置换后矩阵乘积的形状变了,但是计算的结果依然不变

  - $$
    记C=AB\in\mathbb{R}^{m\times{m}}
    \\D=BA\in\mathbb{R}^{n\times{n}}
    \\C_{ij}=\sum_{k=1}^{n}A_{ik}B_{kj}
    \\
    C_{ii}=\sum_{k=1}^{n}A_{ik}B_{ki}
    \\D_{ij}=\sum_{k=1}^{m}B_{ik}A_{kj}
    \\
    D_{ii}=\sum_{k=1}^{m}B_{ik}A_{ki}
    $$

  - $$
    A_{ij},B_{ij}都是标量,因此满足乘法交换律
    \\
    \mathbf{A}_{ij} \mathbf{B}_{ji}=\mathbf{B}_{ji}\mathbf{A}_{ij}
    $$

    

  - $$
    \mathrm{tr}(\mathbf{AB}) 
    = \sum_{i=1}^m (\mathbf{AB})_{ii} 
    =\sum_{i=1}^m (\mathbf{C}_{ii}) 
    = \sum_{i=1}^m (\sum_{k=1}^{n}A_{ik}B_{ki})
    = \sum_{i=1}^m (\sum_{j=1}^n (\mathbf{A}_{ij} \mathbf{B}_{ji}))
    \\
    \mathrm{tr}(\mathbf{BA})
    =\sum_{i=1}^n (\mathbf{BA})_{ii} 
    =\sum_{i=1}^n (\mathbf{D}_{ii} )
    =\sum_{i=1}^n (\sum_{k=1}^{m}B_{ik}A_{ki})
    =\sum_{k=1}^m \sum_{i=1}^n ( B_{ik}A_{ki})
    \\由于求和指标字母不影响求和结果,所以将k替换成i,再将i替换成j,从而:
    \\tr(BA)=\sum_{i=1}^m \sum_{j=1}^n ( B_{ji}A_{ij})
    =\sum_{i=1}^m \sum_{j=1}^n ( A_{ij}B_{ji})
    \\从而tr(AB)=tr(BA)
    $$

- 另一个有用的事实是**标量**在迹运算后仍然是它自己：$a = Tr(a)$

### 迹运算的分配律

- 假设矩阵$A^{(1)},\cdots,A^{(m)}$是同型矩阵(且都为n阶方阵),且$Q=\sum_{i=1}^{m}A^{(i)}$
- 则$tr(Q)=\sum_{i=1}^{n}Q_{ii}$
- 另一方面,$Q_{ij}=\sum_{k=1}^{m}A^{(k)}_{ij}$
  - $Q_{ii}=\sum_{k=1}^{m}A^{(k)}_{ii}$
  - $tr(Q)=\sum_{i=1}^{n}Q_{ii}=\sum_{i=1}^{n}(\sum_{k=1}^{m}A^{(k)}_{ii})$
    - $=\sum_{k=1}^{m}(\sum_{i=1}^{n}A_{ii}^{(k)})$
    - $=\sum_{k=1}^{m}tr(A^{(k)})$
- 可见$tr({\sum_{i=1}^{m}A^{(i)}})=\sum_{i=1}^{m}tr(A^{(i)})$



## 方阵行列式和特征值

- 行列式，记作 det(A)，是一个将方阵 A 映射到实数的函数。
- 行列式等于**方阵特征值的乘积**。$|A|=\prod_{i=1}{\lambda_i}$
- 行列式的**绝对值**可以用来衡量<u>矩阵参与矩阵乘法后</u>空间扩大或者缩小了多少。
  - 如果行列式是 0，那么空间至少沿着某一维完全收缩了，使其失去了所有的体积。
  - 如果行列式是 1，那么这个转换保持空间体积不变。



