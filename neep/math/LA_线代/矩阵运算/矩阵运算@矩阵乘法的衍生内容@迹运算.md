[toc]

## 方阵的幂及其运算🎈

- $A^m=\underbrace{AA\cdots{A}}_{m个A}$
- $A^0=E$
- $A^kA^l=A^{k+l}$
- $(A^k)^l=A^{kl}$
- Note:一般的$(AB)^k=\underbrace{(AB)(AB)\cdots{(AB)}}_{k个(A)B}\neq{A^kB^k}$

## 矩阵乘法相关性质🎈🎈

### 矩阵乘法运算律

- 结合律:$(AB)C=A(BC)$
- **分配律**:(B,C同型时才成立)
  - 左乘分配律:$A(B+C)=AB+AC$
  - 右乘分配律:$(B+C)A=BA+CA$
  - Note:提取公共矩阵的时候也要求同型,否者不可以提取
- $\lambda{(AB)}=(\lambda{A})B=A(\lambda{B})$

#### 限定消去律

- $当方阵A可逆时,AB=AC\Rightarrow{B=C}$
  - 对$AB=AC$左乘$A^{-1}$,得到$B=C$
- 对一般的矩阵A,不满足消去律$AB=AC\nRightarrow{B=C}$

### 分配律🎈

- $D=A(B+C)$;$E=AB+AC$



- $$
  A=\begin{pmatrix}
     a_{11}&  a_{12}&  \cdots&a_{1n} \\
      a_{21}&  a_{22}&  \cdots&a_{2n} \\
      \vdots&  \vdots&  &\vdots \\
      a_{m1}&  a_{m2}&  \cdots&a_{mn} \\
  \end{pmatrix}
  \\
  B=\begin{pmatrix}
     b_{11}&  b_{12}&  \cdots&b_{1p} \\
      b_{21}&  b_{22}&  \cdots&b_{2p} \\
      \vdots&  \vdots&  &\vdots \\
      b_{n1}&  b_{n2}&  \cdots&b_{np} \\
  \end{pmatrix}
  \\
  C=\begin{pmatrix}
     c_{11}&  c_{12}&  \cdots&c_{1p} \\
      c_{21}&  c_{22}&  \cdots&c_{2p} \\
      \vdots&  \vdots&  &\vdots \\
      c_{n1}&  c_{n2}&  \cdots&c_{np} \\
  \end{pmatrix}
  \\
  G=\begin{pmatrix}
     g_{11}&  g_{12}&  \cdots&g_{1q} \\
      g_{21}&  g_{22}&  \cdots&g_{2q} \\
      \vdots&  \vdots&  &\vdots \\
      g_{p1}&  g_{m2}&  \cdots&g_{pq} \\
  \end{pmatrix}
  $$

  - $$
    d_{ij}=\sum_{k=1}^{n}a_{ik}(b_{kj}+c_{kj})
    \\
    e_{ij}=\sum_{k=1}^{n}a_{ik}b_{kj}+\sum_{k=1}^{n}a_{ik}c_{kj}
    $$

    - 根据求和运算的性质可知,$d_{ij}=e_{ij}$因此$D=E$,即左分配律成立.

- 右乘分配律

  - $D'=(B+C)G$;$E'=BG+CG$

  - $$
    d'_{ij}=\sum_{k=1}^{p}(b_{ik}+c_{ik})g_{kj}
    \\
    e'_{ij}=\sum_{k=1}^{p}b_{ik}g_{kj}+\sum_{k=1}^{p}c_{ik}g_{kj}
    $$

    - 可见$d'_{ij}=e'_{ij}$,即$D'=E'$,右分配律成立

- 应用:

  - $(A+B)^2=(A+B)(A+B)=A(A+B)+B(A+B)=A^2+AB+BA+B^2$

  - $(A+B)(A-B)=A^2-AB+BA-B^2\not\xlongequal{通常}A^2-B^2$

    


#### 矩阵乘结合律@说明

- 结合律是值得多关注的一种矩阵乘法**运算律**

#### 包含向量的矩阵乘

- 特别是标量和矩阵乘法的时候,假设矩阵$A\in{\mathbb{R}^{1\times{n}}}$,$B\in{\mathbb{R}^{n\times{1}}}$,$C\in{\mathbb{R}^{n\times1}}$
  - 那么$T=AB$的结果是一个标量($T\in{R}^{}$)
  - 从而$(AB)C=TC$
  - $A(BC)$是否和$(AB)C$相等?
    - 观察发现,矩阵$B$和$C$是无法相乘的,它们的形状制止了这一点

### 矩阵乘法链👺

- 通常,对于一个矩阵乘法链,要求$\prod_{i=1}A_i$,我们要求$A_i$的列数和$A_{i+1}$的行数要相等
- 但是有一种情况是例外,也就是**标量**(矩阵形状为$1\times{1}$)的情况,这相当**矩阵数乘**
- 这种情况下,就不能简单的讨论用结合律

- 如果矩阵连中没有向量(或说没有那一部分乘积为**标量**),可以随意结合乘法链中相邻的<u>矩阵因子</u>($\large\prod_{i=p}^{q}A_i$)

#### 证明结合律

- 设$A\in{\mathbb{R}^{m\times{n}}}$,$B\in{\mathbb R^{n\times{u}}}$,$C\in{\mathbb{R}^{u\times{v}}}$

- 记$M=AB$,$N=BC$

- $L=(AB)C=MC$

- $R=A(BC)=AN$

- 容易验证,$L,R\in{R^{m\times{v}}}$

- $M_{ij}=\sum_{k=1}^{n}A_{ik}B_{kj}$

- $N_{ij}=\sum_{k=1}^{u}B_{ik}C_{kj}$

- $L_{pq}=\sum_{r=1}^{u}M_{pr}C_{rq}=\sum_{r=1}^{u}\sum_{k=1}^{n}A_{pk}B_{kr}C_{rq}$

- $R_{pq}=\sum_{r=1}^{n}A_{pr}N_{rq}=\sum_{r=1}^{n}A_{pr}\sum_{k=1}^{u}B_{rk}C_{kq}$

  - 由于双重求和号调换顺序后结果不变:

    - $$
      R_{pq}
      =\sum_{r=1}^{n}\sum_{k=1}^{u}A_{pr}B_{rk}C_{kq}
      =\sum_{k=1}^{u}\sum_{r=1}^{n}A_{pr}B_{rk}C_{kq}
      $$

  - 同时求和号的指标字母不影响结果,对求和指标$r,k$进行原地翻转:

    - $$
      R_{pq}=\sum_{r=1}^{u}\sum_{k=1}^{n}A_{pk}B_{kr}C_{rq}
      $$

    - 可见$L_{pq}=R_{pq}$

      - $p=1,\cdots,m$;$q=1,\cdots,v$

    - 所以$(AB)C=A(BC)$



### 矩阵多项式

- $$
  设关于x的m次多项式:f(x)=\sum\limits_{i=0}^{m}a_ix^i
  \\则f(\bold{A})=\sum\limits_{i=0}^{m}a_i\bold{A}^i称为矩阵A的m次多项式
  $$

  

## 矩阵的转置🎈

- 转置（transpose）是矩阵的重要操作之一。矩阵的转置是以对角线为轴的镜像,这条从左上角到右下角的对角线被称为 主对角线（main diagonal）。

- 一个简单的定义:把矩阵A的**行**换成同序数的**列**,得到的新矩阵称为$A$的转置矩阵,记为$A^\rm{T}$

- 我们将矩阵 $A\in\mathbb{R}^{m\times{n}}$ 的转置表示为 $A^T\in\mathbb{R}^{n\times{m}}$，定义如下(从$A^T$中的元素和$A$的关系描述)

  - $$
    (A^T)_{ij}=A_{ji}
    $$

    - $i=1,2,\cdots,n$
    - $j=1,2,\cdots,m$

- 向量:可以看作只有一列的矩阵。对应地，向量的转置可以看作是只有一行的矩阵。有时，我们通过将向量元素作为行矩阵写在文本行中，然后使用转置操作将其变为标准的列向量，来定义一个向量，比如 $x = [x1_,\cdots, x_n]^⊤$.

- 标量:可以看作是只有一个元素的矩阵。因此，标量的转置等于它本身，$a^⊤=a$

### 运算性质🎈🎈

- $(A^T)^T=A$

- $(\lambda{A})^T=\lambda{}A^T$

  - $B=\lambda{A}$,$b_{ij}=\lambda{a_{ij}}$

  - $C=B^T,c_{ij}=b_{ji}=\lambda{a_{ji}}$

  - $D=\lambda{A^T}$,$d_{ij}=\lambda{a_{ji}}$

  - $\therefore{c_{ij}=d_{ij}}$,即$(\lambda{A})^T=\lambda{A^T}$

- $(A+B)^T=A^T+B^T$(转置分配律)

  - $A^T+B^T=(A+B)^T$(逆分配律)

  - $(\lambda E+B^T)=((\lambda{E})^T+B^T)=(\lambda E+B)^T$
    - 因为$E^T=E$,$(\lambda{E})^T=\lambda{E^T}=\lambda{E}$

- $(AB)^T=B^TA^T$(注意位置的调换)

- $$
  (A_1A_2\cdots{A_m})^T=A_m^TA_{m-1}^T\cdots{A_1^T}
  \\或(\prod_{i=1}^{m}A_i)^T=\prod_{i=1}^{m}A_{m-i+1}^T
  $$

#### 关于矩阵加法的转置分配律

- $$
  A=\begin{pmatrix}
  	a_{11}  &a_{12}  &\cdots  &a_{1n}  	\\
  	a_{21}  &a_{22}  &\cdots  &a_{2n}  	\\
  	\vdots  &\vdots  &        &\vdots  	\\
  	a_{m1}  &a_{m2}  &\cdots  &a_{mn}  	\\
  \end{pmatrix}
  \\
  B=\begin{pmatrix}
  	b_{11}  &b_{12}  &\cdots  &b_{1n}  	\\
  	b_{21}  &b_{22}  &\cdots  &b_{2n}  	\\
  	\vdots  &\vdots  &        &\vdots  	\\
  	b_{m1}  &b_{m2}  &\cdots  &b_{mn}  	\\
  \end{pmatrix}
  \\
  C=A^T
    =\begin{pmatrix}
    	c_{11}  &c_{12}  &\cdots  &c_{1m}  	\\
    	c_{21}  &c_{22}  &\cdots  &c_{2m}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	c_{n1}  &c_{n2}  &\cdots  &c_{nm}  	\\
    \end{pmatrix}
    =\begin{pmatrix}
    	a_{11}  &a_{21}  &\cdots  &a_{m1}  	\\
    	a_{12}  &a_{22}  &\cdots  &a_{m2}  	\\
    	\vdots  &\vdots  &        &\vdots  	\\
    	a_{1n}  &a_{2n}  &\cdots  &a_{mn}  	\\
    \end{pmatrix}
  $$

- $P=A+B$,$p_{ij}=a_{ij}+b_{ij}$

- $Q=P^T,q_{ij}=p_{ji}=a_{ji}+b_{ji}$

- $R=A^T+B^T,r_{ij}=a_{ji}+b_{ji}$

- 容易知道$R,P$都是n行m列,且$q_{ij}=r_{ij}$,从而转置运算满足加法分配律

#### 关于矩阵乘法转置逆序分配律🎈

- 令$C=AB$,$c_{ij}=\prod_{k=1}^{n}a_{ik}b_{kj}$
- 令$D=C^{T},d_{ij}=c_{ji}=\prod_{k=1}^{n}a_{jk}b_{ki}$
- $E=B^{T}A^T$,$e_{ij}=\prod_{k=1}^{n}b'_{ik}a'_{kj}$=$\prod_{k=1}^{n}b_{ki}a_{jk}$
- 可见$D=E$,从而$(AB)^T=B^TA^T$

- 推广:$(\prod_{i}^{n}A_{i})^T=\prod_{i=1}^{n}A_{n-i+1}^T$(即:$(A_1A_2\cdots{A_n})^T=A_n^TA_{n-1}^T\cdots{A_{1}^T}$)

### python实现矩阵转置🎈

- ```python
  import numpy as np
  rng = np.random.default_rng()
  ##
  m,n=4,5
  c = rng.random(size=(m,n))
  d=c.round(3)
  
  for i in d:
      # print(i)
      for j in i:
          print(j,end="\t")
      print()
  print("translating...","-"*10)
  l=len(d)
  for i in range(n):
      # print(i)
      for j in range(m):
          print(d[j,i],end="\t")
      print()
  ```

- ```
  0.502	0.208	0.014	0.633	0.065	
  0.035	0.117	0.387	0.086	0.369	
  0.181	0.328	0.649	0.76	0.225	
  0.741	0.432	0.881	0.795	0.597	
  translating... ----------
  0.502	0.035	0.181	0.741	
  0.208	0.117	0.328	0.432	
  0.014	0.387	0.649	0.881	
  0.633	0.086	0.76	0.795	
  0.065	0.369	0.225	0.597
  ```

#### 直接使用numpy提供的转置函数

- ```python
  np.transpose(d)
  ```

  - ```
    array([[0.502, 0.035, 0.181, 0.741],
           [0.208, 0.117, 0.328, 0.432],
           [0.014, 0.387, 0.649, 0.881],
           [0.633, 0.086, 0.76 , 0.795],
           [0.065, 0.369, 0.225, 0.597]])
    ```

  

##  迹运算🎈

- $Tr(A)=\sum_{i}A_{ii}$

  - 使用迹运算可以代替掉表达式中的某些求和号

- 迹运算可以让许多运算清楚的表示:

  - 例如描述矩阵的Frobenius 范数:

  - $$
    ||A||_F=\sqrt{\sum_{i,j}(a_{ij})^2}=\sqrt{Tr(AA^T)}
    $$

  - 迹运算在转置运算下是不变的:$Tr(A)=Tr(A^T)$

- 设$A_1,\cdots,A_n$可以连续相乘,且$A_{i_1},\cdots,A_{i_n}$也是可以连续乘的,那么$Tr(\prod_{i=1}A_i)=Tr(\prod_{j=1}A_{i_j})$

  - 其中$i_1,\cdots,i_n$表示$1,\cdots,n$的一种排列(共有$n!$中可能)
  - 对于本情景,可能远没有$n!$那么多,应为不是所有的排列后能够依然能够执行连续乘法

- 类似的矩阵乘法

  - $$
    Tr(\prod_{i=1}^{n}F^{(i)})
    =Tr(F^{(1)}\prod_{i=2}^{n}F^{(i)})
    =Tr(F^{(n)}\prod_{i=1}^{n-1}F^{(i)})
    \\
    F^{(i)}中的i表示第i个矩阵
    $$

    - $A\in\mathbb{R}^{m\times{n}}$,
    - $B\in{\mathbb{R}^{n\times{m}}}$
    - $Tr(AB)=Tr(BA)$


#### 交换律

- 即使循环置换后矩阵乘积的形状变了,但是计算的结果依然不变

  - $$
    记C=AB\in\mathbb{R}^{m\times{m}}
    \\D=BA\in\mathbb{R}^{n\times{n}}
    \\C_{ij}=\sum_{k=1}^{n}A_{ik}B_{kj}
    \\
    C_{ii}=\sum_{k=1}^{n}A_{ik}B_{ki}
    \\D_{ij}=\sum_{k=1}^{m}B_{ik}A_{kj}
    \\
    D_{ii}=\sum_{k=1}^{m}B_{ik}A_{ki}
    $$

  - $$
    A_{ij},B_{ij}都是标量,因此满足乘法交换律
    \\
    \mathbf{A}_{ij} \mathbf{B}_{ji}=\mathbf{B}_{ji}\mathbf{A}_{ij}
    $$

    

  - $$
    \mathrm{tr}(\mathbf{AB}) 
    = \sum_{i=1}^m (\mathbf{AB})_{ii} 
    =\sum_{i=1}^m (\mathbf{C}_{ii}) 
    = \sum_{i=1}^m (\sum_{k=1}^{n}A_{ik}B_{ki})
    = \sum_{i=1}^m (\sum_{j=1}^n (\mathbf{A}_{ij} \mathbf{B}_{ji}))
    \\
    \mathrm{tr}(\mathbf{BA})
    =\sum_{i=1}^n (\mathbf{BA})_{ii} 
    =\sum_{i=1}^n (\mathbf{D}_{ii} )
    =\sum_{i=1}^n (\sum_{k=1}^{m}B_{ik}A_{ki})
    =\sum_{k=1}^m \sum_{i=1}^n ( B_{ik}A_{ki})
    \\由于求和指标字母不影响求和结果,所以将k替换成i,再将i替换成j,从而:
    \\tr(BA)=\sum_{i=1}^m \sum_{j=1}^n ( B_{ji}A_{ij})
    =\sum_{i=1}^m \sum_{j=1}^n ( A_{ij}B_{ji})
    \\从而tr(AB)=tr(BA)
    $$

- 另一个有用的事实是**标量**在迹运算后仍然是它自己：$a = Tr(a)$

### 迹运算的分配律

- 假设矩阵$A^{(1)},\cdots,A^{(m)}$是同型矩阵(且都为n阶方阵),且$Q=\sum_{i=1}^{m}A^{(i)}$
- 则$tr(Q)=\sum_{i=1}^{n}Q_{ii}$
- 另一方面,$Q_{ij}=\sum_{k=1}^{m}A^{(k)}_{ij}$
  - $Q_{ii}=\sum_{k=1}^{m}A^{(k)}_{ii}$
  - $tr(Q)=\sum_{i=1}^{n}Q_{ii}=\sum_{i=1}^{n}(\sum_{k=1}^{m}A^{(k)}_{ii})$
    - $=\sum_{k=1}^{m}(\sum_{i=1}^{n}A_{ii}^{(k)})$
    - $=\sum_{k=1}^{m}tr(A^{(k)})$
- 可见$tr({\sum_{i=1}^{m}A^{(i)}})=\sum_{i=1}^{m}tr(A^{(i)})$

