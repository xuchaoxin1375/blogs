@[toc]
# 定点数位数扩充(补齐)

- 有时候,给定真值的二进制表示位数较短,为了对齐机器字长(寄存器字长),需要扩充位数
- 扩充后的机器码所对应的真值与扩充前的真值相等🎈
- 主要讨论3种机器码的扩充问题
  - 原码(T(x))
  - 补码(O(x))
  - 反码(A(x))

## 正数的机器码扩充

- 正数的机器码扩充比较容易,因为T(x)=O(x)=A(x)
- 它们都是在边缘补0
  - 整数在高位补0
  - 小数在低位补0

## 负数的机器码扩充

- 不同的机器码具有
  - 共同点:
    - 符号位不变
  - 不同点:
    - 补位数码规律不同

### 原码

- 符号保持不变
  - 整数扩充:高位补0
  - 小数扩充:低位补0

### 反码

- 符号保持不变
  - 整数扩充:高位补1
  - 小数扩充:低位补1

### 补码

- 符号保持不变
  - 整数扩充:高位补1(也就是符号位)
  - 小数扩充:低位补0

# 定点数的移位运算

## 算数移位

- 算数移位的对象是有符号数(机器数)
  - 移位过程中,**符号位**保持不变
  - 相当于对被移动的**有符号机器数**$x$的真值(二进制形式)做相应的移动

### 算数移位的实质

- $设真值x的机器码为X(x)$
  - X可以取(原码/补码/反码)函数中的任意一个
- $对X(x)进行算数移位,就是为了对真值x进行乘以基数r或者除以基数r的操作$
  - 十进制数中也有类似的操作,只不过通常我们移动的是小数点,来达到类似的效果
  - 二进制计算机以2为基数;十进制数以10为基数
  - 移位之后,真值需要补位(而且总是补0)
    - 左移引起低位缺失,补0
    - 右移引起高位缺失,补0
- 而二进制机器码对真值的0/1串做了处理,因此对应到机器码里的补位需要分别讨论

## 逻辑移位

- 逻辑移位将操作数视为**无符号数**
- 移位和添补规则:
  - 逻辑左移:
    - 高位移丢
    - 低位添0
  - 逻辑右移:
    - 低位移丢
    - 高位添0

### 对比算数移位

- 逻辑移位将寄存器中的数最高位视为数值位,一并参与移动
- 算数右移:(以单符号位为例)
  - 不移动最高位(符号位),被移动的位从第二位开始

#### 例

- 寄存器中的内容为:**<u>x=10110010</u>**
  - 对其进行逻辑右移
    - 01011001
  - 对其进行算数右移
    - 如果将其视为补码,做右移1位操作:1,1011001
  - 为了避免上述x左移最高位丢1,可使用带进位($C_y$)的左移(将**符号位**)移入$C_y$

## 循环移位

- 分为:
  - 带进位标志CF的循环移位(大循环)
  - 不带进位标志的循环移位(小循环)
- 主要特点
  - 移除的数位又被移入到数据中
  - 是否带进位:取决于是否将进位标志CF加入循环移位

- 循环移位特别适合将数据的低字节数据和高字节数据互换

##  二进制移位操作

- 计算机中小数点的位置是事先约定的,

  - 因此,二进制表示的==机器数==在相对于小数点作n 位左移或右移时,**其实质就是**该数乘以或除以 $2^{n}(n=1,2, \cdots, n)$

  - 对于带符号数$s=\pm\sum\limits_{i=0}^{n}x_i2^i$

    - 左移一位(如果产生溢出)相当于乘以2

    - 右移一位(如果不考虑被因移位而被舍去的末尾位),相当于除以2

      



#  🎈单符号位定点小数的移位操作

## 结论 

- 负数的补码左移,低位补0(空位产生于低位)
- 负数的补码右移,高位补1(空位产生于高位)
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062211063166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)



### 声明

- 尽管您不记得该表格了,但是只要您会把不同机器码转为原码(或真值),您就可以通过原码来作为中介,通过原码的移位结果计算回转换前的机器码形式,也可以得到结果.

## 补位解释

- 总结出来的三种机器码的**移位填补规则**
  - 在负数部分,三种机器码的移位添补规律虽然各有不同特点
  - 但是体现在**真值**上的移位效果则较为一致:**<u>都是对真值进行补0</u>**

### 正数

- $由于x的原码,补码,反码相同,即:T(x)=C(x)=C_1(x)$

  - 所以,它们的补位操作一致

  - 我们以**原码**的补位为代表,容易知道,补的数是0

    

### 负数🎈🎁

- $机器数对应的真值x为负数时$

  1. 由于负数的原码数值部分与真值相同,故在移位时只要使符号位不变,其空位均添即可。

  2. 由于负数的反码各位除符号位外与负数的原码正好相反,故移位后所添的代码应与原码相反,即全部添1。

  3. 分析**任意负数x的补码T(x)**可发现

     - 从T(x)**由低位向高位**找到第一个“`1`”时(为了方面描述,称这个1为$x_\alpha$(即,第$\alpha$位小数$x_\alpha=1$))

     - $x_\alpha$左边的各位均**与对应的反码相同**

     - $x_\alpha$右边的各位(包括此$\alpha$在内)均**与对应的原码相同**

       - 🎈这个规律(现象是在移位操作之外就存在的),下面会给出推导过程

     - 故负数的补码左移时,因空位出现在低位,则添补的代码与原码相同,即添0;

     - 右移时因空位出现在高位,则添补的代码应与反码相同,即添1

     - ref:[为什么是这样的?](https://blog.csdn.net/xuchaoxin1375/article/details/127979480)

##  🎈例子

- 设**机器数字长为 8 位**  (  含 1 位符号位  ) ,

  -  若整数$A=\pm 26$,

  -  写出三种机器数左,右移一位和两位后的表示形式及对应的真值,

  -  并分析结果的正确性:

### 正数例子

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120806753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

  - 可见,对于正数,三种机器数移位后符号位均不变


  - 左移时最高数位丢1,结果**出错**;

  - 右移时最低数位丢1 ,影响**精度**。

### 负数例子

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120841344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

#### 🎈负数补码例

- 和移位前的二进制代码做对比

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120927890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

- 以下精度问题规律,可以从原码出发举例体验.

  - 负数的原码左移时,高位丢1,结果出错;右移时,低位丢1,影响精度。

  - 负数的补码左移时,高位丢0,结果出错;右移时,低位丢1,影响精度。

  - 负数的反码左移时,高位丢0,结果出错;右移时,低位丢0,影响精度。



# 🎈 双符号位算数移位

## 结论

- 双符号位具有判断溢出的便利特点
  - 当两位符号位相同(无溢出时)
    - 此时两位符号位都表示**真实符号位**
    - 移位规律按照**单符号位**的移位规律执行(补位)
  - 当两位符号位不同(溢出)
    - 此时**低位符号位**不是真实符号位!
      - 可将其理解为数值位
      - 此时对该位数进行右移,不会导致高位缺失!
      - 因此不需要补位,只需要将低符号位一并右移即可
      - 最后高符号位复制一份,覆盖低符号位即可
    - **低位符号位需要参与移动**,**高位符号位不参于移动**

## 解释



- 为了更加更好的理解,稍做推导

- $$
  设双符号位数x,y(补码):
  \\C(x)=x_{-1}x_0,x_1\cdots
  \\C(y)=y_{-1}y_{0},y_1\cdots
  \\C(s)=x+y=s_{-1}s_{0},s_1\cdots
  \\假设x,y是同号(y_{-1}=y_{0}=x_{-1}=x_{0}),同时x+y会引发进位:
  \\即:x_1+y_1+C_{2}\in\set{2,3}
  \\C_i表示从最低位(C_n)执行加法进位直到第i位相加产生进位
  \\(C_i将参与x_{i-1}+y_{i-1}+C_i运算)
  \\这种情况下,s_0=x_0+y_0+C_1产生的进位是有数值含义(位权)
  \\应该让s_0参与移位(通常在浮点数右归中操作)
  \\s_{-1}代表结果的真实符号位
  $$

  

- 符号位不参与移动

  - 符号位是单独处理(保持),
  - 在单符号位的**算数移位**中也是不参于移位的)

- 下面介绍的两数相加进位规律告诉我们,双符号位最高位为什么是最终(两数相加减真实正确结果)的符号位

  - 两数相减在计算机中也是转换为加法运算,因此仅讨论加法
  - 该规律只是原因之一,可以结合真值表来完整证明

## 例(补码双符号位)

- 一般双符号位移位在补码上用的比较多,(双符号位法计算**补码浮点数**加/减法中的规格化中会遇到)

- 对下面的双符号位小数(**补码**形式)进行移位操作
  - 00.11000
    - 00.01100
  - 11.110001
    - 11.1110001
  - 01.110001
    - 00.1110001
  - 10.110001
    - 11.0110001
