@[toc]

## 存储单元的地址分配

* 主存各`存储单元`的`空间位置`是由`单元地址号`来表示的,

* 而`地址总线`是用来`指出存储单元地址号`的,根据该地址可`读出或写人一个存储字` 

* 不同的机器`存储字长`也不同,为了满足字符处理的需要,常用`8位二进制数表示一个字节`,因此存储字长都取8(bit)的倍数 

* 通常计算机系统既可`按字`寻址,也可`按字节`寻址 
  * 例如IBM 370机器(记为A机器)的`字长为32位`,
    * 它可按`字节`寻址,即它的`每一个存储字包含4个可独立寻址的字节`,
    
    * 其地址分配如图(a)所示 
      
      
      
      * <table><thead><tr><th></th><th colspan="4">字节地址</th><th>Note</th></tr></thead><tbody><tr><td rowspan="3">字<br>地<br>址</td><td>0</td><td>1</td><td>2</td><td>3</td><td>w1</td></tr><tr><td>4</td><td>5</td><td>6</td><td>7</td><td>w2</td></tr><tr><td>8</td><td>9</td><td>10</td><td>11</td><td>w3</td></tr><tr><td colspan="6">IBM370机器</td></tr></tbody></table>
      
      * `字地址(word address)`的二进制分别是:0000,0100,1000
      
      * 该矩阵下,每一行代表该机器的一个字(word);
      
        * 行内的四个数字分别表示该字所包含的四个字节的四个**字节地址**
      
    * **字地址**是用(构成)该`字`(的4个字节中的)==高位字节的地址==来表示
    
    * 故其`字地址`是4(4Byte)整数倍,正好用`地址码`的`末两位`来区分`同一字`的`4个字节的位置` 
    
    * 对`24位地址线`的主存而言,按`字节`寻址的范围是16 M( $2^{24}=2^{4}\times 2^{20}=16M(Byte)$,
    
      * 地址线的位数直接决定了字节的寻址能力(范围,和机器相关的单位是`字`,也就是同样位数的地址线的寻址范围会因为不同的机器而不同);
      * 按`字`寻址的范围为4M(按字节寻址的范围宽度/存储字长=$2^{24}/4=4\cdot{2^{20}}=4M$)
        * 机器A的一个字包含4个Byte
    
  * 但对PDP -11机(记为B机器)而言,其`字长为16位`,字地址是2(Byte)的整数倍.
    * 它用`低位字节`的地址来表示`字地址`
    
      * <table><thead><tr><th></th><th colspan="2">字节地址</th><th>Note</th></tr></thead><tbody><tr><td rowspan="3">字<br>地<br>址</td><td>0</td><td>1</td><td>w1</td></tr><tr><td>2</td><td>3</td><td>w2</td></tr><tr><td>4</td><td>5</td><td>w3</td></tr><tr><td colspan="4">PDP-11</td></tr></tbody></table>
    
    - 对`24位地址线`而言,按`字节`寻址的范围仍为16 M
      - 但按`字`寻址的范围为8 M 

## 数据的存储和排列

* 现代计算机基本上都采用`字节编址`，即每个`地址编号`中存放1字节 
* 不同类型的数据占用的`字节数`不同，
  * int和 float型数据占4字节，double型数据占8字节等，而`程序中对每个数据只给定一个地址` 
  * 假设`变量i`的地址为08 00H，`字节`01H、23H、45H、67H应该各有一个`内存地址`(字节地址)
  * 那么地址08 00H对应4字节中`哪字节的地址(最高字节地址还是最低字节地址)`呢?

### 字节序

- 现代的计算机系统一般采用[字节](https://baike.baidu.com/item/字节)(Octet, 8 bit Byte)作为逻辑寻址单位 
- 当物理单位的长度大于1个字节时，就要区分字节序（Endianness），字节序是指处理器在处理多字节数据时，在寄存器和内存中保存字节的顺序 
- 为了简便起见它的英文也常常表示为 Byte Order 

- 目前在各种体系的计算机中通常采用的字节存储机制**主要有两种**：
  - Little-Endian 
  - Big-Endian 
  - 另外还有一种不常用的字节序Middle-Endian，又称为Mixed-Endian或者PDP-Endian，它是Little-Endian 和 Big-Endian的混合体 

- Big-Endian(BE)，是指数据的高字节(MSB)保存在内存的低地址中，而数据的低字节(LSB)保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；
- Little-Endian(LE)，是指数据的高字节(MSB)保存在内存的高地址中，而数据的低字节(LSB)保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致 

### MSB最高有效字节

- MSB(Most Significant Byte)，最高有效字节，指**多字节序列**中具有**最大权重**的[字节](https://baike.baidu.com/item/字节)，是<u>一个数据中权值最大的那一个字节 </u>

### LSB最低有效字节

- LSB(Least Significant Byte)，最低有效字节，指多字节序列中最小权重的字节，是一个数据中权值最小的那一个字节 

### 大/小端存放方式

#### 大端方式

- 从数据的**最高有效字节**到**最低有效字节**的顺序存储数据，即`最高有效字节存放在前面`;


#### 小端方式

- 按从最低有效字节到最高有效字节的顺序存储数据，即`最低有效字节存放在前面` 

#### 例子

-  保存十六进制数据01234567H(相当于32位二进制数)

  - ```python
    >>> bin(0x01234567)
    '0b1001000110100010101100111'
    ```

    

| 内存地址 | ...  | 0800H | 0801H | 0802H | 0803H | ...  |
| -------- | ---- | ----- | ----- | ----- | ----- | ---- |
| 大端方式 | ...  | 01H   | 23H   | 45H   | 67H   | ...  |
| 小端方式 | ...  | 67H   | 45H   | 23H   | 01H   | ...  |

* 通常的,一个数的**书写顺序**是从高位写到低位
  * 而<u>保存顺序却有两种,</u>从的低位开始保存(小端方式)或者从高位开始保存(大端方式)
  * 比如01H;23H;45H;67H
  * $MSB=01H$(最高权重字节)
  * $LSB=67H$(最低权重字节)
* 内存的地址从低地址到高地址增长
  * 大端方式是先存放数据的高位字节再存放低位字节
    * 例如1122H,**高位字节**11H先被存放在低地址内存单元处

  * 小端方式先存放的是数据的低位字节
    - 例如,1122H,低位字节22H先被存放在低地址内存单元

### 应用情况

- 我们常见的**大部分处理器都采用Little-Endian**，
  - 例如x86、6502、Z80、VAX以及PDP-11等；
- 使用Big-Endian的处理器通常是**Motorola的处理器**，
  - 例如：6800、68000、PowerPC 以及System/370等；
- 可切换的字节序(Bi-Endian)
  - 像ARM、[PowerPC](https://baike.baidu.com/item/PowerPC)、Alpha、SPARC V9、[MIPS](https://baike.baidu.com/item/MIPS/2173143)、PA-RISC和IA64等体系结构 **支持可切换的字节序**，
  - 这个特性可以提高效率或者简化网络设备和软件的逻辑 
  - 这种可切换的字节序被称为**Bi-Endian**，用于硬件上意指计算机或者传递数据时**可以使用两种不同字节序中任意一种的能力 **
- Middle-Endian 使用很少，偶尔会在一些小型机体系中的十进制数的压缩格式中出现



