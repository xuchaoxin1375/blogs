@[toc]

# 原码一位乘法:

## 笔算乘法

### 例

- 乘法A*B转换为关于A的若干次移位和加法(怎么移位的由乘数B的各个位来决定)
- 简单的加法运算(而且每次加法总是有一个操作数取值为A(或者0)(也就是被乘数或者0参与和 `此次加法前得到的部分积`的加法运算操作))

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622090640419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

* 从上面的加法/移位交替计算的过程中可以看到,加法结果每次移位,蓝绿色区域内的数就会增加一位,这些位都将作为最终的的''乘法''结果的低位
  * 他们不受后续高位计算的影响而改变数值(但是仍然参与移位)

- 上述演算中,可以看到,得到最终结果的过程中,**低位是最早被确定的**

  - 而且不受后续高位结果位的影响

  - 各层**部分积**的**低位**随着计算的进行,逐渐被作为**总结果的低位**而确定下来

    - **总结果的低位部分**和早期计算的**部分积的低位**是**一致**的

  - ![🥰04/02/2022 14:33:49](https://img-blog.csdnimg.cn/img_convert/aa1443fb8cf6518601fad851e0b08abb.png)

  - 既然部分积的最低位最早可以确定,那么将这一位保存到合适的位置后(即最终结果的最低位开始)),

    就可以将原先保存乘数的寄存器的低位用于存放别的数据(譬如新的部分积)

## 笔算乘法的改进

- $$
  \sum_{i=p}^{n}x_ir^{-i}
  \\
  =r^{-q}\sum_{i=p}^{n}x_ir^{q-i}
  \\p=q=1时:
  \\
  \sum_{i=1}^{n}x_ir^{-i}
  =r^{-1}(\sum_{i=1}^{n}x_ir^{1-i})
  =r^{-1}(x_1+\sum_{i=2}^{n}x_ir^{1-i})
  \\
  =r^{-1}(x_1+r^{-1}(x_2+\sum_{i=3}^{n}x_ir^{2-i}))
  \\
  =r^{-1}(x_1+r^{-1}(x_2+\cdots{r^{-1}(x_{n-1}+\sum_{i=n}^{n}x_ir^{(n-1)-i})}))
  \\
  =r^{-1}(x_1+r^{-1}(x_2+\cdots{r^{-1}(x_{n-1}+ r^{-1}(x_n+0))}))
  \\\\
  \sum_{i=1}^{n}x_ir^{-i}
  =r^{-1}(x_1+r^{-1}(x_2+\cdots{r^{-1}(x_{n-1}+ r^{-1}(x_n+0))}))
  \\
  K\sum_{i=1}^{n}x_ir^{-i}
  =Kr^{-1}(x_1+r^{-1}(x_2+\cdots{r^{-1}(x_{n-1}+ r^{-1}(x_n+0))}))
  \\=r^{-1}(Kx_1+r^{-1}(Kx_2+\cdots{r^{-1}(Kx_{n-1}+ r^{-1}(Kx_n+0))}))
  $$

  

- $$
  特别的,当r=2:
  \\
  \sum_{i=1}^{n}x_i2^{-i}
  =2^{-1}(x_1+2^{-1}(x_2+\cdots{2^{-1}(x_{n-1}+ 2^{-1}(x_n+0))}))
  \\
  K\sum_{i=1}^{n}x_ir^{-i}
  =2^{-1}(Kx_1+2^{-1}(Kx_2+\cdots{2^{-1}(Kx_{n-1}+ 2^{-1}(Kx_n+0))}))
  $$

  

- $$
  \\
  对于p\in[1,n]
  \\
  \sum\limits_{i=p}^{n}y_ir^{(p-1)-i}
  =r^{-1}\sum\limits_{i=p}^{n}y_ir^{(p)-i}
  =r^{-1}(y_p+\sum\limits_{i=p+1}^{n}y_ir^{p-i})
  \\
  二进制数移位形式的递推:
  \\
  \sum\limits_{i=p}^{n}y_i2^{(p-1)-i}
  =2^{-1}\sum\limits_{i=p}^{n}y_i2^{(p)-i}
  =2^{-1}(y_p+\sum\limits_{i=p+1}^{n}y_i2^{p-i})
  $$

  

- $$
  以小数为例:
  \\设,有真值x,y作乘数操作数,求它们的原码乘积,即T(x)T(y):
  \\T(x)=x_0.x_1x_2\cdots{x_n}
  \\T(y)=y_0.y_1y_2\cdots{y_n}
  \\x^*=|x|=0.x_1x_2\cdots{x_n}
  \\y^*=|y|=0.y_1y_2\cdots{y_n}
  \\ x_i,y_i\in\set{0,1}
  \\T(x)T(y)=x_0\oplus{y_0}.(0.x_1x_2\cdots{x_n})(0.y_1y_2\cdots{y_n})
  $$

- $$
  \\S=x^*\cdot{y^*}=x^*\cdot\sum\limits_{i=1}^{n}y_{i}2^{-i}
  \\=x^*(2^{-1}(x^*y_1+2^{-1}(x^*y_2+\cdots{2^{-1}(x^*y_{n-1}+ 2^{-1}(x^*y_n+0))})))
  \\
  为了便于描述:记部分积为
  \\
  \begin{cases}
  s_i=y_{n-(i-1)}\cdot{x^*}+z_{i-1}
  \\z_i
  =2^{-1}s_i
  =2^{-1}(y_{n-(i-1)}\cdot{x^*}+z_{i-1})
  ;(i\in{0,1,\cdots{,n}})
  \end{cases}
  \\\clubsuit则:z_i=2^{-1}s_i
  \\(可见,z_i可以由s_i直接右移1位得到)
  \\对于机器计算s_i时,要先执行乘数的移位(在表格法中,
  \\这个移位操作伴随着z_{i-1}的右移一起右移)
  \\以便得到对应的乘数bit:y_{n-(i-1)};然后在执行加法操作(+z_{i-1}),得到s_i
  \\
  $$
  
  
  
  - $$
    \\
    \begin{aligned}
    &z_0=0
    \\&z_1=2^{-1}s_1=2^{-1}(x^*y_n+z_0))
    \\&z_2=2^{-1}s_2=2^{-1}(x^*y_{n-1}+z_1))
    \\&\vdots
    \\&z_n=2^{-1}s_n=2^{-1}(x^*y_1+z_{n-1}))
    \end{aligned}
    \\可见S=x^*\cdot{y^*}=z_n;
    \\🎈RHS(等式右边),y的下标和z的下标之和为n
    \\\\
    \spadesuit再强调一下取值范围的事:
    \\
    \clubsuit x_i,y_i\in\set{0,1}
    \\这意味着,虽然递推式中包含了乘法的形式(x^*y_j,但实际上
    \\计算机执行的是加x^*或者加0即可
    \\用表格模拟上述策略,可以
    \\列出z_0\sim{z_n}共n+1行(n是乘数y的位数)
    $$
    
    
  
  
  
  - $$
    上述的z_1,z_2,\cdots,z_n每一个式子就是一轮操作
    \\(加法操作和移位操作的先后执行)
    \\再比较这些式子,它们在形式(结构上是一样的),
    \\不变的元素是因子2^{-1}(表示向右移位);
    \\x^*y_j中y_j不像x^*,在不同的z_i式子中可能是不同
    \\体现在机器做乘法的过程中,就是要连通乘数y^*也一并做右移位
    \\(使得乘数的末位就是参与分布乘法的bit)
    $$
  
    

#### 例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622090613645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

### 模拟机器计算一位原码乘法

#### 例

* $$
  \begin{aligned}
  &&0.1101
  \\&\times&0.1011
  \end{aligned}
  $$

  - 下面的列表计算中,(A=0.1101;B=0.1011)
    - 第1栏为对部分积的操作(包括加法和部分积移位)
      - 假设保存部分积的寄存器为$R_x$
    - 第2栏为乘数,包括对乘数的移位(调整并保持最后位bit的值是恰好可以用来计算$s_i$)
      - 假设保存乘数(以及部分积的低位)的寄存器为$R_y$
      - $B=0.y_1y_2y_3y_4$
      - 那么乘数列第$1,2,3,4$个值的末位分别:$y_4,y_3,y_2,y_1$
        - 它们先后被利用完就因为右移被逐个丢弃,右移空出来的高位使用来接纳部分积中的向右移位而被挤出来的位
        - 当$y_1$也被丢弃,那么乘法操作完成(结束)

* ![image-20220402161458539](https://img-blog.csdnimg.cn/img_convert/cdc15a3353fe66f60e6dcff0810a0678.png)

* 形成的最终结果分布在两个寄存器内

  * 结果的高位部分放在$R_1$中
  * 结果的低位部分则位于$R_2$中

## 小结

- 从递推公式中可以看出,被乘数$x^*$视为一个整体
  - 乘数$y^*$被分解为2的幂的和的形式下一个部分积(当前计算的部分积$z_i$用到上一个算好的部分积$z_{i-1}$)
  - 递推公式告诉我们,计算机内部使用
    - 加法联合移位两种计算机擅长的操作来实现乘法运算(间接)
    - 由$y_i\in\set{0,1}$容易知道,$x^*\cdot{y_i}\in{\set{x^*,0}}$
    - 如果乘数$y^*$有n位,那么该策略共需要进行n次加法操作和n次移位操作
    - 由乘数的**末位值(末位bit)t**确定被乘数是否与原部分积(上一次计算得到的部分积)**相加**
      - t=1,则加上被乘数
      - t=0,不加被乘数(加0代替之)
      - 然后**右移一位**(即乘以$2^{-1}$),形成新的部分积;
        - 同时,乘数也右移一位,使得<u>次低位</u>作**新的末位**,`空出最高位放部分积的最低位`
    - 每一轮计算(加操作/移位操作)中,加法计算在前,移位计算在后
      - 每次做加法时,**被乘数**仅仅与**原部分积的高位相加**
      - 其低位,被移出到乘数所空出的高位位置(寄存器)

* 用一个寄存器存放 `被乘数`,一个寄存器存放 `乘积` 另一个寄存器 存放 `乘数(已经用过的低位乘数不再保留)`及`乘积的低位(就是A*B的总结果的低位)`(共用一个寄存器,最终,乘数的各个位都被丢弃,而仅有乘积的较低位部分);
* 再配上加法器及其他相应电路,就可组成乘法器。
  * 又因加法只在部分积的`高位`进行,故不但节省了器材,而且还缩短了运算时间。








