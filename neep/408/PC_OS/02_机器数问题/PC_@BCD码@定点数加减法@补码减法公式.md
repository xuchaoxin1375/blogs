 [toc]

## 编码

### BCD码

- 用4为二进制数(可以表示$2^4=16$种不同的值)来表示10个十进制数0~9
  - 这种编码方法使得二进制数和十进制数可以快速进行转换
  - 容易发现,BCD码中有6中冗余码不代表某个十进制数

#### 8421BCD

- 有权BCD码
  - 权值从高到低为$8,4,2,1$
  - $b_4b_3b_2b_1$代表的十进制数就是按权展开$\sum\limits_{i=1}^{4}b_i2^{i-1}$
- 具有的6个冗余码为:$1010\sim{1111}$

##### 修正

- $两个4位8421BCD码相加的结果如果不大于9即:(1001)_{8421BCD}$,则不需要修正
- 否则需要修正:
  - $例如:15=6+9=0110_2+1001_2=1111_2$
    - 而$15=\underline{0001}\overline{0101}$,即,1,5的权分别用一个8421BCD码分别表示
    - 显然1111不是正确结果
  - 修正方法简单,假设某个结果X=A+B落在冗余码区间内的$1010\sim 1111$,则对X+6,即可
    - 从16进制的角度(对应4为8421BCD码)来看容易理解
    - 超过9的部分记为T落入冗余区间(跨度为$6(=0110_2$)),为了还原T,额外+6来填补冗余区间,还原了T,得到正确结果
    - $上例1111_2+0110_2=10101_2$用8421BCD表示(高位补0)得到$00010101_{8421BCD}$

##### BCD转10进制数

- 不同于按权展开,根据8421BCD的定义,将BCD二进制串从低位向高位每四个一组,分别转换为10进制的数码(0~9)中的一个即可
  - eg.$101001_{8421BCD}=29_{10}$

## 算数逻辑单元ALU

- ALU是一种功能强的组合逻辑电路
- 能够进行多种算数运算和逻辑运算
  - 加减乘除都能够归结为加法运算,ALU的核心是**带标志的加法器**





# 定点数加减计算

- 对于定点数
  - 小数点约定在最左边就是顶点小数;
  - 约定在最右边就是定点整数
- 实际上机器内部没有小数点
  - 因此在运算过程中,可以不考虑是小数还是整数,只需要关心它们的**符号**和**数值位**

## 补码加减法运算

- 不同于原码的加减法,(原码的符号位是单独处理,而不是统一做加法)
- 补码才可以将符号位和数值位一样做加法

###  补码加法的基本公式如下:

#### 加法

- $整数  \quad[A]_{补}+[B]_{补}=[A+B]_{补}\left(\bmod 2^{n+1}\right)$
  $小数  \quad[A]_{\text {补 }}+[B]_{补}=[A+B]_{补}(\bmod 2)$
- 即补码表示的两个数在进行加法运算时,可以把符号位与数值位同等处理,
  - 只要结果不超出机器能表示的数值范围,
    - 运算后的结果按  $ 2^{n+1}$  取模  (  对于整数  )
    - 或按 2 取模  (  对于小数  ) ,
  - 就能得到本次加法的运算结果。
- 可根据补码定义,按两个操作数的四种正负组合情况加以证明。


#### 减法

- $记y=A-B=A+(-B)$
- 则对上述三个表达式同时取补码
  -   $[y]_补=[A-B]_{补}=[A+(-B)]_{补}$

- 由补码加法基本公式,展开可得
- 整数$\quad[A-B]_{补}=[A]_{补}+[-B]_{补}\left(\bmod 2^{n+1}\right)$
- 小数$\quad[A-B]_{\text {补 }}=[A]_{\text {补}}+[-B]_{\text {补 }}(\bmod 2)$

#### 小结

- 符号位和数值位一起参与运算,加/减结果的符号位也在运算中直接得出
- 最终的运算结果保留最低位开始的n+1位(也就是能够刚好放在寄存器中),而更高位丢弃

#### 补码之间的减法:

- 此外,还成立:

  - $C=A-B$

    - $C(C)=C(A)-C(B)$
    - $C(C)=C(A)+C(-B)$

  - $$
    [A]_{补}-[B]_{补}=[A]_{补}+(-[B]_{补})\\
    =[A]_{补}+[-B]_{补}=[A-B]_{补}
    $$

    

- 这里的A,B都是真值.


- 因此,若机器数采用补码, 当求  A-B  时, 只需先求  $[-B]_{补}$
- $由C(B)求C(-B)是容易的,利用规律:$

  - $真值x的相反数-x的补码C(-x)可通过将C(x)的每一位(包括符号位)取反再加1得到$
  - $对于给定的A-B算式,通常A,B都是正数,从而x的补码和原码相同:C(x)=T(x)$

### 总结和案例

- 设机器数字长为8bit(含有1bit符号位)
  - 若A=+15;B=+24;
  - 记$y=A-B$;求:
    - $C(y)=C(A-B);$
    - 并从$C(y)$还原出y真值
- 分析:主要分为是3~4个步骤(第4个步骤取决于是否要得到真值形式)

#### 将真值用二进制表示

- A=+15=+0001111
- `B=+24=+(3*8)=+11*1000=+0011000`

#### 计算被减数,减数和减数相反数的补码

- 从真值直接得到对应的补码形式
  - 原码和真值仅相差符号位的表现形式而已
- C(A)=0,000 1111
- C(B)=0,001 1000或T(-B)=1,001 1000
  - 这两个用其中一个即可,取决于习惯,用来计算C(-B)
- C(-B)=1,110 0111+1=1,110 1000

##### 计算C(-B)有3条路🎈

- C(-B)=$\overline{C(B)}+1$

  - 无论B是正是负都适用
  - 利用的是真值(X)与真值相反数(-X)的补码间的关系
  - 这里$\overline{X}$表示对X所有bit取反(包括符号位一同取反)

- $C(-B)=\overline{data(T(-B))}+1$

  - 只有当B>0(-B<0)的情况下适用,
  - 这里$\overline{data(X)}$表示的是对$X$除了符号位以外的所有bit(数值位data bits)进行取反
    - $\overline{X}$和$\overline{data(X)}$是不同的(差异在于符号位是否参与取反,后者符号位不参于取反)
  - 利用的是负数的求补方法

- $C(-B)=PQ(T(-B))=P@Q$

  - $P@Q=\overline{Z[1:m-1]}@Z[m:n]$
  - m表示Z串的最后出现的1的位置
  - n表示Z串的最后一个bit的位置(长度)
  - 位置从高位1开始计数🎈
  - $Z=data(T(x))$表示T(x)的数值位部分
    - Z串中含有1的时候,Q串至少含有1个bit
    - 否则(Z串中没有1),那么更简单了,说明B=-B=0,C(-B)=0
  - @表示比特串拼接
  - 简写为$C(-B)=\overline{Z[:m-1]}@Z[m:]$🎈
  - 也即是说,**<u>只需要确定m的位置即可</u>**
  - 左右法,原理是,某个数的补码可以看做两部分,高部分和反码相同,低部分和原码相同
  - 这是唯一一种不需要末尾加一的方法了
    - 符号位不参于取反,保留T(x)的符号位
    - 虽然看上去形式复杂,但是操作起来却十分便利!
    - 比如说,本例中T(-B)=1,001 **<u>1</u>**000
      - 下线出就是位置m
      - 那么可以直接得出C(-B)=1,110 <u>**1**</u>000

  

#### 带入公式:

- C(y)=C(A-B)=C(A+(-B))=C(A)+C(-B)=0,000 1111+1,110 1000=1,111 0111
- T(y)=T(A-B)=1,000 1001

#### 按需还原为真值

- y=-000 1001=-9

### 手工计算顶点数减法(补码法)

- 记y=A-B
- y=A-B=C(C(y))=C(C(A-B))=C(C(A)+C(-B))

#### 例

- A=+10010;(18)
- B=+1011;(11)
- T(A)=0,10010
- T(B)=0,01011(在原码对齐位数,后期不易出错)
- C(-B)=PQ(T(-B))=PQ(1,01011)=1,10101
- y=A-B=10010-1011=C(C(A)+C(-B))=C(0,10010+1,10101)=C(10,00111)=C(0,00111)=+00111=+111



