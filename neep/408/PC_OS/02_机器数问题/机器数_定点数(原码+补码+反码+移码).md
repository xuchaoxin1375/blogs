[toc]

# 计算机中的数

## 机器数

- 机器数:把符号(+/-号)“数字化”的数称为**机器数**,

  - 一旦符号数字化后,符号和数值就形成了一种新的编码。

  - 在运算过程中,符号位能否和数值部分一起参加运算?

  - 如果参加运算,符号位又需作哪些处理?
    - 这些问题都与**符号位**和**数值位**所构成的**编码**有关，
      - 这些编码就是原码、补码、反码和移码。

## 真值

- 真值:生活中的带有正负号的数(正数/负数)称为**真值**
  - 真值是机器数所代表的**实际值**
- 计算机中,通常将符号和数值一起编码,将**符号数值化**
  - 通常用0表示正
  - 用1表示负

## 无符号数

- 计算机中的数均放在寄存器中通常称寄存器的位数为机器字长。
- 所谓无符号数,即没有符号的数,
  - 在寄存器中的每一位均可用来存放数值。
- 当存放有符号数时,则需留出位置存放符号。
- 因此,在机器字长相同时,无符号数与有符号数所对应的数值范围是不同的。
- 以机器字长为16位为例,
  - 无符号数的表示范围为0 ~65 535,
  - 而有符号数的表示范围为–32 768 ~ +32 767(此数值对应补码表示 )。

## 定点数和浮点数

- 根据小数点的位置是否固定,分为定点数和浮点数
  - 定点数
    - **定点补码整数**表示**整数**
  - 浮点数
    - **定点原码小数**表示**浮点数的尾数**
    - **移码**表示浮点数**阶码部分**

## 定点表示法

### 定点小数

- 定点小数是**纯小数**
  - 小数点位置在<u>符号位之后</u>,且在**有效数值部分(尾数)**<u>最高位</u>之前
  - $设X=x_0.x_1\cdots{x_n}$
    - $x_0为符号位$
    - $x_1\sim{x_n}是数值的有效部分$(尾数)
      - $x_1$最高有效位
- 定点整数是**纯整数**
  - 小数点位置位于:**有效数值部分**<u>最低位</u>之后; 
  - $设X=x_0x_1\cdots{x_n}.$
    - $x_0为符号位$
    - $x_1\sim{x_n}是数值的有效部分$(尾数)
      - $x_1$最高有效位
      - $x_n$为最低有效位

# 🎈定点数编码表示法

- 主要有:原码/反码/补码/移码

### Note

- 浮点数的定义要比定点数复杂的多,其结构更复杂,用到了多种编码表示法,而不单是一种
- 一个比较好的学习方式是结合大量的实例和练习来学习理解,而不是单纯盯着定义看



# 🎈原码

* 原码是最简单的机器数
*  符号位为0表示正数,符号位为1表示负数,
* **数值位**即**真值的绝对值**,(通常真值的<u>数值部分</u>以<u>二进制形式(0/1串)</u>表现出来(符号部分还是用+/-号),便于讨论和转换)
  * 原码表示又称为<u>带符号的绝对值表示</u>。
  * 为了书写方便以及区别整数和小数,约定
    * 整数的**符号位**与数值位之间用**逗号**隔开;
    * 小数的**符号位**与数值位之间用**小数点**隔开。

## 原码形式化定义

- 原码:TrueForm
- 注意,下面的公式(右侧)都是**真值运算**(如果还是机器数运算,那么展开的意义就不大了)
  - 而且采用二进制形式进行运算

### 整数原码

* $$
  T(x)=[x]_原=
  \begin{cases}
  x,&0\leqslant{x}<2^n
  \\2^{n}-x=2^{n}+|x|,&-2^{n}<x\leqslant{0}
  \end{cases}
  $$

* 形式化定义中:

  * $x为真值$
  * $n为整数位数$
    * 具体是指**,机器字长**(ML)中用于表示**数值位部分**的**位数**
      * 强调字长,是为了讨论<u>补齐问题</u>
      * 判断真值整数$x$的位数$n$时不考虑`±`符号
      * 位数是指x的二进制形式数值部分的二进制代码位数
    * 对于单符号位,机器字长ML=1+n;
    * (机器字长=符号位+数值位)
      * 例如,给定的机器字长位8bit,则n=8-1=7



### 小数原码

- $$
  T(x)=
  \begin{cases}
  x,&0\leqslant{x}<1
  \\
  1-x=1+|x|,&-1<x\leqslant{-1}
  \end{cases}
  $$

  

#### 例(整数)

$$
求两个真值x_1,x_2的原码:
\\
x_1=+1110_2;
x_2=-1110_2,
\\
解:
\\n=4
\\
T(x_1)=x_1=0,1110
\\\\
T(x_2)=2^4-(x_2)=+10000_2-(-1110_2)
\\
=11110
\\
=1,1110_2
$$



- $$
  基于上例中的x_1,x_2真值转为原码表示的例子;
  \\为了强调机器字长的重要性,现在假设字长为8bit;
  \\那么n=7
  \\
  x_1=+1110_2;
  x_2=-1110_2,
  \\
  T(x_1)=0,0001110(字长为8)
  \\
  T(x_2)=2^7+1110=1,0001110
  $$

  

#### 例(小数)

- $$
  x_1=+0.1101
  \\
  x_2=-0.1101
  \\
  机器字长为8bit;
  \\
  单符号位(占用1bit),数值部分位数为n=8-1=7
  \\
  T(x_1)=x_1=0.1101\underline{000}(包含了补齐数值位(3位))
  \\原码小数是向低位补0
  \\T(x_2)=1+|x_2|=1,1101\underline{000}(包含了数值位补齐3位)
  $$
  
  

#### 更多说明(verbose)

- 公式中考虑了符号位,即,将公式的右值转换为二进制代码,最高位自然就是符号位.(转化后的有符号数的位数将是`n+1`位)


- 这里提到的形式化定义公式在计算的时候可以都看作是无符号数(绝对值)之间的计算
  -   公式的展开已经将符号位考虑在数值计算中
  - 只需要在最终结果的二进制形式中划分出来作为最高位为符号位即可)

#### 取值范围:

- 联系上下文,机器字长设为n+1

  - 原码整数的表示范围关于原点对称:

  - $$
    -(2^n-1)\leqslant{x}\leqslant{2^n-1}
    \\即:
    如果字长为n+1=8
    \\那么以真值的范围为
    [-1111111_2,+1111111_2]
    $$

    

# 补码🎈🎈🎈

- 为了控制篇幅,将这部分内容单独成文
  - [PC_定点数_模+补码表示+补码相关性质_xuchaoxin1375的博客-CSDN博客](https://blog.csdn.net/xuchaoxin1375/article/details/127790409?csdn_share_tail={"type"%3A"blog"%2C"rType"%3A"article"%2C"rId"%3A"127790409"%2C"source"%3A"xuchaoxin1375"})



# 反码

- **反码**（英语：**1's complement**）
  - 反码也被称为1的补码

- 反码用的较少
  - 正数的反码和原码一致
  - 负数的反码,将原码的**数值位**各位取反即可得到
- 反码和补码:
  - $负数x的反码被定义为x的补码减1,即:(C(x)-1)$
  - $负数真值x的补码可以通过对x的反码+1的方式获得$
    - 也可以通过对<u>原码的数值位部分</u>**每位取反**得到

## 反码的形式化定义

### 整数

- $$
  A(x)=C_1(x)=[x]_反=
  \begin{cases}
  x,&0\leqslant{x}<2^n
  \\
  2^{n+1}+x=2^{n+1}-|x|,&-2^{n}\leqslant{x}\leqslant{0}
  \end{cases}
  (\mod 2^{n+1}-1)
  \\
  $$

#### 例

- $$
  x_1=+1101
  \\x_2=-1101
  \\
  取n=4
  \\
  C_1(x_1)=x_1=0,1101
  \\
  C_2(x_2)=x_2=2^{n+1}+x_2=2^5-1101=32-13=19=16+3
  \\=10000_2+11_2=10011_2=1,0011
  $$

  

### 小数

- $$
  C_1(x)=[x]_反=
  \begin{cases}
  x,&0\leqslant{x}<1
  \\
  (2-2^{-n})+x ,&-1<{x}\leqslant{0}
  \end{cases}
  (\mod 2-2^{-n})
  \\
  $$

  

#### 例

- $$
  x_1=+0.0110
  \\
  x_2=-x_1
  \\
  n=4
  \\
  C_1(x_1)=x_1=0.0110
  \\
  C_2(x_2)=2-2^{-n}+x_2=10.0000_{2}-0.0001_{2}-0.0110_2
  \\=1.0000_2+0.1111_2-0.0110_2
  \\=1.1001_2
  $$

### 0的反码

- $$
  设x_0=0.0000
  \\(取n=4)
  C_1(+0.0000)=0.0000
  \\
  C_1(-0.0000)=10.0000-0.0001-0.0000=1.1111
  \\显然,0在补码中有两种不相同的形式(正0和负0)
  $$

  

# 移码

- **移码**（英语：**Offset binary**）是一种
  - 将全0码映射为最小负值
  - 全1码映射为最大正值的编码方案
- **移码**经常用来表示**浮点数的阶码**

## 移码和补码的关系

- 移码就是在真值X上加上一个<u>常数(偏置值,通常为$2^n$)</u>

  - 相当于X在枢轴上向正方向偏移了若干个单位

  - $$
    O(x)=2^n+x(-2^n\leqslant{x}<2^n,机器字长为n+1)
    $$

    

### 例

- $$
  x_1=+10101
  \\x_2=-x_1
  \\字长为n+1=8位
  (数值位数为n=8-1=7)
  \\
  O(x_1)=2^7+x_1=1,0010101
  \\
  O(x_2)=2^7+x_2=1101011=0,1101011
  $$

### 特点

- 移码中真值0的表示唯一:

  - $$
    O(+0)=2^n+0
    \\
    O(-0)=2^n-0
    \\
    O(+0)=O(-0)=2^n=100\cdots{0},(n个0)
    $$

    

* **真值**x的移码和补码仅差一个**符号位**，$[x]_补$的符号位取反即得$[x]_移$
* (“1”表示正，“O”表示负，这与其他机器数的符号位取值正好相反)，反之亦然。
* 移码保持了数据原有的大小关系(单调映射)
  * $真值x_1<x_2,则O(x_1)<O(x_2)$



#  🎃原码,补码,反码规律总结

* 适用于定点数:
  * 整数以及小数

* 求解机器数相关问题,**分析正负是第一位**

  * 当然,有时候给出的是一个**无符号数**
    * 无符号数不属于<u>原码,补码和反码</u>这些机器数的讨论对象(它们的对象是有符号数!)
    * 那就直白的按照十进制转二进制或者维持原本的二进制即可
    * 但是,由于无符号数的**最高位**不是符号,因此**表示范围**主要差异

  * 有时候直接给出的是某个数x的补码(或者其他机器数)形式,但是**判断正负只要看第一位**
  * 这足够重要

* 求某个**真值x的三种机器数(原码/补码/反码)**表示的方法可归纳如下

  * 三种机器数的最高位均为符号位。

  * 将真值以**二进制形式**表示;
    * 符号位和数值部分之间可用".”(对于小数)或",”(对于整数)隔开。
    
    * $记号:x的原码T(x),x的补码C(x),x的反码A(x)$
    
    * 如果给定了**机器字长(n+1)**,还应该考虑将数值位位数不足的二进制补齐到n位长
    
    * 补齐操作的时机有两种选择:
    
      * 先将真值二进制(或者原码)补齐到n位
    
        * 然后在做机器数转换
    
      * 先转换后再做等值补齐到n位长(正数全部是补0)
    
      * 但是往往要对负数做处理:
    
        * 负数补码在补位(高位)是补的是1串(FH)
        * 其他机器数就较少用了
    
        
    
  * 当**真值为正(x>0)**时,<u>原码,补码和反码</u>的表示形式**均相同**,即符号位用“0”表示,数值部分与**真值**相同。

  * 当**真值为负(x<0)**时,<u>原码、补码和反码</u>的表示形式**不同**,

    * 但其符号位**都**用“1”表示(符号位相对于数值位**单独确定**)

    * 而**数值部分**有这样的关系,

      * **反码**是<u>原码$T(x)$</u>的“每位求反”

      * **补码**是<u>原码$T(x)$</u>的“求反加1”

* 特别的,由于$C(-x)可以由C(x)的每位取反再+1得到$

  * $如果用\overline{C(x)}表示对C(x)的每位(包括数值位)取反,那么有表达式$

    * $$
      C(-x)=\overline{C(x)}+1
      \\对于小数,可以理解为:
      \\C(-x)=\overline{C(x)}+2^{-n}
      $$

    * 注意,无论是从$T(x)求C(x)还是从C(-x)求C(x)$

      * 都不要忘记取反(它们的取法区别在于是否对符号位一起取反)后在加1的操作


## 注

* 反码为`原码的每位求反`不包括数值化后的`符号位`.
* 真值为负数的时候,转换为机器数的形式后,其符号位都用"1"表示,
  * 但是为什么是`1`是有推导过程(特别是按照国外有些教材的转换手法)
  * 上述的总结,是后面形式化转换公式的一种简单描述
    * 其**根据**是形式化定义,但不如形式化定义那样完备
    * <u>对于某些临界情况,使用公式会是更好的选择</u>
  * 譬如+0/-0的补码形式,采用公式的做法可以得出都是0



## 不同角度解读机器数

- 原码/补码/反码/移码都是有符号数	

- 限定机器字长(n+1)的情况下,机器可以表示的数(真值)的范围有所不同

  * 同一个`二进制代码`以不同种的机器数规则来解读,可能对应着不同的真值(真值取值范围)

  * 同一个`二进制代码`,它对应的`有符号机器数`的符号位`都是一致`的(机器数形式之间的转换不影响`符号位`)

## 🎈示例

### 由各种机器数求真值

- 转换方法有两类
  - 方法1:逆用形式化定义,(反函数)
  - 方法2:逆用口诀
    - 可以先转换为原码!
      - $C_1(x)\to{T(x)}:数值位各位取反即可$
      - $C(x)\to {T(x)}:数值位取反+1$
      - $O(x)\to{T(x)}:符号位取反得到补码,再利用上述过程(数值位取反+1)$
    - 原码$T(x)$转为真值:
      - $T(x)\to{x}:符号位转换操作:0\to{'+'},1\to{'-'}$

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621183246351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)
- 表格中的十进制数都是真值
  - 将同一个`二进制代码`以不同的机器数方式解读的时候对应的真值是不同的
  - 即,将<u>二进制代码</u>分别视为$U(x),T(x),C(x),C_1(x)$,分别求出对应的**十进制真值**
    - 单符号位(0为正,1为负)

- 二进制代码转为十进制数(不考虑最高位符号位)是最为直白的一种转换方式

  - 按权展开求和即可,将这种操作记为`操作A`

- 注:

  - 二进制代码以原码的角度解读,所作的转换工作也挺直白的(最简单的有符号数),相较于转为无符号数,只是`保留最高位作为符号位`,其余位(非符号位)按照上述`操作A`进行转换)

  * 将`数值位`部分的各个位`按位取反`,`最后再加1`(均以二进制形式表达)
    * 但有特殊情况(1000...0)这种形式的(比如下表中补码的`-128`)/以及(+0/-0)的补码(根据形式化公式来计算)
    * 真值`-128`如果要用字长为8的机器是无法直接表示(因为如果包括符号位在内,需要至少9位才能够存放的下)

### 🎈补码&真值 变化趋势

- $主要讨论负数(x<0)范围内$

  - $|C(x_1)|<|C(x_2)|\Leftrightarrow{x_1<x_2}$
    - $且x_2更接近0$
    - $|x_2|<|x_1|$
  - 更一般的,如果$x_1x_2>0(即x_1,x_2同号)$
    - $|C(x_1)|<|C(x_2)|\Leftrightarrow{x_1}<x_2$依然成立

  - 其中:
    - $|C(x)|$表示给定的某个补码串
    - $x表示真值$

- 上述规律将有符号的问题转化为无符号数问题(截掉符号位 .)

#### 例

- $如果C(x)=1.x_1x_2\cdots{x_n}$
  - $|C(x)|=x_1x_2\cdots{x_n}$
- $如果0>x>-32$
  - $C(-32)=C(-2^5)=1,100000$
    - $2^5=100000$
    - $011111+1=100000$
  - $C(x)=1,x_1x_2\cdots{x_n}$
  - 满足使用变化趋势规律使用条件:
    - $|C(x)|>|C(-32)|$
    - $x_1x_2\cdots{x_n}>100000$

## 🎈不同机器数的表示能力(范围)

### 关于真值

- $$
  设:x=x_0,x_1\cdots{x_n};x_i\in\set{0,1},i=1,2,\cdots,n
  \\则:
  \\
  |x|=0,x_1\cdots{x_n}
  \\
  -|x|=1,x_1\cdots{x_n}
  \\
  -x=\overline{x_0},x_1\cdots{x_n}
  $$

  

### 整数范围内

- 给定N+1位机器字长(N位数值位,这N位上的排列组合视为无符号数模型):
  - 整数:
    - 补码和移码的表示范围值最广的,每一个不同的编码都可以一个数,而且这些数不重合
    - 因此,每个bit上的取值有两种可能(0/1);N个bit可表示$2^N$个不同的整数
    - 原码和反码表示的数要少一个(最小值$-2^N$,且0占用了两个编码),因此只有$2^N$个不同的数
  - 小数:
    - 可表示数的个数和整数的情况类似
    - 移码不表示小数!
- 一般的:
  - 对于R进制,互不相同的N位R进制数有$R^N$个
    - 比如十进制R=10,N位十进制数有$R^N$个

#### 意义

- N位二进制代码可以精确表示的不同数有$2^N$个
  - 以整数为例:$如果给定的某一个数x不在2^N里面,意味着这个数x无法别精确表示$



