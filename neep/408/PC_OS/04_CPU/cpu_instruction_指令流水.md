[toc]

## 指令流水

- 指令流水类似于工厂的装配线:
  - 流水线，又称装配线，工业上的一种生产方式，指**每一个生产单位只专注处理某一个片段的工作**，以提高工作效率及产量。
  - 装配线利用了**产品在装配的不同阶,段其装配过程不同**这一特点,使<u>不同产品处在不同的装配段</u>上,即==每个装配段同时对不同产品进行加工==,这样可大大提高装配效率。
- 将这种装配生产线的思想用到指令的执行上,就引出了指令流水的概念。

------



- 同一时刻只有一条指令在执行,各功能部件的利用率不高
- 现代计算机普遍采用指令流水技术,统一时刻有多条指令在cpu的不同功能部件中并发执行
  - 大大提高了功能部件的并行性和程序的执行效率

## 提高处理机的并行性

- 时间上的并行技术
  - 将一个任务分解为不同的几个阶段,每个阶段在不同的功能部件上并行执行
  - 以便在同一个时刻执行多个任务,提升系统性能
  - 这种方法被称为指令**流水技术**
- 空间上的并行技术
  - 在一个处理机中设置多个**执行相同任务的功能部件**
  - 并且让这些功能部件**并行工作**,这样的处理机被称为**超标量处理机**(superscalar processor)

## 指令流水技术

- 一条指令的执行过程可以拆分为若干阶段
- 每个阶段有相应的功能部件完成
- 将各个阶段视为相应的**流水段(功能段)**,指令的执行过程就构成了一条流水线
  - 取指(IF):从存储器(cache)中取指令
  - 译码/读寄存器(ID):操作控制器对指令进行译码,同时从寄存器中取出操作数
  - 执行/计算地址(EX):执行运算操作或计算地址
  - 访存(MEM):对存储器进行读写操作
  - 回写(WB):将指令执行结果写回寄存器堆
- 将第k+1条指令的取指阶段提前到第k条指令的译码阶段
  - 第k+1条指令的译码阶段和第k条指令的执行阶段同时进行

### 理想流水

- 在理想的情况下,每个时钟周期都有一条指令进入流水线,
- 每个时钟周期也都有一条指令完成
- (平均)每条指令的时钟周期数都为1(即cpi=1)

### 指令流水设计原则

- 指令**流水段**个数以最复杂指令所用的功能段个数为准
- **流水段**的长度:以最复杂的操作所耗费的时间为准
  - 指的是每个流水段的长度(所有的流水段长度都相等)
- **基准时间**:就是流水段的长度

#### 例

- 假设某机器的某条最复杂指令的5个阶段耗时情况如下:
  - IF:200ps
  - ID:100ps
  - EXE:150ps
  - MEM:200ps
  - WB:100ps
  - 🎈为了便于讨论,和书写,将上述5个阶段分别记为A,B,C,D,E
- 那么流水段的长度(基准时间$\Delta{t}$)被定为200ps
- 每条指令的执行时间都达到了1000>750ps
  - 从这个角度上看,比串行执行的方式更加费时
- 但是,如果某个待执行程序中有N条指令
  - 对于单周期处理器
    - 串行执行所耗费时间为750N(ps)
  - 而流水线处理机需要的时间(理想情况下):
    - $t=(N-1+5)\times{200}ps$
      - 分析下表中每条指令的开头阶段(IF)可知,最后条指令的开头阶段将在第N个基准时间段解释执行
      - 当第N条指令的最后一个阶段执行完毕,这N条指令才全部执行完毕
      - $E_N$将在第N+k-1个基准时间段完成执行
  
- 例:

  - | ...   |               |               |               |               |               |               |               | ...           |               |                  |                  |
    | ----- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ---------------- | ---------------- |
    | $I_7$ |               |               |               |               |               |               | $A_7$         | $B_7$         | $C_7$         | $D_7$            | $E_7$            |
    | $I_6$ |               |               |               |               |               | $A_6$         | $B_6$         | $C_6$         | $D_6$         | $E_6$            |                  |
    | $I_5$ |               |               |               |               | $A_5$         | $B_5$         | $C_5$         | $D_5$         | $E_5$         |                  |                  |
    | $I_4$ |               |               |               | $A_4$         | $B_4$         | $C_4$         | $D_4$         | $E_4$         |               |                  |                  |
    | $I_3$ |               |               | $A_3$         | $B_3$         | $C_3$         | $D_3$         | $E_3$         |               |               |                  |                  |
    | $I_2$ |               | $A_2$         | $B_2$         | $C_2$         | $D_2$         | $E_2$         |               |               |               |                  |                  |
    | $I_1$ | $A_1$         | $B_1$         | $C_1$         | $D_1$         | $E_1$         |               |               |               |               |                  |                  |
    |       | $\Delta{t}_1$ | $\Delta{t}_2$ | $\Delta{t}_3$ | $\Delta{t}_4$ | $\Delta{t}_5$ | $\Delta{t}_6$ | $\Delta{t}_7$ | $\Delta{t}_8$ | $\Delta{t}_9$ | $\Delta{t}_{10}$ | $\Delta{t}{...}$ |

- 上面是一个5段**指令流水线**示意图表
  - 纵坐标$指令I$
  - 横坐标是$时间段\Delta{t}(或者时间t)$
- 另外还有**指令流水时空图**,
  - 横坐标为时间$t$
  - 纵坐标为空间$s$,表示一条指令的不同**功能段**(取指IF,...,写回WB)
- 每条指令可以拆分为5个阶段:A,B,C,D,E
  - 对于第i条指令:$A_i,B_i,C_i,D_i,E_i$
- 从$\Delta{t}_4$开始,指令流水线已经可以充分流动,效率达到最高
  - 假设程序有N条指令
  - 所有流水段的长度之间的关系$\Delta{t}=\Delta{t_i},i\in\{1,2,3,\cdots\}$
  - 每个$$\Delta{t}_i$$可以平均完成一条指令!($i\in[5,N]$)
    - 为什么说是平均完成?
      - 这是以工作总量(执行完成的功能段的总数上看的)
        - 如果每条指令5个功能段
        - 那么3条指令全部执行完毕经历了15个功能段的全部执行完毕
        - 对于上述表格所展示的,$\Delta{t_5}\sim{\Delta{t_7}}$的时间段内,总共完成了15个功能段
        - 因此说,是平均每个时间段$\Delta{t}$完成一条指令(工作量)
      - 我们以$\Delta{t}_5$为例,该时间段内,可以完成:$A_5,B_4,C_3,D_2,E_1$,它们是同时自行的,(也就是说,书写顺序不体现执行顺序和完成顺序,但是可以知道,它们都将在$\Delta{t}_5$这个时间段内全部完成,而且是并行执行(应该是在时间段$\Delta{t}_5$的起点同时启动这5个功能段的任务)
      - 容易看得到,不同指令的不同功能段在同一时间段内并行执行,充分利用了cpu的各个功能部件
      - 但是为了做到这一点,对指令集的设计具有一定要求,否则无法实现同一流水段执行不同指令的不同周期的目标
    - 根据上面的表格可以看出:
    - 在第$y=N+(5-1)=(N-1)+5=N+4$个基准时间段,N条指令尽数执行完毕
  - 从而,执行完所有指令耗费的时间(最理想的情况下)为:
    - $(N+4)\Delta{t}$
  - 平均每条指令耗费的时间为$t_a=\frac{(N+4)\Delta{t}}{N}$
    - 当$N\to{+\infin}时,t_a\to1$
    - $\lim\limits_{N\to{+\infin}}t_a=1$
- 例如
  - 程序中有7条指令($I_1\sim{I_7}$)
  - 在最理想的情况下,执行完7条指令耗费的时间是$11\Delta{t}$
    - 与代入公式$t=(N+4)\Delta{t}=11\Delta{t}$,是相符合的
  - 其中,在$\Delta{t}_5\sim{\Delta{t}_7}$这3个时间段每个时间段都能够平均完成一条指令
- 比较两种执行方式:
  - 为了便于比较,假设指令的各个功能功段执行完毕所要耗费的时间都是$\Delta{t}$
  - 那么串行执行耗时:$5N\Delta{t}$
  - 并行流水技术耗时:$(N+4)\Delta{t}$
  - $\eta=\frac{(N+4)\Delta{t}}{5N\Delta{t}}=\frac{1}{5}+\frac{4}{5N}$
  - $\lim\limits_{N\to{\infin}}\eta=\frac{1}{5}$
  - 也即是说,最理想的请况下,流水技术可将速度提升将近至5倍

### 小结

- 在对于整个程序(而非单条指令)而言,指令流水技术可以使得程序的执行效率大为提高
- 如果程序的指令非常多,那么可以使得cpi趋近于1
  - (每个周期就能够完成一条指令的执行)

### 利于指令流水的指令集设计原则

- 指令**长度应该尽量一致**,有利于化简取指令和指令译码操作
  - 否则,取指所花费时间长短不同,使得取指部件复杂,不利于指令译码
- 指令格式应该**尽量规整**
  - 尽量保证源寄存器的位置相同
  - 有利于在指令未知的时候就可以执行取寄存器操作数
  - 否二需要译码后才能够确定指令中各个寄存器编号位置
- 采用Load/Store指令,其他指令都不能访问存储器
  - 这样,可以吧Load/Store指令的地址计算和运算指令的执行步骤规整到同一个周期中,有利于减少操作步骤
- 数据和指令在计算机中对齐存放
  - 有利于减少访存次数
  - 使得所需要的数据在一个流水段(时间段)内就可以从内存中取得

### 流水线表示方式

#### 时空图

- **指令流水时空图**
  - 横坐标为时间$t$
  - 纵坐标为空间$s$,表示不同功能部件:
    - 取指部件IF,...,写回部件WB
    - 描述了各个功能部件在不同时间段在执行那条指令的(对应功能段)

- 例子

  - | 空间(部件)s |               |               |               |               |               |               |               |               |               |                  |                  |       |
    | ----------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ---------------- | ---------------- | ----- |
    | $WB$        |               |               |               |               | $I_1$         | $I_2$         | $I_3$         | $I_4$         | $I_5$         | $I_6$            | $I_7$            | ...   |
    | $MEM$       |               |               |               | $I_1$         | $I_2$         | $I_3$         | $I_4$         | $I_5$         | $I_6$         | $I_7$            | $I_8$            | ...   |
    | $EX$        |               |               | $I_1$         | $I_2$         | $I_3$         | $I_4$         | $I_5$         | $I_6$         | $I_7$         | $I_8$            | $I_9$            | ...   |
    | $ID$        |               | $I_1$         | $I_2$         | $I_3$         | $I_4$         | $I_5$         | $I_6$         | $I_7$         | $I_8$         | $I_9$            | $I_{10}$         | ...   |
    | $IF$        | $I_1$         | $I_2$         | $I_3$         | $I_4$         | $I_5$         | $I_6$         | $I_7$         | $I_8$         | $I_9$         | $I_{10}$         | ...              |       |
    |             | $\Delta{t}_1$ | $\Delta{t}_2$ | $\Delta{t}_3$ | $\Delta{t}_4$ | $\Delta{t}_5$ | $\Delta{t}_6$ | $\Delta{t}_7$ | $\Delta{t}_8$ | $\Delta{t}_9$ | $\Delta{t}_{10}$ | $\Delta{t}{...}$ | 时间T |


  - 例如,指令$I_1$的完整执行过程从$\Delta{t_1}\sim{\Delta{t_5}}$

    - 单元格$(\Delta{t_1},IF)=I_1$描述的是指令$I_1$在$\Delta{t_1}$时间段内,由功能部件IF进行取值处理
    - 单元格$(\Delta{t_2},ID)=I_1$描述的是指令$I_1$在$\Delta{t_2}$时间段内,由功能部件ID进行指令译码处理
    - ...
    - 单元格$(\Delta{t_5},WB)$描述的是指令$I_1$在$\Delta{t_5}$时间段内,由功能部件WB进行指令执行结果回写处理

  - 又例如:指令$I_2$的执行过程,从$\Delta{t_2}\sim\Delta{t_6}$

    - 单元格$(\Delta{t_2},IF)=I_2$描述的是指令$I_2$在$\Delta{t_2}$时间段内,由功能部件IF进行取值处理
    - 单元格$(\Delta{t_3},ID)=I_2$描述的是指令$I_2$在$\Delta{t_3}$时间段内,由功能部件ID进行指令译码处理
    - ...
    - 单元格$(\Delta{t_6},WB)$描述的是指令$I_2$在$\Delta{t_6}$时间段内,由功能部件WB进行指令执行结果回写处理

  - 又比如,

    - 单元格$(\Delta{t_7},EX)=I_5$,描述的是,指令$I_5在时间段\Delta{t_7}内由功能部件EX(运算/执行部件)执行$运算任务


#### 效率比较

- 从时空图可以看出,在$\Delta{t}_{10}$结束时,回写部件WB已经完成$I_6$指令的执行
  - 当然$I_1\sim{I_6}$全部完成
  - $I_7\sim{I_{10}}$指令的完成程度个不相同
    - $I_{10}$刚刚完成第一阶段(IF取值阶段)
    - 而$I_7$已经完成了MEM阶段,可以知道下一个$\Delta{t}$,就可以完成$I_7$的所有阶段
- 而如果是串行的方式执行,那么到$\Delta{t_{10}}$结束,就只有两条指令完成,
- 可见,流水技术的方式要高效得多

### 小结

-  只有在大量连续任务不断输入流水线才能够成分发挥流水线的性能
  - 指令的执行正好是连续不断的,比较适合采用流水线技术
- 流水线技术能够提升运算幂集型应用的性能
- 但是对于单个运算是无法提升性能

## 流水线的基本实现

- 单周期cpu的时钟频率取决于数据通路中的关键路径(最长路径)
- 虽然不是所有指令都必须经过5个(流水)阶段,但是只能够以执行速度最慢的指令作为设计其时钟周期的依据

### 流水线的数据通路

- IF(取指)
  - 程序计数器PC
  - 指令存储器
  - 下条指令地址的计算逻辑
- ID(译码)
  - 操作控制器
  - 取数操作逻辑
  - 立即数符号扩展模块
    - 用来将短数据扩展为长数(比如16bit立即数扩展为32bit)
- EX
  - 算数逻辑单元ALU
  - 分支地址计算模块(BranchAddress)
- MEM
  - 数据存储器读写模块
- WB
  - 寄存器写入控制模块

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/f0a3ecdb25334f46b037f34259317ebb.png)


#### 流水寄存器

- 每个流水段后面都需要增加一个**流水寄存器**
  - 锁存本段处理完成的数据和控制信号
  - 保证本段的执行结果能够在下一个时钟周期给下一个流水段使用
  - 根据流水寄存器所连接的前后功能段来命令流水寄存器:
    - IF/ID寄存器
    - ID/EX寄存器
    - EX/MEM寄存器
    - MEM/WB寄存器

- 各种寄存器和数据存储器均采用统一的时钟CLK进行同步
  - 每来一个时钟,就会有一条指令进入到流水线(IF段)
  - 不同的流水寄存器锁存的数据不同 

#### 小结

- 流水寄存器保存的信息:
  - 后面流水段所需要的所有**数据信息**,包括:
    - PC+4
    - 指令
    - 立即数
    - 目的寄存器
    - ALU运算结果
    - 标志信息
    - ...
  - 后面各段流水段要用到的所有**控制信号**(从前面传递过来的)

## 流水线冒险和处理

- 在指令流水中,可能会遇到一些情况使得流水先无法正确执行后续指令引起流水线阻塞(停顿)
  - 这种情况称为流水线冒险
  - 相关原因有三种

### 结构冒险

- 多条指令在同一时刻真用同一资源而形成的冲突(也称为**资源冲突**),是有硬件资源竞争造成的冲突
- 解决办法
  - 前一指令访存时,使后一条相关指令(以及后续指令)暂停一个时钟周期
  - 单独设置指令存储器/数据存储器,使取数操作和取指操作各自在不同的存储器中进行
  - 现代计算机都引入了cache机制,L1 Cache通常采用数据Cache和指令Cache分离的方式,避免了资源冲突

### 数据冒险

- 在一个程序猴子那个,下一条指令会用到当前指令的计算结果的时候,此时这两条指令发生数据数据冲突
- 当多条指令重叠处理时,就会发生冲突
- 数据冒险分为三类
  - 读后写(RAW)
    - 表示当前指令将数据写入寄存器后,下一条指令才能从寄存器中读取数据
    - 否则读到的就是错误的数据(旧数据)
  - 写后读(WAR)
    - 当前指令读出数据后,下一条指令才能够写该寄存器.
    - 否则读到的就是错误的数据(被覆盖的数据)
  - 🎈写后写(WAW)
    - 表示当前指令写入寄存器后,下一条指令才能够写该寄存器,
    - 否则,下一条指令在当前指令写之前写,使得<u>寄存器的值不是最新的</u>
- 解决办法:
  - 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期
  - 直到数据相关问题消失后,再继续执行
    - 又可以分为硬件阻塞(stall)和软件插入(NOP)指令两种方式
  - 设置相关专用通路
    - 不用等待前一条指令将结果写回寄存器组
    - 下一条指令也不再读取寄存器组来获取数据
    - 而是直接把前一条指令的ALU计算结果作为自己的输入数据开始计算过程
    - 使得原本需要暂停的操作变得可以继续执行(称为**数据旁路技术**)
  - 通过编译器对数据相关指令进行编译优化,调整指令顺序来解决数据相关问题

### 控制冒险

- 控制冒险:指令通常是顺序执行的
  - 但是遇到改变指令执行顺序的情况(例如执行转移/调用/返回等指令)时,会改变PC的值,**造成断流**
- 解决办法
  - **预测**:对转移指令进行分支预测,尽早生成**转移目标地址**
    - 简单预测(静态预测)
      - 总是预测条件不满足
      - 继续执行分支指令的后续指令
    - 动态预测
      - 根据程序执行的历史情况,进行动态预测调整
      - 具有较高的预测准确率
  - **预取:**
    - 预取转移成功和不成功两个控制流方向上的目标指令
  - 加快和提前形成条件码
  - 提高转移方向的准确率

#  例题🎃

##  流水的相关问题(冲突问题)实例

###  数据相关

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210623151724544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

1）流水线操作的时钟周期T应按四步操作中所需时间最长的一个步骤来考虑，所以T=100ns。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210623151938879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210623152220705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

#   流水线性能指标🎈

##  流水吞吐率

- Pipeline throughput(吞吐率:ThroughPut)

  - 指的是单位时间内,流水线完成的任务数量(输出的结果数量)

  - $TP=\frac{n}{T(n,k)}$

  - $T(n,k)=(n+k-1)\Delta{t}$

    - 可以将$T(n,k)$简写为$T_k$(通常更加强调参数$k$)

  - $\Delta{t}$是基准时间,有时它就是<u>时钟周期</u>

  - $k$是每条指令的功能段(流水段)数

    - 前面的例子中,$k=5$,从这个角度上看,k越大,吞吐率越小

    - 连续输入的任务$n\to{\infin}$时,

      - $$
        TP=\lim\limits_{n\to{\infin}}\frac{n}{T(n,k)}
        =\lim\limits_{n\to{\infin}}\frac{n}{(n+k-1)\Delta{t}}
        =\frac{1}{\Delta{t}}
        $$



##  加速比(串行/流水耗时比)

- 为了比较流水线技术相较于串行执行方式的速度提升情况,使用加速比来描述

  - **加速比**:完成同一批任务(n条指令),不使用流水线与使用流水线所用的时间之比

    - 分子是串行方式执行的总耗时较长

    - 分母是流水并行方式执行,总耗时较短

    - 记为$S=\frac{T_0}{T_k}$

      - $T_0=T_{se}(n)$表示**串行方式**(serial)执行($n条k段指令任务$)所耗费的时间

        - 记$T_{per}$表示**每条**(per)指令的执行耗时
        - $T_0=T_{se}(n)=nT_{per}$

      - $T_k=T(n,k)=(n+k-1)\Delta{t}$表示$k$段流水线方式执行耗费的时间

      - $$
        S=\frac{T_0}{T_k}=\frac{nT_{per}}{(n-k+1)\Delta{t}}
        $$

        

### 例

- 假设每条k段任务的每段执行时间都是$\Delta{t}$

  - $T_0=kn\Delta{t}$表示串行方式执行($n条k段指令任务$)所耗费的时间

    - $$
      \lim\limits_{n\to{\infin}}S
      =\frac{nk\Delta{t}}{(n-k+1)\Delta{t}}
      =\lim\limits_{n\to{\infin}}\frac{kn}{n+k-1}=k
      $$

      

    - $$
      实际情况:T_0\leqslant{kn\Delta{t}}	
      \\
      \lim\limits_{n\to{\infin}}S
      \leqslant{k}
      $$

    - 加速比一般是达不到$k$

    

##  流水效率(设备利用率)

- $$
  E=\frac{n个任务占用的时空区有效面积(单元格总面积)}{n个任务所用时间和流水段数k所围成的时空面积}
  =\frac{T_0}{kT_k}
  \\
  \lim_{n\to{\infin}}E=\frac{nk\Delta{t}}{k\cdot{(n+k-1)\Delta{t}}}
  =\frac{n}{n+k-1}=1
  $$

- 可见,在最理性的情况下,流水技术的设备利用率趋近于百分之百(任务数量足够多)

## 例题(加速比)

- 注意,在计算加速比的时候,串行时间部分的计算不按流水的时钟周期来计算的

- (流水时间周期指基于流水方式提出,不属于串行概念)
- 设5个功能段的指令流水中,每段的执行时间分别为
  - 10,8,10,10,7,单位是ns
  - 完成n=12条指令的流水线而言
  - 加速比S=?
  - 流水线吞吐率TP=?
- 分析:
  - 流水线应该将基准时间$\Delta{t}=10$
  - $T_k=T(n,k)=T(12,5)=(12+5-1)\times{10}=160ns$
  - $T_{per}=10+8+10+10+7=45ns$
  - $T_0=nT_{per}=12\times{45}=540ns$
  - $S=\frac{T_0}{T_k}=\frac{540}{160}=3.375$
  - $TP=\frac{n}{T_k}=\frac{12}{160}=0.075(条/ns)$

# 高级流水线技术🎈

- 有两种增加指令级并行的策略

## 多发射技术

- 采用多个(相同功能的)内部功能部件,使得流水线**功能段**可以同时处理多条指令(的相同阶段)
- 处理机可以一次发射多条指令进入流水线执行

### 超标量流水线技术

- 即,动态多发射技术
- 每个**时钟周期**内可以**并发**多条独立指令,以并行方式将多条指令编译并执行,需要配置多个功能部件
- 超标量不能调整指令的执行顺序,通过编译优化技术,可以把并行执行的指令搭配起来,挖掘更多的指令并行性

### 超长指令字技术

- 即,静态多发射技术

- 由于编译程序挖掘出指令间潜在的并行性,将多条能并行操作的指令组合成一条**具有多个操作码字段**的超长指令字

  - 可以达到几百bit
  - 需要采用多个处理部件

  

## 超流水线技术

- 增加流水线**级数**来使得更多的指令同时在流水线中**重叠执行**

  - $$
    TP=\lim\limits_{n\to{\infin}}\frac{n}{T(n,k)}
    =\lim\limits_{n\to{\infin}}\frac{n}{(n+k-1)\Delta{t}}
    =\frac{1}{\Delta{t}}
    $$

    

  - 从前面对流水吞吐率的讨论中可以知道:

    - 流水线功能段划分的越多,时钟周期就可以设定的越短,指令的吞吐率就越高

  - 因此,超流水线技术通过**提高流水线主频(缩短流水线时钟周期)**的方式来提升流水线性能
  - Note:
    - 但是,流水线级数不是越多越好
    - 流水线级数越多,用于**流水寄存器的开销越大**,流水线级数是有限制的



