[toc]

# 程序中断🎃

- **程序中断方式**中断是现代计算机<u>有效合理地发挥效能和提高效率</u>的一个十分重要的功能。

- CPU中通常设有处理中断的机构——**中断系统**，以解决各种**中断的共性问题**。

- 程序中断过程是有软硬件共同完成
  - 中断隐指令阶段(硬件)

  - 中断服务程序阶段(软件)

- 中断服务程序是处理器处理紧急事件,可以理解为一种服务
  - 通过执行事先编写好的某个特定程序来完成的
  - 一般属于操作系统的模块,以供调用


## 中断概念

- 计算机执行现行程序的过程中,出现某些急需要处理的
  - 异常情况
  - 特殊请求

- 暂时终止现行程序,而转去对这些情况进行处理
- 处理完后在返回到现行程的断点处,继续执行原程序
- 以上就是对**中断**概念的描述
  - 经典的中断类型有IO中断等类型


### 中断目的比较

- 程序中断是为了**传送数据**
  - 细分引入中断的目的
    - 提高整机效率
    - 应付突发事件(例如突然掉电)
    - 实时控制的需要
- DMA中断是为了报告<u>正常传送结束或者故障</u>

### 中断功能(作用)

- 早期:
  - 处理数据传送
- 现在
  - 实现cpu与IO设备的并行工作(parallel)
  - 处理硬件故障和软件错误
  - 实现人机交互
    - 用户干预机器需要借助于中断系统
  - 实时处理需要借助中断系统来实现快速响应
  - 实现应用程序和操作系统(管态程序)之间的切换
    - 称为**软中断**
  - 多处理器系统中各个处理器之间的<u>信息交流和任务切换</u>

### 中断请求

- 中断请求:是指中断源向CPU发送**中断请求信号**。

### 中断源

- 中断源:请求**cpu**中断的**设备或者事件**
- 一台计算机允许有多个中断源
- 每个中断源向**cpu**发送中断请求的时间是随机的

#### 中断源举例

- 外部事件

- 虚拟存储器失效(缺页)

- 浮点运算上溢(且属于内中断)

  - 浮点下溢则不会引起中断(被当做机器0处理)

- Cache不会提出中断(完全有硬件实现)

- 多到程序切换

- 处理器间的信息交流

  

## 🎈🎈程序中断方式的接口电路

- 为了处理IO中断,需要在iO接口中配置相关硬件线路
- 中断请求触发器和中断屏蔽触发器在IO接口中是成对出现的

### 🎃中断请求触发器INTR

- **每台外设**都必须要配置一个**中断请求触发器INTR**

  - 当INTR=1时,表示<u>该设备**提出**中断请求</u>

  - **设备本身**必须处于**就绪状态**,(接口内的**完成触发器D=1**)

  - 也就是说,设备的INTR能否被置为1,D=1是前提必要条件(但是不充分,需要考虑屏蔽触发器Mask)
  
  - 当设备中断接口满足
  
    - D=1
    - Mask=0
    - INTR=1
    - 表示该设备向(中断源)向cpu发出了中断请求信号(cpu可以检测到相应的中断请求)
    - 该信号被送至排队器种机型优先级判断
  
    

### 中断屏蔽触发器Mask🎈

- 为了能够处理多个中断源向cpu提出中断的情况
- 需要对中断各种中断源的请求进行排队
  - 并且只接级别最高的中断源的请求,同时不允许低优先级的中断源中断正在运行的高级别中断服务程序
- 通过在**接口**中设置一个**中断屏蔽触发器Mask**来实现
  - 当Mask=1时,表示被屏蔽,封锁其中的中断源请求
    - 此时即使完成触发器D=1,中断查询信号到来时刻也只能够将INTR置为0
    - cpu收不到该中断源的请求(即,所谓的中断源**被屏蔽**)

#### 作用

- 中断屏蔽标志可以改变多个中断服务程序执行完的次序
- 中断屏蔽标志的作用之一就是实现中断(优先级)升级,改变**中断处理顺序**(从而影响中断服务程序执行完成的次序)

### 中断分类

#### INTR

- 根据**中断源的类别**，可把中断源分为内中断和外中断两种。
- 每个中断源向CPU发出中断请求的时间是随机的。
- 为**记录中断事件**并**区分不同的中断源**，中断系统需对每个中断源设置中断请求标记**触发器INTR**,当其状态为“1”时，**表示中断源有请求**。
  - 这些触发器可**组成中断请求标记寄存器**，该寄存器可**集中在CPU中**，也可**分散在各个中断源中**。
- 中断请求触发器越多,计算机(系统)处理中断的能力越强
  - **计算机系统**和**操作系统**不等价
  - 计算机系统包括软硬件
  - 操作系统是系统级软件

#### 外中断

- **外中断**是指来自**处理器和内存以外**的部件引起的中断

##### 外中断举例

- 定时器**到时**
  - 定时器到时,是**时钟中断**,属于外部中断
- 网络数据包到达
  - 描述的是cpu执行指令意外的事件,属于外部中断
- I/O设备发出的**I/O中断**
- **外部信号**中断（如用户按Esc键）
- **外中断**在狭义上一般称为**中断**（后文若未说明，**一般是指外中断**）。
- **硬件中断属于外中断**





#### 陷入(内中断/异常)

- 由**CPU内部事件**(运算过程中)所引起的中断,称为**内中断**或**陷入(trap)**
  - 异常是cpu执行一条指令时,有cpu在内部检测到的,与正在执行的指令相关的同步事件
  - 中断则是典型的有外部事件触发的,与当前正在执行的指令无关的异步事件
  - 异常和中断的处理过程基本相同🎈

- 与(外)中断一样，若系统发现了有陷入事件，CPU也将**暂停正在执行的程序**，转去执行该陷入事件的处理程序。

- 中断和陷入的**主要区别**是**信号的来源**，即是来自CPU外部，还是CPU内部。

- **内中断**主要是指在**处理器和内存内部产生的中断**包括
  - **程序运算引起**的各种错误
    - 如地址非法、
    - 校验错、
    - 页面失效、
    - 存取访问控制错、
    - 算术操作溢出、
    - 数据格式非法、
    - 除数为零、
    - 非法指令、
    - 用户程序执行特权指令、
    - 分时系统中的**时间片中断**及用户态到核心态的切换
    - <u>程序出错</u>
    - <u>地址越界</u>
    - <u>电源故障</u>
    - 等

#### 非屏蔽中断和可屏蔽中断

- ref:
  - [Non-maskable interrupt - Wikipedia](https://en.wikipedia.org/wiki/Non-maskable_interrupt)
- **非屏蔽中断(不可屏蔽中断)**： 此种中断通过**不可屏蔽中断请求NMI**控制，不受**中断标志位IF**的影响，即使在关中断（IF=0）的情况下也会被响应。
- 🎈**内中断**属于不可屏蔽中断
  - NMI: a **non-maskable interrupt** (**NMI**) is a hardware [interrupt](https://en.wikipedia.org/wiki/Interrupt) that standard [interrupt-masking techniques](https://en.wikipedia.org/wiki/Interrupt#Masking) in the system cannot ignore.
    - It typically occurs to signal attention for non-recoverable hardware [errors](https://en.wikipedia.org/wiki/Error). 
    - Some NMIs may be masked, but only by using proprietary methods specific to the particular NMI.
- **可屏蔽中断**：可屏蔽中断也是一种**硬件中断**，此种中断**通过中断请求标记触发器INTR控制**，且**受中断标志位IF的影响**，在**关中断**情况下**不接受中断请求**。
  - INTR:
    - INTerrupt Request



### 硬件中断和软件中断

- **硬件中断**：通过外部的硬件产生的中断。
  - 属于外中断


- **软件中断**：通过**某条指令产生的中断**，这种中断是可以**编程实现**的
  - 而**内中断**是cpu运算引起错误导致
  - **软件中断是内中断**。

### 关系整理🎈

- ```mermaid
  flowchart LR
  subgraph outer[外中断]
  	outter[硬件中断]
  end
  subgraph inner[内中断]
  	软件中断
  end
  ```

  

- 非屏蔽中断

  - 内中断
    - 软中断
  - 严重的外中断

- 可屏蔽中断

  - 不严重的外中断

## 中断判优🎈中断优先级

- 中断系统在任一瞬间只能响应一个**中断源**的请求。
- 由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑确定响应哪个中断源的请求，
  - 例如故障中断的优先级别较高，然后是I/O中断。
- **中断判优**既可<u>以用硬件实现，又可用软件实现</u>。(区别**中断向量**,由硬件产生)
  - **硬件实现**是通过**硬件排队器**实现的，它既可以设置在CPU中，又可以分散在各个中断源中
    - 硬件排队器分为两类
      - 分散在各个接口电路汇中的排队器:称为链式排队器(INTR触发器)
        - 每个接口电路汇总设有一个非门和一个与非门
        - 犹如链条一样串接起来
      - 设在cpu内的排队器:
        - 一样可以由许多非门和与非门构成
  - **软件实现**是通过**查询程序**实现的 
- 中断响应优先级是指cpu**响应中断请求的先后顺序**
  - 细分:
    - 响应优先级
      - 在硬件上是固定的,不便改动
    - 处理优先级
      - 可以利用中断屏蔽技术动态调整,以实现多重中断
- **经常会有多个中断信号源**，每个中断源**对服务要求的紧急程度并不相同**，
  - 例如，**键盘终端的中断请求的紧急程度不如打印机**，而打印机中断请求的紧急程度**又不如磁盘**等。
  - 为此，系统就需要为它们**分别规定不同的优先级**。
- 一般来说:
  - `不可屏蔽中断>内部异常>可屏蔽中断`
    - 内部异常
      - `硬件中断>软件中断`
        - 比如DMA请求(IO方式之一),优先级同时高于软件中断(内中断的范畴)
      - `访管指令中断>程序性中断>重新启动`
        - 从新启动优先级最低,需要等待其他任务完成后在进行
        - 方管指令优先级要高于外部中断
        - 用户需要输入输出时,需要调用操作系统提供的接口请求系统服务,引起访管中断,系统由用户态转为核心态
  - `DMA中断请求优先于IO设备传送的中断请求`
  - IO传送类中断
    - `高速设备>低速设备`
    - `输入设备>输出设备`
    - `实时设备>普通设备`

- 总体而言,中断源的优先顺序是从:
  - 如果该中断不及时处理导致的工作**出错的严重程度**而定
  - 例如:
    - 掉电(对机器工作影响最大),其优先级最高
    - 顶点溢出(或浮点上溢),严重程度也高,因为该错误导致计算机后续一切运行都是无效的

### 🎈🎈🎈CPU响应中断的条件

- 什么时候**响应中断**(开中断)关乎**多重中断的实现**问题
- CPU在满足一定的条件下响应中断源发出的中断请求，并经过一些特定的操作，转去执行中断服务程序。
- **CPU响应中断**必须满足以下3个条件:
  - ①中断源有**中断请求**。
  - ②CPU**允许中断**(开中断)
    - 不可屏蔽中断(包括异常)不受此限制
    - 具体是:
      - cpu中的允许中断触发器EINT=1
      - 该触发器可以用开中断指令/关中断指令进行置为,或硬件自动复位
  - ③**一条*<u>指令</u>*执行完毕**(异常除外)，且**没有更紧迫的任务**。

### 外中断实现思路🎈(cpu响应中断的时间)

- 注意：I/O设备的就绪时间是随机的
  - 从cpu查询中断信号和响应中断两个时间结点描述:
  - CPU查询中断:**CPU在统一的时刻**,即每条 指令**<span style='color:red'>执行阶段</span>结束的最后<u>时刻</u>** (指令执行阶段设为$t_1t_2$,该阶段结束前的最后时刻$t\to{t_2}$), 向接口发出中断查询信号**，以**获取I/O的中断请求
  - 也就是说，CPU**响应中断**的时间是**在每条指令执行阶段的结束时刻**,而不是**执行过程中**

- 这里说的中断**仅指外中断**，<u>内中断不属于此类情况。</u>
- 对比DMA中断,则是安排在每个**存储后期**结束后检查是否有DMA请求

### 中断隐指令 及其工作

- CPU响应中断后，经过某些操作，转去执行中断服务程序。
- 这些操作是由**硬件直接实现**的，我们将它称为**中断隐指令**。
- 中断隐指令并不是指令系统中的一条**真正的指令**，它**没有操作码**
  - 所以中断隐指令是一种**不允许也不可能为用户使用的特殊指令**。它所完成的操作如下：

#### ①关中断

- 在中断服务程序中，为了**保护中断现场(即CPU主要寄存器中的内容)期间**不被<u>新的中断</u>所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕后能接着正确地执行。
  - 关中断通常是包含在硬件**中断隐指令**中自动执行的(将<u>允许中断触发器ENIT</u>置为0)

- 关中断之前应该是开中断(否则就无法接受新的中断)
- **处理器响应中断后**，首先要保护程序的现场状态，在保护现场的过程中，CPU不应响应更高级中断源的中断请求。
- 否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序。

#### ②保存断点

- 为保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须**将原来程序的断点保存起来**。
- 断点内容:
  - 程序计数器(PC)的内容

- 为保证中断服务程序执行完毕后**能正确地返回**到原来的程序，必须将**原来的程序的断点**保存起来。
- **断点**可以压入**栈**或者**特定寄存器**中。
- 🎈保存现场的两层含义即其区别:
  - 保存**程序断点**:
    - 原程序点断(程序计数器PC)内容的保存,硬件自动完成
    - 程序计数器的更新也是有由硬件自动完成
  - 保存**cpu现场**信息:<u>通用寄存器/状态寄存器(PSW/GPR)中断服务程序负责保存</u>
  - 两者的执行者/保存内容都是不同的
- 中断和异常的差异:
  - 异常指令的断点:通常没有执行成功,异常处理后需要**重新执行**(断点是当前指令的地址)
  - 中断的断点则是<u>下一条指令的地址</u>.

#### ③识别中断源

- 引出中断服务程序(发出中断响应信号并形成向量地址)包括2步骤
  - 识别**中断源**;
  - 将**中断服务程序的入口地址**并传送给**程序计数器(PC)**

##### 寻址中断服务程序的入口的实现方法

- 通常有两种方法寻址中断服务程序的入口地址：
  - **硬件向量法**和**软件查询法**。
    - 硬件向量法通过**硬件产生中断向量地址**，再由**中断向量地址**(入口地址的地址)找到**中断服务程序的入口地址**。
    - 软件查询法用**软件编程的办法寻找入口地址**。
  - 引出中断服务程序的实质是，取出中断服务程序的入口地址送入程序计数器(PC)。
    - cpu响应中断后,通过识别中断源,获得**中断类型号**，由中断类型号计算出**中断向量存放的地址(中断向量地址)**
    - 有中断向量地址从**中断向量表**中取出<u>中断服务程序入口地址</u>(即向量地址)
  - 🎈异常好中断的识别方式不同
    - 异常大多采用软件方式识别
      - cpu设置一个**异常状态寄存器**,用于记录异常原因
      - 操作系统使用一个同一的异常/中断查询程序,按照优先级顺序查询异常状态寄存器
        - 以检测异常和中断类型
        - 先查询到的先处理,然后转到内核汇中相应的处理程序
    - 中断既采用硬件方式(称为:向量中断,异常或者中断**处理程序**的**首地址**称为中断向量),也可采用软件方式识别
      - 每一个异常或者中断被指定一个中断类型号
      - 在保存中断向量的**中断向量表**中,中断类型号和中断姓梁一一对应,因此,可以通过中断类型号快速找到对应的处理程序
      - 中断响应过程结束后,cpu通过程序计数器PC中取出中断服务程序的第一条指令开始执行,完成中断程序后,最后一条指令中断返回.(这个过程有软硬件协同完成)

### 🎈中断向量(入口地址)

- 不同的<u>设备</u>有**不同的中断服务程序**
  - 每个中断服务程序**都有一个入口地址**，CPU必须找到这个**入口地址，即中断向量**

#### 中断向量表(入口地址表)

- 把系统中的**全部中断向量集中存放到<u>存储器</u>的某个区域内**，这个存放中断向量的**存储区就称为中断向量表**，即中断服务程序**入口地址表**。
- CPU响应中断后
  - 通过识别中断源获取中断类型号
  - 据此计算出对应中断向量地址A(V)
  - 根据地址A(V)从中断向量表中取出中断服务程序的入口地址A(P)
  - 并将A(P)送入程序计数器PC,转而执行中断服务程序
  - 通过这种实现程序的切换方法，称**为中断向量法**
  - 采用中断向量法的中断称为**向量中断**。
  - **中断向量**由向量地址形成部件产生(硬件:**设备编码器**),
    - 不同的中断源对应不同的终端服务程序,通过中断向量法可快速的识别中断源

- 注意：
  - 🎈**中断向量**是中断服务程序的**入口地址**，
  - **🎈中断向量地址**是指中断服务程序的**入口地址的地址**。



- 为了处理上的方便，通常是为**每种设备**配以相应的**中断处理程序**
- 并把该**程序的入口地址**放在**中断向量表的一个表项中**，并为**每一个设备的中断请求规定一个(标识:)中断号**，它<u>直接对应于中断向量表的一个**表项**中</u>。

- 当**IO设备发来**中断请求信号时，由**中断控制器**确定该请求的**中断号**
- 根据该**设备的中断号**去**查找中断向量表**，从中取得**该设备中断处理程序的入口地址**，这样便可以**转入中断处理程序执行**。



## 🎈🎀多重中断处理过程

### 记号/格式说明

- @环节名称:带`@`号的环节是对于<u>采用屏蔽字技术</u>的多重中断相对于简单多重中断过程所增加的环节

### 大致步骤

- 不同计算机的中断处理过程各具特色,大致步骤
- ①关中断
- ②**保存断点**。
- ③识别**中断源**/中断服务程序寻址(引出中断服务程序)
- 🎈1~3是有中断隐指令实现
  - 中断隐指令把**允许中断触发器ENIT**置为0(ENIT即,关中断)

------



- 保存**现场(和屏蔽字)**
  - **进入中断服务程序后**首先要保存现场
  - **现场信息**
    - 一般是指用户可见的工作寄存器的内容,
    - 包括
      - **程序状态字**PSW
      - 中断屏蔽寄存器
      - CPU中某些寄存器的内容。
    - 存放着程序执行到断点处的现行值
    - 现场信息可以用指令直接访问,通常在中断服务程序中通过**指令**把他们保存到**栈**中,由**<u>软件实现</u>**
  - **断点信息**
    - 由cpu在中断响应时自动保存到**栈**或者指定的**寄存器**中,由**<u>硬件实现</u>**
- @设置屏蔽字
- 开中断(EINT置为0)
  - **允许更高级中断请求得到响应，实现中断嵌套。**
  - 注意这个阶段是在前一阶段:`保存现场和屏蔽字`之后开放

- 执行中断服务程序(比如IO设备服务)
  - 这是**中断请求的目的**。
- @关中断 
  - 保证在**恢复现场和屏蔽字时不被中断**。
- 恢复现场
  - 将现场和屏蔽字恢复到原来的状态。
- @恢复屏蔽字
- @开中断 
- 中断返回。
  - 中断服务程序的**最后一条指令**通常是一条中断返回指令R
    - 与无条件跳转指令J不同的是,R不仅要修改PC,
    - 中断返回指令R还要将cpu中的寄存器都恢复到中断前的状态(还原现场)
  - 使其**返回到原程序的断点处**，以便继续执行原程序。
- 其中，
  - ①〜③在CPU**进入中断周期**后，由**中断隐指令(硬件自动)完成**；
  - 其余步骤,由**中断服务程序完成**(软件完成)。
  - 注意：
    - 恢复现场是指在**中断返回前**，必须将寄存器的内容**恢到中断处理前的状态**，这部分工作由**中断服务程序完成**。
    - **中断返回**由**中断服务程序的最后一条中断返回指令**完成。
    - 多重中断系统在保护中断进程现场时关中断,
      - 执行中断处理程序时则开中断

### 例

- 机器每 400ns 发出一次中断请求，而响应和处理时间为 100ns，中断响应的最长延迟时间为50ns,计算该设备的I/O 时间占整个CPU 时间的百分比p至少为多少?
  - 解:
    - 求解时间类问题,可以时间事件轴的起点一般设为0(或者某个延迟下>0)来分析
      - 每400ns发出一次中断请求,则轴上的400的倍数400k($k\in\set{0,1,\cdots}$)这些点均为中断请求时刻
      - 响应和处理时间为100ns,应该理解为是两个响应和处理两个阶段的时间耗时总和
    - 对于所问的问题来说,给出的容许的延迟时间t=50ns为干扰信息(无用),因为在 50ns 内，无论怎么延迟，每 400ns 还是要花费 100ns 处理中断的
      - 严谨的说,是$t\in[0,300]$都不会影响p的结果
    - 所以该设备的I/O 时间占整个CPU 时间的百分比为p=100ns/400ns=25%

### 中断和外中断

- 一般的,提到中断(没有特别指明,均为**外中断**(来自cpu执行指令以外的事件))
- 中断请求的产生与当前指令执行无关
  - 但是内中断就有关系

## 🎈一次中断处理过程的大阶段:

- 中断请求
- 中断判优
  - 中断优先级是有屏蔽字决定(而不是简单的根据请求的先后来决定)
    - 

  - 并且前者有利于灵活调整优先级

- 中断响应阶段
  - 响应当前最优先的中断请求
- <u>中断服务阶段</u>(处理阶段)
  - 向量地址中,存放的值一条无条件跳转指令
  - 通过无条件跳转指令跳转到中断源的服务程序入口
- 中断返回

### 中断服务程序的流程

- 中断服务程序只能够在**核心态下执行**

- 不同设备的服务程序是不同的
  - 但是程序的流程是类似的
  - 分为四大部分
    - 保护现场
      - 中断隐指令完成**程序断点**保护(保存)
      - 中断服务程序完成**通用寄存器和状态寄存器**的保存
    - 中断服务
      - 中断程序的主体部分
      - 对于不同的中断源有不同的行为
      - 比如打印机
        - 将字符代码通过接口传送到打印机的缓冲存储器中
      - 显示器
        - 将字符代码通过接口送入显示器的显示存储器中
    - 恢复现场
      - 服务程序的结尾部分
      - 推出中断服务程序之前,需要将原程序中断的时候的现场恢复到原来的寄存器中
    - 中断返回
      - 中断服务程序的最后一条指令,通常是一条中断返回指令,,时期返回到原程序的断点处以便继续执行原程序

## 🎈对多中断源的处理方式

- 对于多中断信号源的情况，当处理机正在处理一个中断时，又来了一个新的中断请求,这时应如何处理?
  - 例如，当系统正在处理打印机中断时，又收到了优先级更高的磁盘中断信号。
  - 对于这种情况，可有两种处理方式:
    - 屏蔽(禁止)中断
    - 嵌套中断
  - 两种方式的区别在于,嵌套中断方式将开中断的

### 屏蔽(禁止)中断/单重中断

- 当处理机正在处理一个中断时，将屏蔽掉所有的中断，即处理机对任何新到的中断请求，都暂时不予理睬，而让它们等待。

- 直到处理机已完成本次中断的处理后，处理机再去检查是否有中断发生。

- 若有，再去处理新到的中断，若无，则返回被中断的程序。

- 在该方法中，**所有中断都将按顺序依次处理**。

- 其优点是**简单**，但<u>不能用于对实时性要求较高的中断请求</u>。

  

### 嵌套中断/多重中断🎃🎊

- 当cpu正在执行某个中断服务程序P1(Pi)时,另一个中断源提出了新的中断请求
- 若CPU对新的请求做出响应,停止了正在运行的服务程序P1(Pi+1,矩执行新的中断服务P2,则称为多重中断
- 中断屏蔽技术主要用于多重中断。

#### 🎈🎈🎈多重中断条件

- CPU 要具备多重中断的功能，必须满足下列条件:
  - 在<u>中断服务程序中</u>**提前设置开中断指令**。
  - <u>优先级别高的中断源</u>有权<u>中断优先级别低的中断源</u>。

- 由于中断服务程序只能够在**核心态下执行**所以,为了能够检测到多重中断,内核态下也必须能够检测和响应中断
- 在多重中断中,中断处理优先级更低中断请求信号是检测不到的
  - 只有在检测到比当前处理的中断更高的优先级时,才能够进入中断相应周期
  - 进入**中断响应周期**时,cpu处于中断允许(开中断)的状态
    - 否则,无法响应其他的(更高优先级)的中断请求,无法实现多重中断

### 中短周期(中断响应周期)

- 中断响应周期是电脑术语。当CPU采用中断方式实现主机与I/O交换信息时，CPU在每条指令执行阶段结束前，都要发中断查询信号，以检测是否有某个I/O提出中断请求。
- 如果有请求，CPU则要进入**中断响应阶段**，又称**中断周期**。

#### 🎍屏蔽字

- 现代计算机一般使用中断屏蔽技术
  - 每个**中断源**都有一个**屏蔽触发器**
    - 1表示屏蔽(该中断源的请求$1\to{Deny}$)
    - 0表示可以正常申请中断($0\to{OK}$)
  - 所有**屏蔽触发器**组合在一起,构成一个**屏蔽字寄存器**
  - 屏蔽字寄存器的内容称为**屏蔽字**

#### 优先级控制

- 在设置了**中断优先级**的系统中，通常按这样的规则来进行**优先级控制**;
  - (1)当**同时有多个不同优先级**的中断请求时，CPU**优先响应最高优先级的中断请求**;
  - (2）高优先级的中断请求可以**抢占正在运行的低优先级中断的处理机**，
    - 该方式类似于**基于优先级的抢占式进程调度**。
    - 例如，处理机正在处理打印机中断，当有**磁盘中断**到来时，可暂停对打印机中断的处理，转去处理磁盘中断。
    - 如果新到的是**键盘中断**，由于它的**优先级低于打印机的优先级**，故处**理机继续处理打印机中断**。
  - 对于同级别的多个中断,它们将按照先来后到的顺序,即相互屏蔽
    - 这些中断分别标记位$X_i^{[k]};i,j\in\set{1,2,\cdots}$,k表示优先级同为k
      - 那么$X_i比X_{i+j}$先处理

## 🎈对比多重中断和单重中断

- CPU一旦响应了某个中断源的请求后,便由硬件线路自动关闭中断
  - 中断允许触发器EINT置为0
  - 确保中断服务可以顺利执行
  - 如果执行过程不用**开中断**指令将EINT置为1,那么cpu就不能够在响应任何一个中断源的请求
    - 除非是非屏蔽中断性质的中断(不收关中断的影响)
- 那么对于单中断而言,**开中断**指令设置在**中断返回**之前执行
  - 意味着在整个中断服务处理过程中不能够在响应其他中断源的请求
- 对于多重中断,开中断指令提前到保护现场之后,
  - 意味着保护现场之后,如果有更高级别的中断源提出请求(这也是实现多重中断的必要条件之一)
  - cpu应该响应这个更高优先级的中断
  - 再次中断现行的服务程序,转去执行新的服务程序(这是多重中断和单重中断的主要区别)

## 🎈中断处理程序(操作系统部分)

- 当一个**进程A请求**I/O操作时，**该进程A将被挂起**
- 直到**I/O设备完成I/O操作**后，**<u>*设备控制器*</u>**便向CPU**发送一个中断请求**(表示资源可用了)
- CPU响应后便转**向中断处理程序**，中断处理程序**执行相应的处理**，处理完后<u>解除进程A的阻塞状态</u>。
- **中断处理程序的处理过程**可分成以下几个步骤：

### (1)测定是否有未响应的中断信号

- 每当设备完成一个字符(字或数据块)的读入(或输出)，设备控制器便向处理机发送一个中断请求信号。
- 请求处理机将设备已读入的数据传送到内存的缓冲区中(读入)，或者请求处理机将要输出的数据(输出)传送给设备控制器。
- 程序**每当执行完当前指令**后，处理机都要**测试是否有未响应的中断信号**。
  - 若没有，**继续执行下一条指令。**
  - 若有，则停止原有进程的执行，准备转**去执行中断处理程序**，为把**处理机的控制权转交给中断处理程序做准备。**

### (2)保护被中断进程的CPU环境

- 在把**控制权转交给中断处理程序之前**，需要先保护被中断进程的CPU环境，以便以后能恢复运行。
- 首先需要保存的是，从中断现场恢复到当前进程运行**所需要的信息**。
- 通常由**硬件**自动将以下内容保存在**中断保留区(栈)中**。
  - 处理机状态字(PSW)
  - 保存在程序计数器(PC)中**下一条指令的地址NextAddress**,简记为N+1(这样方便从中断处理程序换源断点现场信息和断点信息,仿佛中断没有发生过一样回来继续执行的时候可以直接执行)
- 然后，把被中断进程的<u>CPU现场信息</u>,即,将包括所有<u>CPU寄存器</u>的内容都压入**中断栈**中,比如
  - 通用寄存器
  - 段寄存器等
- 在中断处理时可能会占用到这些寄存器,因此要先将原内容保存起来
- 下图:该程序是指令在**N位置时被中**断的，程序计数器中的**内容为N+1,**所有寄存器的内容都被保留在**栈**中。
  - ![image-20220604094104129](https://img-blog.csdnimg.cn/img_convert/7776ca7fbcd6352d1ba231f8aaea79e5.png)

### (3)转入相应的设备处理程序。

- 由处理机对各个中断源进行测试，以**确定引起本次中断的I/O设备**，并向**提供中断信号的设备**发送确认信号。
- 在该设备收到确认信号后，就**立即取消它所发出的中断请求信号**。
- 然后，将相应的设备中断处理程序的<u>入口地址</u>**装入到程序计数器**中。
- 这样，当处理机运行时，便可自动地转向中断处理程序。

### (4)中断处理

- 对不同的设备，有不同的中断处理程序。
- 该程序首先从设备控制器中读出**设备状态**，以判别**本次中断是正常完成中断还是异常结束中断**。
- 若是正常完成，中断程序便做**结束处理**。
  - 假如这次是<u>字符设备</u>的读操作，则来自输入设备的中断是表明该设备已经读入了一个字符(字)的数据，并已放入**数据寄存器**中。
  - 此时中断处理应将该数据传送给CPU,再将它存入**缓冲区**中，并修改相应的**缓冲区指针**，使其**指向下一个内存单元**。若还有命令，可**再向控制器发送新的命令**，进行新一轮的数据传送。
- 若是异常结束中断，则根据发**生异常的原因做相应的处理**。

### (5)恢复CPU的现场并退出中断

- 当**中断处理完成**以后，需要**恢复CPU的现场**，退出中断。
- 但是，此刻**是否返会到被中断的进程X**，取决于两个因素：
  - ①本中断是否采用了屏蔽(禁止)中断方式，若是，就**会返回被中断的进程X**。
  - ②采用的是**中断嵌套方式**，
    - 如果**没有优先级更高的中断请求IO**,在中断完成后，**仍会返回被中断的进程X**；
    - 反之，系统将处理优先级更高的中断请求。
  - 如果是要返回到被中断的进程，可将保存在**中断栈中的被中断进程的现场信息取出**，并装入到相应的**寄存器**中，其中包括该程序**下一次要执行的指令的地址N+1**、**处理机状态字PSW,**以及**各通用寄存器和段寄存器的内容**。
  - 这样，当处理机再执行本程序时，**便从N+1处开始，最终返回到被中断的程序**。



## 小结:程序中断方式的思想

- CPU在程序中安排好<u>于某个时刻启动某台外设</u>(外设启动就绪是需要一定的时间)
  - 然后CPU<u>继续执行原来的程序</u>
  - 不需要像**程序查询方式**那样一直等待外设准备就绪。

- 一旦外设完成数据传送的**准备工作**,就主动向CPU发出中断请求，请求CPU为自己服务。
- 在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务
  - **在中断服务程序中完成一次<u>主机与外设</u>之间的*<u>数据传送</u>***，传送完成后，CPU返回原来的程序





#  🎈多重中断和中断屏蔽技术

## 例:屏蔽字和执行轨迹

- 设某机有4个中断源A、B、C、D，其硬件排队优先次序为A>B>C>D,现要求
  将中断处理次序改为D>A>C>B。
  1)写出每个中断源对应的屏蔽字
  2）根据时间轴给出的4个中断源的请求时刻，画出CPU执行程序的轨迹(**程序(p)-时间(t)**图像)(设每个中断源的中断服务程序时间长头20us)

  - 4个中断源对应的请求时刻:
    - B:5
    - D:10
    - A:35
    - C:60

- 解

  - 1)在中断处理次序改为<u>D>A>C>B</u>后,逐个分析屏蔽情况

    - D具有最高优先级

      - 可以<u>屏蔽其他所有中断</u>，且<u>不能中断自身</u>，(即屏蔽D,A,C,B全部)
      - 因此D对应的屏蔽字为1111;
      - 🎈tips:1越多,表示其优先级越高,反之,0越多,优先级越低

    - A屏蔽A,C,B,

      - A对各个中断源的屏蔽二进制代码
        - A:1
        - B:1
        - C:1
        - D:0
      - 因此A对应的屏蔽字为1110，

    - C屏蔽C,B

      - C对各个中断源的屏蔽二进制代码:
        - A:0
        - B:1
        - C:1
        - D:0
      - C的屏蔽字为0110

    - B屏蔽自身(B)

      - B:1
      - 其余全为1
      - B的屏蔽字为0100

      

- 2）根据中断源发出请求的时间顺序以及处理不同中断源的优先级进行多重中断分析

  - 在时刻5，B发中断请求，获得CPU;
  - 在时刻10，D发中断请求，
    - 5~10时间段内,cpu执行了5us的任务B
    - 此时B还未执行完毕(还需要15=20-5)us，
    - 根据处理优先级,D的优先级高于B，于是D中断B而获得CPU;
    - D占用20us(此时时间线到了10+20=30us)完成任务后范围到B的中断程序处继续执行
  - 在时刻30，D执行完毕，B继续获得CPU
  - 时刻35,A发出中断请求
    - 30~35时间段内,cpu执行了5us的任务B
    - 此时B还未执行完毕(还需要15-5=10us)
    - 根据处理优先级,A的优先级更高,
    - 于是A中断B而获得CPU;
    - 由于下一个中断信号是在时刻60到达,60-35=25>20
    - 即A的任务可以完成,而且还有盈余的时间回到被A中断的B串继续执行25-20=5us的时间
  - 时刻55(=35+20),A执行完毕
    - 回到B执行
  - 时刻60,C发出中断
    - 55~60时间段,cpu执行了5us的任务B
    - 此时B还未结束(还有10-5=5us)
    - 但是C优先级更高,C中断B(抢夺了B的cpu资源)
    - C发出的是最后一个中断信号
    - 知道执行完毕(耗时20us)
    - 回到被中断的B任务
  - 时刻80=(60+20),C任务结束
    - 回到被C中断的断点继续执行B
    - 此时B还需要5us,
    - 因此到了时刻85,结束全部任务
  - ![在这里插入图片描述](https://img-blog.csdnimg.cn/1c21dc7699164cf5b08329a39e1aeba8.png)
    - 纵坐标就按照字母顺序从低到高升序排列即可
  - ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210623220226474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

## 例:中断传送计算问题

- 对于IO中断方式,每次中断可以传送一次数据
- 在这个前提下,设问:
  - 设备A以中断方式和cpu进行数据交互
  - 主频为1GHz
    - 也即是,每秒可以执行1G=$10^9$个时钟周期的任务
  - 接口中的数据缓冲寄存器为32bit(4B)
    - 也就是,一次中断方式数据传送可以传送4B内容
  - 同时,已知设备的传送速率为50kB/s
  - 如果每次传送开销(包括<u>中断响应</u>和<u>中断处理</u>)为1000个时钟周期
    - 中断**中断响应**一般比**中断处理**要快的多,中断耗时主要由中断处理影响着
    - 中断处理阶段是**中断周期**的一部分,该阶段就是用来传送数据的有用的时间
  - 那么,cpu用户输入输出的时间占整个cpu时间的百分比p最多为?
    - 解:
      - 取1s为单位分析cpu时间
      - 由于数据传送速录为50kB/s,那么需要的中断次数为
        - $n=\frac{50kB}{4B}=12.5k$次
      - 又,每次中断时间开销为1k个时钟周期
        - 从而,耗费在中断以及输入输出总的时间(中断时间包含了输入输出时间)
        - 为了计算最大占比,用总共耗费在中断上的总是时间
          - $12.5k\times10^3$个周期
        - 从而,百分比p的最大值$p_{max}=\frac{12.5M}{1G}=12.5\times{10^{-3}}=1.25\times{10^-2}=1.25\%$

