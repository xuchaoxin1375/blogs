@[toc]

# OS_I/O系统的层次结构

## I/O系统总览

### I/O系统的层次结构

![image-20220604140157439](https://img-blog.csdnimg.cn/img_convert/45a0e5dd87fcfbd0bdaefa3be7e2586d.png)

### I/O系统中各个模块之间的层次

![image-20220604140624855](https://img-blog.csdnimg.cn/img_convert/a9285ec29e7925e99ff2d1b583c9a335.png)

- 用户层软件

- > I/O系统接口

- 设备独立性(无关性)软件

- 设备驱动程序

- 中断处理程序

- > RW/HW接口

- 设备控制器

> 在上、下两个接口之间则是I/O系统

### I/O系统的上、下接口

#### (1)I/O系统接口

- 它是**I/O系统与上层系统之间的接口**，向**上层提供对设备进行操作的抽象I/O命令**，以方便高层对设备的使用。

- 有不少OS在用户层提供了与I/O操作有关的库函数，供用户使用。

- 在**上层**系统中有**文件系统、虚拟存储器系统以及用户进程**等。

- 包括:

  - 块设备接口
  - 流设备接口

  - 网络通信接口

#### (2)软件/硬件(RW/HW)接口

- 该接口是**软件/硬件接口**，在它的上面是**中断处理程序**和用于不同设备的**设备驱动程序**。

- 在它的**下面是各种设备的控制器**。

  - 如CD-ROM控制器、硬盘控制器、键盘控制器、打印机控制器、网络控制器等，它们都属于硬件。

  - 由于设备种类繁多，故该接口相当复杂。

    

### I/O系统的分层 

- 与前面所述的**I/O软件组织**的**层次结构**相对应，**I/O系统本身**也可分为如下三个层次：

- (1)中断处理程序。

  - 它处于I/O系统的底层，直接与硬件进行交互。当有I/O设备发来中断**请求信号**时，在<u>中断硬件</u>做了初步处理后，便**转向中断处理程序**。
  - 它首先**保存被中断进程的CPU环境**，然后**转入相应设备的中断处理程序进行处理**，在处理完成后，又**恢复**被中断进程的CPU环境，**返回断点继续运行**。

- (2)设备驱动程序。

  - 它处于I/O系统的**次底层**，是进程和设备控制器之间的**通信程序**，其主要功能是，
    - 将上层发来的抽象I/O请求转换为对I/O设备的**具体命令和参数**，并把它装入到设备控制器中的命令和参数寄存器中，或者相反。
  - 由于设备之间的差异很大，每类设备的驱动程序都不相同，故必须由设**备制造厂商提供，而不是由OS设计者来设计**。
  - 因此，每当在系统中增加一个新设备时，**都需要由安装厂商提供新的驱动程序。**

- (3)设备独立性软件。

  - 现代OS中的**I/O系统**基本上都实现了与**设备无关性**，也称为**与设备无关的软件**。
  - 其基本含义是：<u>I/O软件</u>**独立于**<u>具体使用的物理设备</u>。

  - 由此带来的最大好处是，提高了I/O系统的**可适应性和可扩展性**。
  - 使它们能应用于许多类型的设备，而且在每次增加新设备或替换老设备时，**都不需要对I/O软件进行修改**，这样就**方便了系统的更新和扩展**。
  - **设备独立性软件**的**内容**包括**设备命名、设备分配、数据缓冲和数据高速缓冲一类软件**等。

## I/O设备和设备控制器

- I/O设备一般是由**执行I/O操作的机械部分**和**执行控制I/O的电子部件**组成。
- 通常将这**两部分分开**，
  - **执行I/O操作**的**机械部分**就是一般的**I/O设备**，
  - 而执行**控制I/O的电子部件**则称为**设备控制器**或**适配器（adapter）**
    - 在微型机和小型机中的控制器常做成印刷电路卡形式，因而也常称为**控制卡、接口卡或网卡**，可将它插入计算机的扩展槽中。
  - 在有的大、中型计算机系统中，还配置了I/O通道或I/O处理机。

### 设备与控制器之间的接口

- 通常，**设备**<u>并**不是**直接与**CPU**进行通信</u>而是**与设备控制器通信**，
- 因此，在**I/O设备**中应<u>含有与设备控制器间</u>的**接口**，
  - 在该**接口中**有3种类型的信号各对应一条**信号线**。

#### 数据信号线

- 用于在设备和设备控制器之间传送数据信号。
- 对输入设备而言，由外**界输入的信号经转换器转换后**，所形成的数据**通常先送入缓冲器中**，当<u>数据量达到一定的比特(字符)数后</u>，再从缓冲器**通过一组数据信号线**传送给**设备控制器**
- 对输出设备而言，则是将从设备控制器经过数据信号线传送来的一批数据**先暂存于缓冲器**中，经转换器作适当转换后，再逐个字符地输出。

#### 控制信号线

- 这是作为由设备控制器向I/O设备**发送控制信号时的通路**。
- 该信号规定了**设备将要执行的操作**，如读操作(指由设备向控制器传送数据)或写操作(从控制器接收数据)，或执行磁头移动等操作。

#### 状态信号线

- 该信号线用于传送**指示设备当前状态的信号**。
- 设备的当前状态有正在读(或写)；设备已读(写)完成，并准备好新的数据传送。

### 设备控制器

- **设备控制器**设备控制器的主要功能是，**控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换**。
- 它是**CPU与I/O设备**之间的**接口**，接收从CPU发来的命令，去控制I/O设备工作，使处理机能够从繁杂的设备控制事务中解脱出来。
- 设备控制器是一个**可编址的设备**，当它仅控制一个设备时，**它只有一个唯一的设备地址**；
- 若控制器可连接多个设备，则应含有多个设备地址，每一个设备地址对应一个设备。
- 可把设备控制器分成两类：一类是用于控制字符设备的控制器，另一类是用于控制块设备的控制器。

### 设备控制器的组成

> 由于设备控制器位于CPU与设备之间，它既要与CPU通信，又要与设备通信，还应具有按照CPU所发来的命令去控制设备工作的功能，因此，现有的大多数控制器都是由以下三部分组成:

![image-20220604084932427](https://img-blog.csdnimg.cn/img_convert/76d7e0679a56204bc872e89ee3956664.png)

- 左半部分是cpu与(设备)控制器的结构结构模型;
- 中间部分是IO逻辑模块
- 右半部分是控制器与各个设备接口的结构模型

- 他们通过IO逻辑模块联系起来(通过IO逻辑实现对设备的控制)

#### 设备控制器与处理机的接口。

- 该接口用于实现CPU与设备控制器之间的通信，在该接口中共有**三类信号线**:
  - 数据线、地址线和控制线。
  - **数据线**通常与**两类寄存器**相连接:
    - 第一类是数据寄存器，在控制器中可以有一个或多个数据寄存器，用于存放从设备送来的**数据**(输入)，或从CPU送来的数据(输出)。
    - 第二类是控制/状态寄存器，在控制器中可以有一个或多个这类寄存器，用于存放从CPU送来的**控制信息或设备的状态信息。**

#### IO逻辑

- IO逻辑用于实现**对设备的控制**。
- 它通过**一组控制线**与处理机交互，处理机**利用该逻辑向控制器发送IO命令**。
- 每当CPU要**启动**一个设备时，一方面将启动命令发送给**控制器**，另一方面又同时**通过地址线**把**地址**发送给**控制器**，由**控制器的I/O逻辑**对收到的**地址译码**，再根据所**译出的命令**对所选设备进行控制。

#### 设备控制器与设备的接口

- 在**一个设备控制器**上，可以连接**一个或多个设备**。
- 相应的，在**控制器中**便有**一个或多个<u>设备接口</u>**。
  - 在**每个接口**中都存在**数据、控制和状态<u>三种类型的信号</u>**。
- 控制器中的**IO逻辑**根据**处理机发来的地址信号**去**选择一个设备接口**。







### 设备控制器的基本功能

- (1)接收和识别命令。
  - 设备控制器能接收并识别处理机发来的多种命令。
  - 在控制器中具有相应的**控制寄存器**，用来存放**接收的命令和参数**，并对所接收的**命令进行译码**。
  - 例如，**磁盘控制器**可以接收**CPU发来的**read、write,format等15条不同的命令，而且有些**命令还带有参数**。相应地，在磁盘控制器中**有多个寄存器和命令译码器**等。
- (2)数据交换。
  - **设备控制器**可实现**CPU与控制器之间、控制器与设备之间的数据交换**。
  - 对于前者，是通过**数据总线**，由CPU并行地把数据写入控制器，或从控制器中并行地读出数据。
  - 对于后者，是设备将数据输入到控制器，或从控制器传送给设备。
  - 为此，在控制器中须设置数据寄存器。
- (3)标识和报告**设备的状态**。
  - 控制器应记下设备的状态供CPU了解。
    - 例如，仅当该设备处于发送就绪状态时，CPU才能启动控制器从设备中读出数据。
  - 为此，在控制器中应设置一**状态寄存器**，用其中的**每一位反映设备的某一种状态**。
  - 当CPU将该寄存器的内容**读入后，便可了解该设备的状态**。
- (4)地址识别。
  - 就像内存中的**每一个单元都有一个地址一样**，系统中的**每一个设备也都有一个地址**。设备控制器必须能够识别其所控制的每个设备的地址。
  - 此外，为使CPU能向(或从)寄存器中写入(或读出)数据，这些寄存器都应**具有唯一的地址**。控制器应能正确识别这些地址。
  - 为此，在控制器中应配置**地址译码器**。
- (5)数据缓冲区。
  - 由于I/O设备的**速率较低**，而CPU和内存的速率却很高，故在控制器中必须**设置一缓冲区**。
  - 在输出时，用此缓冲区暂存由主机高速传来的数据，然后才**以与I/O设备所匹配的速率将缓冲器中的数据传送给I/O设备**。
  - 在输入时，缓冲区则用于暂存从I/O设备送来的数据，待接收到一批数据后，再将缓冲区中的数据高速地传送给主机。
- (6)差错控制。
  - 对于由I/O设备传送来的数据，**设备控制器还兼管进行差错检测**。若发现传送中出现了错误，通常是将差错检测码置位，并向CPU报告，于是**CPU将本次传送来的数据作废**，  =并重新进行一次传送。这样便可保证数据输入的正确性。





## 设备驱动程序

- 设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序，其主要任务是**接收上层软件发来的抽象I/O要求**，
  - 如read或write命令，再把它**转换为具体要求后**，发送给设备控制器，启动设备去执行：
- 反之，它也将**由设备控制器发来的信号传送给<u>上层软件</u>**。
- 由于驱动程序与硬件密切相关，故通常应为**每一类设备配置一种驱动程序**。
  - 例如，打印机和显示器需要不同的驱动程序。

#### 设备驱动程序的功能

- 为了实现I/O系统的**高层与设备控制器**之间的通信，设备驱动程序应具有以下功能：
  - (I)接收由**与设备无关的软件**发来的命令和参数，并将**命令中的抽象要求转换为与设备相关的低层操作序列。**
  - (2)检查用户I/O请求的**合法性**，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式。
  - (3)发出I/O命令，
    - 如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；
    - 如果设备忙碌，则将请求者的请求块挂在设备队列上等待
  - (4)**及时响应**由设备控制器发来的**中断请求**，并根据其中断类型，**调用相应的中断处理程序进行处理**。

#### 设备驱动程序的特点

- 设备驱动程序属于**低级的系统例程**，它与一般的应用程序及系统程序之间有下述明显差异：
- (1)驱动程序是实现在与设备无关的软件和设备控制器之间通信和**转换的程序**，具体说，
  - 它将抽象的I/O请求转换成具体的I/O操作后传送给控制器。
  - 又把控制器中所记录的设备状态和I/O操作完成情况，及时地反映给请求I/O的进程。
- (2)驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，对于不同类型的设备，应配置不同的驱动程序。但可以为相同的多个终端设置一个终端驱动程序。
- (3)驱动程序与I/O设备所采用的I/O控制方式紧密相关，常用的I/O控制方式是中断驱动和DMA方式。
- (4)由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。目前有很多驱动程序的基本部分已经固化在ROM中。
- (5)驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。

### 设备处理方式

在不同的操作系统中，所采用的设备处理方式并不完全相同。根据在设备处理时是否设置进程，以及设置什么样的进程，而把设备处理方式分成以下三类：

- (1)为每一类设备设置一个**进程**，专门用于执行这类设备的I/O操作。
  - 比如，为所有的交互式终端设置一个交互式终端进程；
  - 又如，为同一类型的打印机设置一个打印进程。这种方式比较适合于较大的系统。
- (2)在**整个系统**中设置一个**I/O进程**，专门用于**执行系统中所有各类设备的I/O操作**。也可以设置一个输入进程和一个输出进程，分别处理系统中的**输入或输出操作。**
- (3)不设置专门的**设备处理进程**，而只为各类设备**设置相应的设备驱动程序**，供用户或系统进程调用。
  - 这种方式目前用得较多。

#### 设备驱动程序的处理过程

- 设备驱动程序的主要任务是启动指定设备，完成上层指定的I/O工作。
- 但在启动之前，应先完成必要的准备工作，如检测设备状态是否为“忙”等。
- 在完成所有的准备工作后，才向设备控制器发送一条启动命令。
- 以下是设备驱动程序的处理过程：
  - (1)将抽象要求转换为具体要求。
    - 通常在每个**设备控制器**中都含有若干个**寄存器**，分别用于暂存**命令、参数和数据**等。
    - 由于用户及上层软件对设备控制器的具体情况毫无了解，因而**只能发出命令**(抽象的要求)，这些命令是无法传送给设备控制器的。
    - 因此，就需要将这些**抽象要求转换为具体要求**。
      - 例如，将抽象要求中的**盘块号**转换为**磁盘的盘面、磁道号及扇区**。
    - 而这一转换工作**只能由驱动程序来完成**，因为在OS中**只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况**，也只有**它才知道命令、数据和参数应分别送往哪个寄存器**。
  - (2)对服务请求进行校验。
    - 驱动程序在启动I/O设备之前，必须先检查该用户的I/O请求是不是该设备能够执行的。
      - 一个非法请求的典型例子是，用户试图请求从一台打印机**读**入数据。
      - 如果驱动程序能检查出这类错误便认为这次I/O请求非法，它将向I/O系统报告I/O请求出错。
      - I/O系统可以根据具体情况做出不同的决定。
      - 如可以停止请求进程的运行，或者仅通知请求进程它的I/O请求有错，但仍然让它继续运行。
      - 此外，还有些设备如磁盘和终端，它们虽然都是既可读、又可写的，但若在打开这些设备时规定的是读，则用户的写请求必然被拒绝。
  - (3)检查设备的状态。
    - 启动某个设备进行I/O操作，其前提条件应是该**设备正处于就绪状态**。
      - 为此，在每个设备控制器中，都配置有一个状态寄存器。
      - 驱动程序在启动设备之前，要先把状态寄存器中的内容读入到CPU的某个寄存器中，**通过测试寄存器中的不同位，来了解设备的状态**，
        - 例如，为了向某设备写入数据，此前应先检查状态寄存器中接收就绪的状态位，看它是否处于接收就绪状态。
        - 仅当它处于接收就绪状态时，才能启动其设备控制器，否则只能等待。
  - (4)传送必要的参数。
    - 在确定设备处于接收(发送)就绪状态后，便可向控制器的相应寄存器传送数据及与控制本次数据传输有关的参数。
      - 例如，在某种设备控制器中配置了**两个控制寄存器**，
      - 其中一个是**命令寄存器**，用于**存放处理机发来的各种控制命令，以决定本次I/O操作是接收数据还是发送数据等。**
      - 另一个是**方式寄存器**，它用于控制本次传送数据的速率、发送的字符长度等。
      - 如果是利用RS232C接口进行异步通信，在启动该接口之前，应先按通信规程设定下述参数：波特率、奇偶校验方式、停止位数目及数据字节长度等。
      - 对于较为复杂的块设备，除必须向其控制器发出启动命令外，还需传送更多的参数。
  - (5)启动I/O设备。
    - 在完成上述各项准备工作后，驱动程序便可以向控制器中的命令寄存器传送相应的控制命令。
    - 对于字符设备，若发出的是写命令，驱动程序便把一个字符(或字)，传送给控制器：
    - 若发出的是读命令，则驱动程序等待接收数据，并通过读入控制器的状态寄存器中状态字的方法来确定数据是否到达。
    - 在多道程序系统中，**驱动程序**一旦发出IO命令，启动了一个I/O操作后，<u>驱动程序便把控制返回给I/O系统</u>，**把自己阻塞起**来，**直到中断到来时再被唤醒**。
      - 具体的I/O操作是在**设备控制器**的控制下进行的，
      - 因此，在设备忙于**传送数据时**，处理机又可以去干其它的事情，实现了**处理机与I/O设备的并行操作**。

## 与设备无关的IO软件

- 为了方便用户和提高OS的可适应性与可扩展性，在现代OS的I/O系统中，都无一例外地增加了与设备无关的I/O软件，以实现设备独立性，也称为设备无关性。
  - 其基本含义是：**应用程序中所用的**设备，不局限于使用某个具体的物理设备。
  - 为每个设备所配置的设备驱动程序是与硬件紧密相关的软件。
  - 为了实现设备独立性，必须**再在设备驱动程序之上设置一层软件，称为与设备无关的I/O软件**，或设备独立性软件。

### 与设备无关（DeviceIndependence）软件的基本概念

![image-20220605085845072](https://img-blog.csdnimg.cn/img_convert/b3cac5328f60d992e83e68ce349f6bb1.png)

- 与设备无关软件的功能层次

#### 以物理设备名使用设备

- 在早期OS中，应用程序在使用I/O设备时，都使用设备的物理名称，这使应用程序与系统中的物理设备直接相关。

- 当应用进程运行时，如果所请求的物理设备（独占设备类型）己分配给其它进程，而此时尽管还有几台其它的相同设备空闲可用，但**系统只能根据设备的物理名来分配**，无法将另外相同的设备（但具有不同的物理设备名）分配给它，致使该应用进程请求I/O失败而被阻塞。

- 特别是，当应用程序所需要的**设备在系统中已经被更新**时，<u>*该应用程序*</u>将**再也无法在该系统上运行**。

- > 可见，应用程序直接与物理设备相关是**非常不灵活**的，给用户带来了很大的不便，且对提高I/O设备的利用率也很不利。

#### 2.引入了逻辑设备名

- 为了实现与设备的无关性而引入了逻辑设备和物理设备两个概念。
- 逻辑设备是抽象的设备名。
  - 如/dev/printer,该设备名只是说明用户需要使用打印机来打印输出，但并没有指定具体是哪一台打印机。
  - 这样，如果在应用程序中，使用逻辑设备名称请求使用某类设备，系统在对它进行设备分配时，先查找该类设备中的第一台，如它已被分配，系统可立即去查找该类设备中第二台，若又被分配，系统接着去找第三台，若它尚未分配，便可将这台设备分配给进程。
  - 事实上，只要系统中有一台该类设备未被分配，进程就不会被阻塞。
  - 仅当所请求的**此类**设备己全部分配完毕时，进程才会因请求失败而阻塞。
  - 所以，应用进程就**不会由于某台指定设备退役而无法在本系统上运行**。
- 与设备的无关软件还可实现I/O重定向。
  - 所谓I/O重定向，是指用于I/O操作的**设备可以更换**（即重定向），而**不必改变应用程序**。
    - 例如，我们在调试一个应用程序时，可将程序的所有输出送往屏幕显示。
    - 而在程序调试完后，若须正式将程序的运行结果打印出来，此时便须将I/O重定向的数据结构——逻辑设备表中的**显示终端改为打印机**即可，而不必修改应用程序。
    - I/O重定向功能具有**很大的实用价值**，现已被广泛地引入到各类OS中。

#### 3.逻辑设备名称到物理设备名称的转换

- 在应用程序中，用逻辑设备名称使用设备虽然方便了用户，但**系统却只识别物理设备名称**，因此在实际执行时，还必须使用物理名称。
- 为此，在系统中，必须具有将逻辑设备名称转换为某物理设备名称的功能。
- 关于逻辑设备名称和物理设备名称的概念，与存储器管理中所介绍的逻辑地址和物理地址的概念非常类似，在应用程序中所使用的是逻辑地址，而系统在分配和使用内存时，必须使用物理地址。
- 在程序执行时，必须先将逻辑地址转换为物理地址。
  - 类似地，为实现从逻辑设备名称和物理设备名称，在系统中需要配置一张**逻辑设备表**。

### 与设备无关的软件

- **与设备无关的软件是I/O系统的最高层软件**，在它下面的是设备驱动程序，其间的界限，因操作系统和设备的不同而有所差异。
  - 比如，对于一些本应由设备独立性软件实现的功能，却放在设备驱动程序中实现。这样的差异主要是出于对操作系统、设备独立性和设备驱动程序运行效率等多方面因素的权衡和考虑。
  - 总的来说，在**与设备无关的软件**中，包括了<u>执行**所有设备公有操作**</u>的**软件**，具体有如下几项。
  - 1.设备驱动程序的统一接口
    - 为了使所有的设备驱动程序有着统一的接口，一方面，要求每个设备驱动程序与OS之间都有着相同的接口，或者相近的接口，这样会使添加一个新的设备驱动程序变得很容易，同时在很大程度上方便了开发人员对设备驱动程序的编制。
    - 另一方面，要将抽象的设备名映射到适当的驱动程序上，或者说，将抽象的设备名转换为具体的物理设备名，并进一步可以找到相应物理设备的驱动程序入口。
    - 此外，还应对设备进行保护，禁止用户直接访问设备，以防止无权访问的用户使用。
  - 2.缓冲管理
    - 无论是字符设备还是块设备，它们的运行速度都远低于CPU的速度。
    - 为了缓和CPU和I/O设备之间的矛盾、提高CPU的利用率，在现代OS中都无一例外地分别为字符设备和块设备配置了相应的缓冲区。
    - 缓冲区有着多种形式，如**单缓冲区、双缓冲区、循环缓冲区、公用缓冲池**等，以满足不同情况的需要。
  - 3.差错控制
    - 由于设备中有着许多的**机械和电气部分**，因此，它们比主机更容易出现故障，这就导致I/O操作中的绝大多数错误都与设备有关。
    - 错误可分为如下两类：
      - (1)暂时性错误。暂时性错误是因发生暂时性事件引起的，如电源的波动。它可以通过重试操作来纠正。
        - 例如，在网络传输中，由于传输路途较远、缓冲区数量暂时不足等因素，会经常发生在网络中传输的数据包丢失或延误性的暂时性错误。
        - 当网络传输软件检测到这种情况后，可以通过重新传送来纠正错误。
        - 又如，当磁盘传送发生错误后，开始驱动程序并不立即认为传送出错，而是令磁盘重传，只有连续多次(如10次)出错，才认为磁盘出错，并向上层报告。
        - 一般地，设备出现故障后，主要由设备驱动程序处理，而设备独立性软件只处理那些设备驱动程序无法处理的错误。
      - (2)持久性错误。
        - 持久性错误是由持久性故障引起的，如电源掉电、磁盘上有一条划痕或者在计算中发生除以零的情况等。
        - 持久性错误容易发现，有些错误是只要重复执行相同的程序就会再现的错误。
        - 要排除持久性错误，通常需要查清发生错误的原因。
        - 但也有某些持久性硬件错误可由操作系统进行有效的处理，而不用涉及高层软件。如磁盘上的少数盘块遭到破坏而失效，此时无需更换磁盘，而只需**将它们作为坏的盘块记录下来**，并放入一张**坏盘块表**中，以后**不再使用这些坏块**即可。
  - 4.对独立设备的分配与回收
    - 在系统中有两类设备：独占设备和共享设备。
    - 对于**独占设备，为了避免诸进程对独占设备的争夺，必须由系统来统一分配**，不允许进程自行使用。
    - 每当进程需要使用某(独占)设备时，**必须先提出申请**。
    - OS接到对设备的请求后，先对进程所请求的**独占设备进行检查**，看该设备是否空闲。
      - 若空闲，才把该设备分配给请求进程。
      - 否则，进程将被阻塞，放入该设备的请求队列中等待。等到其它进程释放该设备时，再将队列中的第一个进程唤醒，该进程得到设备后继续运行。
  - 5.独立于设备的逻辑数据块
    - 不同类型的设备，其数据交换单位是不同的，读取和传输速率也各不相同，如字符型设备以单个字符(字)为单位，块设备是以一个数据块为单位。
    - 即使同一类型的设备，其数据交换单位的大小也是有差异的,如不同磁盘由于扇区大小的不同，可能造成数据块大小的不一致。
    - 设备独立性软件应能够**隐藏这些差异而被逻辑设备使用**，并**向高层软件提供大小统一的逻辑数据块**。与设备无关软件的功能

### 设备分配

- 系统为实现对独占设备的分配，必须在系统中配置相应的数据结构。

#### 1.设备分配中的数据结构

- 在用于设备分配的数据结构中，记录了对**设备或控制器进行控制所需的信息**。
- 在进行设备分配时需要如下的数据结构。

##### 1)设备控制表DCT

- 系统为**每一个设备**都配置了一张**设备控制表**，用于记录设备的情况，
- ![image-20220605150612177](https://s2.loli.net/2022/06/05/ObHq6IpzrcDlZJW.png)
- 其中,设备控制器表对应一个设备控制器,(因此,在后面提到的分配控制器的步骤中),可以从DCT中找出该设备连接的控制器的COCT

- 设备控制表中，除了有用于指示设备类型的字段type和设备标识字段deviceid外，
- 还应含有下列字段：
  - (1)设备队列队首指针，凡因请求本设备而未得到满足的进程，应将其**PCB**按照一定的策略排成一个**设备请求队列**，其**队首指针指向队首PCB**；
  - (2)忙/闲标志，用于表示当前设备的状态是忙或闲：
  - (3)与设备连接的控制器表指针，该指针指向该设备所连接的控制器的控制表；
  - (4)重复执行次数，由于外部设备在传送数据时较易发生数据传送错误，因而在许多系统中**规定了设备在工作中发生错误时应重复执行的次数**，在重复执行时，若能恢复正常传送，则仍认为传送成功，仅当重复执行次数达到规定值仍不成功时，才认为传送失败。

##### 2)控制器控制表、通道控制表和系统设备表

###### (1)控制器控制表(COCT)

- 系统为**每一个控制器**都设置了**用于记录控制器情况**的控制器控制表，
- ![image-20220605150850385](https://s2.loli.net/2022/06/05/btGpyBe5qOjnQlJ.png)。

###### (2)通道控制表(CHCT)

- 每个通道都有一张通道控制表。
- ![image-20220605150928879](https://s2.loli.net/2022/06/05/8R3WGFtxIPJjYk7.png)

###### (3)系统设备表(SDT)

- 这是系统范围的数据结构，记录了**系统中全部设备的情况**，每个设备占一个表目，其中包括有设备类型、设备标识符、设备控制表及设备驱动程序的入口等项，
- ![image-20220605150946988](https://s2.loli.net/2022/06/05/wMKSyJDf8ktlABj.png)

#### 2.设备分配时应考虑的因素

- 系统在分配设备时，应考虑如下几个因素：
- 1)设备的固有属性
  - (1)独占设备的分配策略。将一个设备分配给某进程后，便由该进程独占，直至该进程完成或释放该设备。
  - (2)共享设备的分配策略。对于共享设备，可**同时分配给多个进程使用**，此时须注意**对这些进程访问该设备的先后次序进行合理的调度**。
  - (3)**虚拟设备**的分配策略，虚拟设备属于**可共享的设备**，可以将它**同时分配给多个进程使用**。
- 2)**设备分配算法**对设备分配的算法，通常只采用以下**两种分配算法**：
  - (1)先来先服务。该算法是根据诸进程对某设备提出请求的先后次序，将这些进程排成一个设备请求队列，设备分配程序总是把设备首先分配给队首进程。
  - (2)优先级高者优先。在利用该算法形成设备队列时，将优先级高的进程排在设备队列前面，而对于优先级相同的I/O请求，则按先来先服务原则排队。
- 3)设备分配中的**安全性**
  - 从进程运行的安全性上考虑，设备分配有以下两种方式：
    - (1)安全分配方式。
      - 每当进程发出I/O请求后，**便进入阻塞状态**，直到其I/O操作完成时才被唤醒。
      - 在采用该策略时，一旦进程已经**获得某种设备后便阻塞**，不能再请求任何资源，而**在它阻塞时又不保持任何资源**。
      - 因此，摒**弃了造成死锁的四个必要条件之一的“请求和保持"条件**，故设备**分配是安全的**。其缺点是CPU与I/O设备是**顺序工作**的。
    - (2)不安全分配方式。
      - 在这种分配方式中，进程在发出I/O请求后仍继续运行，需要时又发出第二个I/O请求、第三个I/O请求等。
      - 仅当进程所请求的设备已**被另一进程占用时,才进入阻塞状态**。
      - 该策略的优点是，一个**进程可同时操作多个设备，使进程推进迅速**。
      - 其缺点是分配不安全，因为它可能具备“请求和保持”条件，从而可能造成死锁。
      - 因此，在设备分配程序中，应对本次的设备分配**是否会发生死锁进行安全性计算**，仅当计算结果说明分配是安全的情况下，才进行设备分配。

#### 3.独占设备的分配程序

- 1)基本的设备分配程序

  - 我们通过一个例子来介绍设备分配过程。当某进程提出I/O请求后，系统的设备分配程序可按下述步骤进行设备分配：

    - (1)分配**设备**。
      - 首先<u>根据I/O请求中的**物理设备名**</u>**查找系统设备表SDT**,从中**找出该设备的DCT,**
      - 再根据DCT中的设备状态字段，可知该**设备是否正忙**。
        - 若忙，便将请求I/O的进程的**PCB挂在设备队列上**;
        - 否则，便按照一定的算法，**计算本次设备分配的安全性**。
          - 如果不会导致系统进入不安全状态，便将设备分配给请求进程；
          - 否则，仍将其PCB插入设备等待队列。
          - ```mermaid
            graph LR
            A(SDT系统设备表) --查找-->B([DCT设备控制表])
            B --"设备状态(status)"--- C{busy?}
            D(挂到PCB任务队列)
            E[计算本次分配安全性]
            C -->|yes|D 
            C -->|no|E
            F(执行分配)
            G{save?}
            E-->G
            G-->|yes|F
            G-->|No|D

  - (2)分配**控制器**。

    - 在系统把设备分配给请求I/O的进程后，
    - 再到其**DCT中找出与该设备连接的控制器的COCT**,
    - 从**COCT的状态字段**中可知该控制器是否忙碌。

      - 若忙，便将请求I/O进程的**PCB,挂在该控制器的等待队列上**。
      - 否则，便将该控制器分配给进程。

        - ```mermaid
          graph LR
              A(系统将设备分配给进程) --在DCT中查找与设备连接的控制器-->B([COCT])
              B --"控制器状态(status)"--> is_busy{busy?}
              busy_no(挂到PCB任务队列)
              busy_yes[将控制器分配给进程]
              append_controller(挂到该控制器的等待队列)
              is_busy -->|yes|append_controller 
              is_busy -->|no|busy_no
          ```
        - 
  - (3)分配**通道**。

    - 在**该COCT中**又可找到**与该控制器连接的通道的CHCT**,

    - 再根据**CHCT内的状态信息**可知该**通道是否忙碌**。

      - 若忙，便将请求I/O的进程挂在该**通道的等待队列**上；
      - 否则，将该**通道分配给进程**。

    - ```mermaid
      graph LR
         assigned_controller(系统将控制器分配给进程)
         check_chct(查找控制器对应的通道)
         is_chct_busy{busy?}
         chct_busy(挂到该通道的等待队列)
         chct_free(将通道分配给进程)
         assigned_controller-->check_chct--检查CHCT状态字段-->is_chct_busy-->|yes|chct_busy
         is_chct_busy-->|no|chct_free
      ```

  ```mermaid
  flowchart LR
      subgraph  s1 [step1]
          direction TB
      check_SDT(SDT系统设备表)--find-->dct["DCT设备控制表by指针"]
      dct --"设备状态(status)"--- is_busy_device{busy?}
      append_device(挂到PCB任务队列)
      safety[计算本次分配安全性]
      is_busy_device -->|yes|append_device
      is_busy_device -->|no|safety
      is_safe{safe?}
      safety-->is_safe
      is_safe-->|yes|assign_device(执行分配step2)
      is_safe-->|No|append_device
      end
  
      %%assign_device
      subgraph s2 [step2]
          direction TB
      dct2(DCT设备控制表) --在DCT中查找与设备连接的控制器-->coct([COCT])
      coct --"控制器状态(status)"--> is_busy_controller{busy?}
      append_controller(挂到该控制器的等待队列)
      is_busy_controller -->|yes|append_controller 
      is_busy_controller -->|no|assign_controller(执行分配step3)
      end
    
  
  
      subgraph s3 [step3]
          direction TB
  
      %%use the square bracket `[]` to name the group(subgraph) to be connect with other part of the flowchart
      coct2(COCT控制器控制表)--查找-->chct(CHCT)
      is_chct_busy{busy?}
      append_chct(挂到该通道的等待队列)
      assign_chct(将通道分配给进程)
      chct--检查CHCT状态字段-->is_chct_busy-->|yes|append_chct
      is_chct_busy-->|no|assign_chct
      end
      s1-->s2-->s3
  ```

  

> - 只有在设备、控制器和通道三者都分配成功时，这次的设备分配才算成功。
> - 然后，便可启动该I/O设备进行数据传送。

- 2)设备分配程序的改进

  - 在上面的例子中，进程是以物理设备名提出I/O请求的。
  - 如果所指定的设备己分配给其它进程，则分配失败。
  - 或者说上面的设备分配程序不具有与设备无关性。为获得设备的独立性，进程应使用逻辑设备名请求I/O。这样，系统首先从SDT中找出第一个该类设备的DCT。若该设备忙，又查找第二个该类设备的DCT,仅当所有该类设备都忙时，才把进程挂在该类设备的等待队列上。而只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。如安全，便可把设备分配给它。

### 逻辑设备名到物理设备名映射的实现

- 为了实现与设备的无关性，当应用程序请求使用I/O设备时，应当用逻辑设备名。
- 但系统只识别物理设备名，因此在系统中需要配置一张**逻辑设备表**，用于将逻辑设备名**映射为物理设备名**。

#### 逻辑设备表LUT(LogicalUnitTable)

- 在逻辑设备表的每个表目中包含了三项：
  - 逻辑设备名、物理设备名和设备驱动程序的**入口地址**
  - ![image-20220605190553131](https://s2.loli.net/2022/06/05/GFVvupa1XBbcNDy.png)
  - 当进程用逻辑设备名请求分配I/O设备时，系统根据当时的具体情况，为它分配一台相应的物理设备。
  - 与此同时，在逻辑设备表上**建立一个表目**，填上应用程序中使用的逻辑设备名和系统分配的物理设备名，以及该设备驱动程序的入口地址。
  - 当以后进程再利用该逻辑设备名请求I/O操作时，**系统通过查找LUT**,便可找到该逻辑设备所对应的物理设备和该设备的驱动程序。

#### 逻辑设备表的设置问题

- 在系统中可采取两种方式设置逻辑设备表：
  - ![image-20220605190734249](https://s2.loli.net/2022/06/05/Sj9IxuA7FaKWDHw.png)
  - 第一种方式，是在整个系统中只设置一张LUT。
    - 由于系统中所有进程的设备分配情况都记录在同一张LUT中，因而不允许在LUT中具有相同的逻辑设备名，这就要求所有用户都不使用相同的逻辑设备名。
    - 在多用户环境下这通常是难以做到的，因而这种方式主要用于**单用户系统**中。
  - 第二种方式，是为每个用户设置一张LUT,
    - 每当用户登录时，系统便为该用户**建立一个进程**，**同时也为之建立一张LUT,**并将该表放入**进程的PCB**中。
    - 由于通常在多用户系统中都配置了系统设备表，故此时的逻辑设备表可以采用上图格式。

## 用户层的IO软件

> 用户层的I/O软件一般而言，大部分的I/O软件都放在操作系统内部，但仍有一小部分在用户层，其中包括与用户程序链接在一起的库函数，以及完全运行于内核之外的假脱机系统等。

### 1.系统调用

- 一方面，为使诸进程能有条不紊地使用I/O设备，且能保护设备的安全性，不允许运行在用户态的应用进程去直接调用运行在核心态(系统态)的OS过程。
- 但另一方面，应用进程在运行时，又必须取得OS所提供的服务，否则，应用程序几乎无法运行。
- 为了解决此矛盾，OS在用户层中引入了一个**中介过程**——**系统调用**，应用程序可以通过它间接调用OS中的I/O过程，对I/O设备进行操作。
- 系统中会有许多系统调用，它们的实现方法是基本相同的。
- 下面简单说明系统调用的执行过程。
  - 当应用程序需要执行某种I/O操作时，在应用程序中必须使用相应的系统调用。
    - 当OS捕获到应用程序中的该系统调用后，便将CPU的状态从**用户态转换到核心态**，然后转向操作系统中相应过程，由该过程完成所需的I/O操作。
    - 执行完成后，系统又将CPU状态从核心态转换到用户态，返回到应用程序继续执行
  - 事实上，由OS**向用户提供的所有功能**，**用户进程都必须通过系统调用来获取**，
    - 或者说，**系统调用是应用程序取得OS所有服务的唯一途径**。
    - 在早期的操作中，系统调用是以汇编语言形式提供的，所以只有在用汇编语言编写的程序中，才能直接使用系统调用，这对用户是非常不方便的，后来在C语言中，首先提供了**与系统调用相对应的库函数**。

### 2.库函数

- 在**C语言以及UNIX系统**中，系统调用(如read)与各系统调用所使用的库函数(如read)之间几乎是一一对应的。

- 而**微软**定义了一套过程，称为**Win32API的应用程序接口(ApplicationProgramInterface)**,程序员利用它们取得OS服务，该接口与实际的系统调用并不一一对应。
- 用户程序通过调用对应的**库函数使用系统调用**，这些库函数与调用程序连接在一起，被嵌入在运行时装入内存的二进制程序中。
- 在C语言中提供了多种类型的库函数，对于I/O方面，**主要是对文件和设备进行读/写的库函数**，**以及控制/检查设备状态的库函数。**
- 显然这些库函数的集合也应**是I/O系统的组成部分**。
- 而且我们可以这样来看待内核和库函数之间的关系：**内核提供了OS的基本功能，而库函数扩展了OS内核**，使用户能方便取得操作系统的服务。
- 在许多现代OS中，**系统调用本身已经采用C语言编写，并以函数形式提供**，所以在使用**C语言编写的用户程序中，可以直接使用这些系统调用。**
- 另外，操作系统在用户层中还提供了一些非常有用的程序，如下面将要介绍的假脱机系统，以及在网络传输文件时常使用的守护进程等，它们是**运行在内核之外**的程序，**但它们仍属于I/O系统**。

### 假脱机(Spooling)系统

> 如果说，通过多道程序技术可将一台**物理CPU虚拟为多台逻辑CPU**,从而允许多个用户共享一台主机，那么，通过假脱机技术，则**可将一台物理I/O设备虚拟为多台逻辑I/O设备**，这样也就**允许多个用户共享一台物理I/O设备**。
>
> - In [computing](https://en.wikipedia.org/wiki/Computing), **spooling** is a specialized form of [multi-programming](https://en.wikipedia.org/wiki/Computer_multitasking) for the purpose of copying data between different devices. In contemporary systems,[[a\]](https://en.wikipedia.org/wiki/Spooling#cite_note-1) it is usually used for mediating between a computer application and a slow [peripheral](https://en.wikipedia.org/wiki/Peripheral), such as a [printer](https://en.wikipedia.org/wiki/Printer_(computing)). 
> - Spooling allows programs to "hand off" work to be done by the peripheral and then proceed to other tasks, or to not begin until input has been transcribed. 
> - A dedicated program, the **spooler**, maintains **an orderly sequence of jobs** for the peripheral and feeds it data at its own rate. 
> - Conversely, for slow *input* peripherals, such as a [card reader](https://en.wikipedia.org/wiki/Punched_card), a **spooler** can maintain a sequence of computational jobs waiting for data, starting each job when all of the relevant input is available; 
> - see [batch processing](https://en.wikipedia.org/wiki/Batch_processing). The **spool** itself refers to the sequence of jobs, or the storage area where they are held.
> -  In many cases, the spooler is able to drive devices at their full rated speed with minimal impact on other processing.
>
> Spooling is a combination of [buffering](https://en.wikipedia.org/wiki/Data_buffer) and [queueing](https://en.wikipedia.org/wiki/Queue_(data_structure)).

Print spooling

- Nowadays, the most common use of spooling is printing: [documents](https://en.wikipedia.org/wiki/Document) formatted for printing are stored in a queue at the speed of the computer, then retrieved and printed at the speed of the printer. 
- Multiple processes can write documents to the spool without waiting, and can then perform other tasks, while the "spooler" process operates the printer.[[1\]](https://en.wikipedia.org/wiki/Spooling#cite_note-TheSpooler-2)

- For example, when a large organization prepares payroll cheques, the computation takes only a few minutes or even seconds, but <u>the printing process might take hours.</u>
-  If the payroll program printed cheques directly, it would be unable to proceed to other computations until all the cheques were printed.
-  Similarly, before spooling was added to [PC](https://en.wikipedia.org/wiki/Personal_computer) operating systems, [word processors](https://en.wikipedia.org/wiki/Word_processor) were unable to do anything else, including interact with the user, while printing.

Spooler or print management software often includes a variety of related features, such as allowing priorities to be assigned to print jobs, notifying users when their documents have been printed, distributing print jobs among several printers, selecting appropriate paper for each document, etc.

A [print server](https://en.wikipedia.org/wiki/Print_server) applies spooling techniques to allow many computers to share the same printer or group of printers

#### SPOOLing系统的组成

![image-20220605091739488](https://img-blog.csdnimg.cn/img_convert/94216d16cd79a39708dc7a19e205bb3f.png)

> - **假脱机技术**在20世纪50年代，为了缓和CPU的高速性与I/O设备低速性间的矛盾，而引入了**脱机输入、脱机输出技术**。
> - 该技术是利用专门的**外围控制机**，先将**低速I/O设备上的数据传送到高速磁盘**上，或者相反。

- 这样当处理机需要输入数据时，便可以**直接从磁盘中读取数据**，极大地提高了输入速度。
- 反之，在处理机需要输出数据时，也可以**很快的速度把数据先输出到磁盘上**，**处理机便可去做自己的事情**。
- 事实上，当系统中引入了多道程序技术后，完全可以利用其中的一道程序，来**模拟脱机输入**时的外围控制机功能，把低速I/O设备上的数据传送到高速磁盘上。
- 再用另一道程序模拟**脱机输出**时外围控制机的功能，把数据从磁盘传送到低速输出设备上。
- 这样，便可在主机的直接控制下，实现以前的脱机输入、输出功能。
- 此时的外围操作与CPU对数据的处理同时进行，我们把这种**在联机情况下实现的同时外围操作**的技术称为SPOOLing(SimultaneausPeriphemalOperatingOnLine)技术，或称为假脱机技术。
- 2.SPOOLing的组成如前所述，SPOOLing技术是对脱机输入/输出系统的模拟，相应地，如图6-21(a)所示，SPOOLing系统**建立在通道技术和多道程序技术的基础上**，以**高速随机外存(通常为磁盘)为后援存储器**。

#### SPOOLing的工作原理

![image-20220605091828193](https://img-blog.csdnimg.cn/img_convert/abdf333be94ca60259fda46f6c615a60.png)

##### 井(磁盘中)

- (1)输入井和输出井。这是在**磁盘上开辟**出来的两个存储区域。
  - 输入井**模拟脱机输入时的磁盘**，用于收容I/O设备输入的数据。
  - 输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。
  - 输入/输出井中的数据**一般以文件的形式组织管理**，我们把这些**文件称为井文件**。
  - 输入/输出队列:**一个文件**仅存放某**一个进程的输入(或者输出)数据**，所有进程的数据输入(或输出)**文件链接成为一个输入(或输出)队列。**

##### 缓冲区(内存中)

- (2)输入缓冲区和输出缓冲区。
  - 这是在**内存中开辟的两个缓冲区**，用于缓和CPU和磁盘之间速度不匹配的矛盾。
  - 输入缓冲区用于暂存由输入设备传送的数据，之后再传送到输入井。
  - 输出缓冲区用于暂存从输出井传送的数据，之后再传送到输出设备。

##### 输入输出进程

- (3)输入进程和输出进程。
  - 输入进程也称为**预输入进程**，用于**模拟脱机输入时的外围控制机**，将用户要求的数据从输入设备传送到输入缓冲区，再存放到输入井。
  - 当CPU需要输入设备时，直接**从输入井**读入内存。
    - 输出进程也称为**缓输出进程**，用于模拟脱机输出时的外围控制机，把用户要求输入的数据**从内存传送并存放到输出井**，待输出设备空闲时，再将输出井中的数据经过输出缓冲区输出至输出设备上。

##### 井管理程序

- 用于控制作业与磁盘井之间信息的交换。
- 当作业执行过程中向某台设备发出启动输入或输出操作请求时，由**操作系统调用井管理程序**，由其控制**从输入井读取信息或将信息输出至输出井**。

#### SPOOLing系统的特点

- (1)提高了I/O的速度。这里，对数据所执行的I/O操作，已从对低速I/O设备执行的I/O操作演变为**对磁盘缓冲区中数据的存取**，如同脱机输入输出一样，提高了I/O速度，缓和了CPU与低速I/O设备之间速度不匹配的矛盾。
- (2)将**独占设备改造为共享设备**。因为在假脱机打印机系统中，实际上并没为任何进程分配设备，而只是在磁盘缓冲区中为进程分配一个空闲盘块和建立一张I/O请求表。这样，便把独占设备改造为共享设备。
- (3)实现了**虚拟设备功能**。宏观上，虽然是多个进程在同时使用一台独占设备，而对于每一个进程而言，它们都会认为自己是独占了一个设备。当然，该设备只是**逻辑上的设备**。
  - 假脱机打印机系统实现了将独占设备变换为若干台对应的逻辑设备的功能。

#### 假脱机打印机系统

![image-20220605094349518](https://img-blog.csdnimg.cn/img_convert/e412f5ed54b66b7f5bc1a94a0fb9b8cc.png)

- 打印机是经常用到的输出设备，属于独占设备。利用假脱机技术可将它改造为一台可供多个用户共享的打印设备，从而提高设备的利用率，也方便了用户。
- 共享打印机技术已被广泛地用于多用户系统和局域网络中。
- 假脱机打印系统主要有以下三部分：

- (1)磁盘缓冲区。它是在磁盘上开辟的一个存储空间，用于暂存用户程序的输出数据，在该缓冲区中可以设置几个盘块队列，如空盘块队列、满盘块队列等。
- (2)打印缓冲区。用于缓和CPU和磁盘之间速度不匹配的矛盾，设置在内存中，暂存从磁盘缓冲区送来的数据，以后再传送给打印设备进行打印。
- (3)假脱机管理进程和假脱机打印进程。
  - 由假脱机管理进程为每个要求打印的用户数据建立一个假脱机文件，并把它放入假脱机文件队列中，由假脱机打印进程依次对队列中的文件进行打印。
  - 每当用户进程发出打印输出请求时，假脱机打印机系统并不是立即把打印机分配给该用户进程，而是由假脱机管理进程完成两项工作：
    - ①在磁盘缓冲区中为之申请一个空闲盘块，并将要打印的数据送入其中暂存；
    - ②为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到假脱机文件队列上。在这两项工作完成后，虽然还没有进行任何实际的打印输出，但对于用户进程而言，其打印请求已经得到满足，打印输出任务已经完成。
    - 真正的打印输出是假脱机打印进程负责的，当打印机空闲时，该进程首先从假脱机文件队列的队首摘取一张请求打印表，然后根据表中的要求将要打印的数据由输出井传送到内存缓冲区，再交付打印机进行打印。
    - 一个打印任务完成后，假脱机打印进程将再次查看**假脱机文件队列**，若队列非空，则重复上述的工作，直至队列为空。
    - 此后，**假脱机打印进程将自己阻塞起来**，仅当再次有打印请求时，才被重新唤醒运行。
    - 利用假脱机系统向用户提供共享打印机的概念是：
      - 对每个用户而言，系统并非即时执行其程序输出数据的真实打印操作，而只是即时将数据输出到缓冲区，这时的数据并未真正被打印，只是让用户感觉系统已为他打印：
      - 真正的打印操作，是在打印机空闲且该打印任务在等待队列中已排到队首时进行的；
      - 而且，打印操作本身也是利用CPU的一个时间片，没有使用专门的外围机：以上的过程是对用户屏蔽的，用户是不可见的。

##### 守护进程（daemon）

- 前面是利用假脱机系统来实现打印机共享的一种方案，人们对该方案进行了某些修改，如取消该方案中的假脱机管理进程，为打印机建立一个**守护进程**，由它执行一部分原来由假脱机管理进程实现的功能，如为用户在磁盘缓冲区中申请一个空闲盘块，并将要打印的数据送入其中，将该盘块的首址返回给请求进程。
- 另一部分由**请求进程自己完成**，每个要求打印的进程首**先生成一份要求打印的文件**，其中包含对打印的要求和指向装有打印输出数据盘块的指针等信息，然后将用户请求打印文件放入假脱机文件队列（目录）中。
- 守护进程是**允许使用打印机的唯一进程**。
  - 所有需要使用打印机进行打印的进程都需将一份要求打印的文件放在假脱机文件队列（目录）中。
  - 如果守护进程正在睡眠，便将它唤醒，由它按照目录中第一个文件中的说明进行打印，打印完成后，再按照目录中第二个文件中的说明进行打印，如此逐份文件地进行打印，直到目录中的全部文件打印完毕，守护进程无事可做，又去睡眠。
  - 等待用户进程再次发来打印请求。
  - 除了打印机守护进程之外，还可能有许多其它的守护进程，如服务器守护进程和网络守护进程等。
  - 事实上，凡是需要将独占设备改造为可供多个进程共享的设备时，都要为该设备配置一个守护进程和一个假脱机文件队列（目录）。
  - 同样，**守护进程是允许使用该独占设备的唯一进程**，所有其它进程都不能直接使用该设备，只能将对该设备的使用要求写入一份文件中，放在假脱机目录中。
  - 由守护进程按照目录中的文件依次来完成诸进程对该设备的请求，这样就把一台独占设备改造为可为多个进程共享的设备。



## 缓冲&缓存

### 缓冲区

- 缓冲区(buffer)是一块**内存区域**，用于保存在**两个设备之间**或在**设备和应用程序**之间**传输的数据**。

- 采用缓冲有三个理由。

  - 一个理由是，处理数据流的生产者与消费者之间的速度不匹配。
    - 例如，假如通过调制解调器正在接收一个文件，并且保存到硬盘。调制解调器大约比硬盘慢一千倍。这样，创建一个缓冲区在内存中，以便累积从调制解调器处接收的字节。
    - 当整个数据缓冲区填满时，就可以通过一次操作将缓冲区写到磁盘。
    - 由于写入磁盘不是即时的而且调制解调器仍然需要一个空间继续存储额外的输入数据，所以采用两个缓冲区。
    - 在调制解调器**填满第一个缓冲区后**，就请求写入磁盘。
    - 接着，调制解调器开始**填写第二个缓冲区**，而这时第一个缓冲区正被写入磁盘。
    - 等到调制解调器写满第二个缓冲区时，**第一个缓冲区的磁盘写入也应完成**；
    - 因此调制解调器可以**切换到第一个缓冲区**，而磁盘可以写第二个缓冲区。
    - 这种双缓冲(doublebuffering)解耦数据的生产者与消费者，因此**放松两者之间的时序要求**。
    - 下图列出了典型计算机硬件的设备速度的巨大差异
      - ![image-20220605121949530](https://img-blog.csdnimg.cn/img_convert/602ae31d956042b35a6d7068b3e4e4de.png)
      - ![image-20220605110736875](https://img-blog.csdnimg.cn/img_convert/991b84b8448b2e0ec0e8ca0daf4c424e.png)

  - 缓冲的第二种用途是，协调传输大小不一数据的设备。
    - 这种不一致在计算机网络中特别常见，缓冲区大量用于消息的分段和重组。
    - 在发送端，一个大的消息分成若干小的网络分组。
    - 这些网络分组通过网络传输，而接收端将它们放在重组缓冲区内，以便生成**完整的源数据映像**。
  - 缓冲的第三种用途是，支持应用程序I/O的复制语义。
    - 通过例子可以阐明“复制语义”的含义。假设应用程序**有一个数据缓冲区**，它希望写到磁盘。
    - 它调用系统调用write,提供缓冲区的指针和表示所写字节数量的整数。
    - 在系统调用返回后，如果应用程序**更改缓冲区的内容**，那么会发生什么？采用复制语义(copysemantics),写到磁盘的**数据版本**保证是应用程序系统调用时的版本，而与应用程序缓冲区的**任何后续更改无关**。
    - 操作系统保证复制语义的一种简单方式是，系统调用write在**返回到应用程序之前**，**复制应用程序缓冲区到内核缓冲区**。
    - **磁盘写入**通过内核缓冲区来执行，以便应用程序缓冲区的**后续更改没有影响**。
    - 内核缓冲区和应用程序数据空间的数据复制在操作系统中很常见，尽管由于干净语义，这个操作引入了这个操作引入了开销
    - 通过巧妙使用虚拟内存映射和写时复制页面保护，可以**更有效地得到同样的效果**。

  

### 缓存

- 缓存(cache)是保存**数据副本**的高速内存区域。
  - 访问缓存副本比访问原版更加有效。
    - 例如，正在运行进程的指令保存在磁盘上，缓存在物理内存上，并再次复制到CPU的次缓存和主缓存。
  - **缓冲和缓存的区别**是，缓冲可以保存数据项的**唯一的现有副本**，而根据定义**缓存只是提供了一个位于其他地方的数据项的更快存储副本**。
- 缓存和缓冲的**功能不同**，但是**有时一个内存区域可以用于两个目的**。
  - 例如，为了保留复制语义和有效调度磁盘I/O,操作系统**采用内存中的缓冲区来保存磁盘数据**、**这些缓冲区也用作缓存，以便提高文件的I/O效率**；
    - 这些文件可被多个程序共享，或者快速地写入和重读。
    - 当内核收到文件I/O请求时，内核**首先访问缓冲区缓存**，以便查看文件区域**是否已经在内存中可用**。
      - 如果是，可以避免或延退物理磁盘I/O。
      - 此外，磁盘写入在数秒内会累积到**缓冲缓存**，以汇集大量传输来允许高效写入调度。

## 缓冲区的结构



- 在现代操作系统中，几乎所有的I/O设备在与处理机交换数据时都用了缓冲区。
- 缓冲区是一个存储区域，它**可以**由**专门的硬件寄存器组成**，但由于硬件的成本较高，容量也较小，一般仅用在**对速度要求非常高的场合**，如存储器管理中所用的联想存储器；设备控制器中用的**数据缓冲区**等。
- 在一般情况下，**更多的是利用内存作为缓冲区**。

> 由**内存组成的缓冲区**

- 缓冲区管理的主要功能是**组织好这些缓冲区**，并提供获得和释放缓冲区的手段。

### 缓冲的引入

- 引入缓冲区的原因有很多，可归结为以下几点：
- (1)**缓和**CPU与I/O设备间**速度不匹配的矛盾**。
  - 事实上，凡在数据到达速率与其离去速率不同的地方，都可设置缓冲区，以缓和它们之间速率不匹配的矛盾。众所周知，CPU的运算速率远远高于I/O设备的速率，如果没有缓冲区，在输出数据时，必然会由于打印机的速度跟不上，而使CPU停下来等待：然而在计算阶段，打印机又空闲无事。
  - 如果在打印机或控制器中设置一缓冲区，用于快速暂存程序的输出数据，以后由打印机“慢慢地”从中取出数据打印，这样，就可提高CPU的工作效率。
  - 类似地，在输入设备与CPU之间设置缓冲区，也可使**CPU的工作效率得以提高**。
- (2)**减少**对CPU的**中断频率**，放宽对**CPU中断响应时间**的限制。
  - ![image-20220605095707488](https://img-blog.csdnimg.cn/img_convert/ccb68396ea2887239dcfac4cf213ef1e.png)
  - 在远程通信系统中，如果从远地终端发来的数据仅用一位缓冲来接收，则必须在每收到一位数据时便中断一次CPU
    - 这样，对于速率为9.6kb/s的数据通信$9.6kb/s\approx10kb/s=10^4b/(10^3ms)=10b/ms=10b/1000us=1b/100us$来说，就意味着其**中断CPU**的频率也为9.6kb/s,
    - 即每100us就要中断CPU一次，而且CPU**必须在100us内予以响应**，**否则缓冲区内的数据将被冲掉**。
  - 倘若设置一个具有**8位的缓冲(移位)寄存器**，则可使CPU被**中断的频率降低为原来的1/8**；
    - 缓冲所有位填满的时候发出中断,让cpu取走数据
    - 而cpu必须在下一个数据填充进来之前,完成响应,否则会丢失掉一个bit
    - 而使用第三种形态(两个8位缓冲寄存器,可以放宽中断响应时限的要求值8倍:
      - 当第一个缓冲寄存器满,发送一个中断请求,如果在下一个数据进入缓冲前,cpu未能完成响应,那么第二个8bit寄存器就排上用场,防止数据丢失,如果第二个寄存器的8位都用上可以放宽8倍的cpu中断响应时限)
  - 若再设置一个8位寄存器，则又可把CPU对**中断的响应时间**从100us放宽到800us。
    - 类似地，在磁盘控制器和磁带控制器中，都需要配置缓冲寄存器，以**减少对CPU的中断频率**，放宽对**CPU中断响应时间的限制**。随着<u>传输速率的提高，需要配置位数更多的寄存器进行缓冲</u>。
  - (3)解决**数据粒度**不匹配的问题。
    - 缓冲区可用于解决在生产者和消费者之间交换的数据粒度(数据单元大小)不匹配的问题。
    - 例如，生产者所生产的数据粒度比消费者消费的数据粒度小时，生产者进程可以一连生产好几个数据单元的数据，当其总和己达到消费者进程所要求的数据单元大小时，消费者便可从缓冲区中取出消费。反之，如果生产者所生产的数据粒度比消费者消费的数据粒度大时，生产者每次生产的数据消费者可以分几次从缓冲区中取出消费。
  - （4）提高CPU和I/O设备之间的**并行性**。
    - 缓冲区的引入可显著地提高CPU和I/O设备间的并行操作程度，提高系统的吞吐量和设备的利用率。
      - 例如，在CPU（生产者）和打印机（消费者）之间设置了缓冲区后，生产者在生产了一批数据并将它放入缓冲区后，**便可立即去进行下一次的生产**。
      - 与此同时，消费者可以从缓冲区中取出数据消费，这样便可使CPU与打印机处于并行工作状态。

#### 单缓冲区和双缓冲区

- 如果在生产者与消费者之间未设置任何缓冲，生产者与消费者之间在时间上会相互限制。
  - 例如，生产者已经完成了数据的生产，但消费者尚未准备好接收，生产者无法把所生产的数据交付给消费者，此时生产者必须暂停等待，直到消费者就绪。
  - 如果在生产者与消费者之间设置了一个缓冲区，则**生产者无需等待消费者就绪，便可把数据输出到缓冲区**。

##### 单缓冲区（SingleBuffer）

- 在单缓冲情况下，每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一缓冲区，
- ![image-20220605105643325](https://img-blog.csdnimg.cn/img_convert/8fcdf84dae210dd5e8afe82f489039f6.png)
  - 在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T(transform),
  - OS将该缓冲区中的数据传送到用户区的时间为M,
  - 而CPU对这一块数据处理（计算)的时间为C(calculation)。
- 由于**T和C是可以并行**的,(但是M和C&T中的任何一方都不可以并行,否则引起混乱)
  - 当T>C时，系统对每一块数据的处理时间为M+T；
  - 反之(T<C)则为M+C,
  - 故可把系统对每一块数据的处理时间表示为Max(C,T)+M。
- 在字符设备输入时，缓冲区用于暂存用户输入的一行数据，在输入期间，用户进程被挂起以等待数据输入完毕：在输出时，用户进程将一行数据输入到缓冲区后继续进行处理。
- 当用户进程已有第二行数据输出时，如果第一行数据尚未被提取完毕，则此时用户进程应阻塞。

##### 双缓冲区（DoubleBuffer）

![image-20220605122527387](https://img-blog.csdnimg.cn/img_convert/0cc8ad82234adf8b1756c4baa0af672b.png)

![](https://img-blog.csdnimg.cn/img_convert/4b1d67ab3b07a67779269d1fc042228c.png)

- 由于**缓冲区是共享资源**，生产者与消费者在使用缓冲区时**必须互斥**。

- 如果消费者尚未取走缓冲区中的数据，即使生产者又生产出新的数据，也无法将它送入缓冲区，生产者等待。

- 如果**为生产者与消费者设置了两个缓冲区**，便能解决这一问题。

  - (使得M操作和T操作可以并行执行)
  - 但是M操作和C操作还是不可以并行

- 为了**加快输入和输出速度**，**提高设备利用率**，人们又引入了**双缓冲区机制**，也称为**缓冲对换**(BufferSwapping)

- 在设备输入时，先将数据送入**第一缓冲区**，装满后便**转向第二缓冲区**。

- 此时操作系统可以**从第一缓冲区中移出数据**，并送入用户进程

- 接着由CPU对数据进行计算。

- 在**双缓冲**时，系统处理一块数据的时间可以**粗略地认为是Max(C+M,T).**

  - 如果C+M<T,可使块设备**连续输入**(处理速度高于数据输入的速度)；

  - 如果C+M>T,则可使CPU不必等待设备输入。(比如数据处理比较复杂,是耗时的密集计算,cpu对材料的消耗速度慢于供应速度)

  - > 总结:那个慢,那个就不需要等待对方
    >
    > 快的一方则要等待慢的一方

  - 对于字符设备，若采用行输入方式，则采用双缓冲通常能消除用户的等待时间(用户输入慢)，即用户在输入完第一行后，在CPU执行第一行中的命令时，用户可继续向第二缓冲区输入下一行数据。



##### 单工/双工通信

- 如果在实现两台机器之间的通信时仅为它们配置了单缓冲
  - ![](https://img-blog.csdnimg.cn/img_convert/e896f8fac046fa26bb3cf0af1aaa0f8b.png)
- 那么，它们之间在任一时刻都只能实现单方向的数据传输。
- 例如，只允许把数据从A传送到B,或者从B传送到A,而绝不允许双方同时向对方发送数据。
- 为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区，如图





## 非阻塞与异步I/O

### 阻塞I/O

- 系统调用接口的另一方面涉及选择阻塞I/O与非阻塞I/O。
- 当**应用程序**执行**阻塞(blocking)系统调用**时应用程序的执行就被挂起。
- 应用程序会从操作系统的运行队列移到等待队列。
- 当系统调用完成后，应用程序被移回到运行队列，符合恢复执行。
- 当它恢复执行时，它会收到系统调用的返回值。
- I/O设备执行的**物理动作常常是异步的**，执行时间也是**可变的或不可预计的**。
- 然而，大多数操作系统为应用程序接口采用阻塞系统调用，因为**阻塞应用代码比非阻塞应用代码更加容易理解**。

### 非阻塞I/O

- 有些用户级进程需要使用**非阻塞(nonblocking)I/O**。
  - 一个例子是用户接口，用来**接收键盘和鼠标输入，同时处理数据并显示到屏幕**。
  - 另一个例子是视频应用程序，用来从磁盘文件上读取帧，同时解压并显示输出到显示器。
  - 应用程序开发人员可以交叉**I/O与执行**的一种方法是,编写**多线程应用程序**。
  - 有些线程可以**执行阻塞系统调用，而其他线程继续执行**。
  - 有的操作系统**提供非阻塞I/O系统调用**。
    - 非阻塞调用不会很长时间停止应用程序的执行。
    - 相反，它会很快返回，其返回值表示已经传输了多少字节。

### 异步系统调用

- 非阻塞系统调用的一种**替代方法是异步系统调用**。

- 异步调用立即返回，无需等待I/O完成,应用程序继续执行代码。

- 在**将来I/O完成**时，有以下方式来**通知应用程序**

  - **通过设置应用程序地址空间内的某个变址**，
  - 或通过**触发信号或软件中断**
  - 或**在线性控制流之外执行的回调函数**，。

- 非阻塞与异步的系统调用的**区别**是，

  - 非阻塞调用read()立即返回任何可用的数据，读取的数据等于或少于请求的字节数，或为零。
  - 异步调用read()要求的传输会完整执行，但是**完成是在将来的某个特定时间**。

- One way an application writer can overlap execution with I/O is to writea multithreaded application. 

- Some threads can perform blocking system calls,while others continue executing. 

- Some operating systems **provide nonblocking I/O system calls.** 

- A nonblocking call does not halt the execution of the application for an extended time. 

  - Instead, it returns quickly, with a return value thatindicates how many bytes were transferred.

- An alternative to a nonblocking system call is an asynchronous systemcall. 

  - An asynchronous call returns immediately, without waiting for the I/O to complete. 
  - The application continues to execute its code. 
  - The completion of the I/O at some future time is communicated to the application, 
    - either through the setting of some variable in the address space of the application
    - or through the triggering of a signal 
    - or software interrupt 
    - or a call-back routine that is executed outside the linear control ﬂow of the application. 
  - Thedifference between nonblocking and asynchronous system calls is that a nonblocking read() returns immediately with whatever data are available—the full number of bytes requested, fewer, or none at all. 
  - An asynchronous read() call requests a transfer that will be performed in its entirety but will complete
    at some future time. 

- ![](https://img-blog.csdnimg.cn/img_convert/ece4d970b1a4a3dd8892995ffc2610af.png)]

- ![image-20220605112857127](https://img-blog.csdnimg.cn/img_convert/8b592511ba7410192d745f4b3526d849.png)

  

- 在现代操作系统中，经常发生异步活动。

  - 通常，它们不会暴露给用户或应用程序，而是包含在操作系统操作中。
    - 例如，磁盘和网络I/O。
  - 在默认情况下，当应用程序发出网络发送请求或磁盘写入请求时，操作系统**记住请求**，缓冲I/O,并**返回到应用程序**。如有可能，为了优化整体系统性能，操作系统完成请求。
  - 如果临时发生系统故障，则应用程序会丢失任何途中请求。
  - 因此，**操作系统通常限制缓冲请求的时间**。
    - 例如，有些版本的UNIX每隔30秒**刷新磁盘缓冲区**，每个请求**在30秒内会被刷新**。
    - **应用程序内的数据**一致性由**内核维护**，内核在发出I/O请求到设备之前读取数据，确保**尚未写入数据**返回给请求读者。
  - 注意，多个线程对同一文件执行I/O可能不会收到**一致的数据**，它取决于内核如何实现I/O。在这种情况下，线程可能需要使用加锁协议。
  - 有些I/O请求需要**立即执行**，这样I/O系统调用通常提供方法，以便指定特定设备的给定请求或I/O应当**同步执行。**

- 非阻塞行为的一个很好的例子是，用于**网络套接字的系统调用select**。

  - 这个系统调用需要一个参数来**指定最大等待时间**。

  - 通过设置为0,应用程序可以**轮流检测网络活动而无需阻塞**。
  - 但是采用select引入额外的开销，因为调用select只检查是否可能进行I/O.
  - 对于数据传输，在select()之后，还需要采用某种类型的命令read或write。
  - 在Mach中，有这种方法的变种，即阻塞**多读调用**。
  - 通过这**一系统调用可以对多个设备指定所需的读取**，而且**只要一个完成就可返回**。
