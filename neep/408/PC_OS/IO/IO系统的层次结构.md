@[toc]

# OS_I/O系统的层次结构

## I/O系统总览🎈

### I/O系统的层次结构



- 用户层软件

  - 产生I/O请求、格式化IVO、Spooling

- 设备独立性软件

  - 映射、保护、分块、缓冲、分配

- 设备驱动程序

  - 设置设备寄存器：检查状态

- 中断处理程序

- 硬件

  - 执行I/O操作

  

### I/O系统中各个模块之间的层次

![image-20220604140624855](https://img-blog.csdnimg.cn/img_convert/a9285ec29e7925e99ff2d1b583c9a335.png)

- 用户层软件
  - I/O系统接口


- 设备独立性(无关性)软件

- 设备驱动程序

- 中断处理程序
  - RW/HW接口


- 设备控制器

- 在上、下两个接口之间是I/O系统

### I/O系统的上、下接口

#### (1)I/O系统接口

- 它是**I/O系统与上层系统之间的接口**，向**上层提供对设备进行操作的抽象I/O命令**，以方便高层对设备的使用。

- 有不少OS在用户层提供了与I/O操作有关的库函数，供用户使用。

- 在**上层**系统中有**文件系统、虚拟存储器系统以及用户进程**等。

- 包括:

  - 块设备接口
  - 流设备接口

  - 网络通信接口

#### (2)软件/硬件(RW/HW)接口

- 该接口是**软件/硬件接口**，在它的上面是**中断处理程序**和用于不同设备的**设备驱动程序**。

- 在它的**下面是各种设备的控制器**。

  - 如CD-ROM控制器、硬盘控制器、键盘控制器、打印机控制器、网络控制器等，它们都属于硬件。

  - 由于设备种类繁多，故该接口相当复杂。

    

### I/O系统的分层 

- 与前面所述的**I/O软件组织**的**层次结构**相对应，**I/O系统本身**也可分为如下三个层次：

- (1)中断处理程序。

  - 它处于I/O系统的底层，直接与硬件进行交互。当有I/O设备发来中断**请求信号**时，在<u>中断硬件</u>做了初步处理后，便**转向中断处理程序**。
  - 它首先**保存被中断进程的CPU环境**，然后**转入相应设备的中断处理程序进行处理**，在处理完成后，又**恢复**被中断进程的CPU环境，**返回断点继续运行**。

- (2)设备驱动程序。

  - 它处于I/O系统的**次底层**，是进程和设备控制器之间的**通信程序**，其主要功能是，
    - 将上层发来的抽象I/O请求转换为对I/O设备的**具体命令和参数**，并把它装入到设备控制器中的命令和参数寄存器中，或者相反。
  - 由于设备之间的差异很大，每类设备的驱动程序都不相同，故必须由设**备制造厂商提供，而不是由OS设计者来设计**。
  - 因此，每当在系统中增加一个新设备时，**都需要由安装厂商提供新的驱动程序。**

- (3)设备独立性软件。

  - 现代OS中的**I/O系统**基本上都实现了与**设备无关性**，也称为**与设备无关的软件**。
  - 其基本含义是：<u>I/O软件</u>**独立于**<u>具体使用的物理设备</u>。

  - 由此带来的最大好处是，提高了I/O系统的**可适应性和可扩展性**。
  - 使它们能应用于许多类型的设备，而且在每次增加新设备或替换老设备时，**都不需要对I/O软件进行修改**，这样就**方便了系统的更新和扩展**。
  - **设备独立性软件**的**内容**包括**设备命名、设备分配、数据缓冲和数据高速缓冲一类软件**等。



# IO软件层次

## 与设备无关的IO软件🎈

- 为了方便用户和提高OS的可适应性与可扩展性，在现代OS的I/O系统中，都无一例外地增加了与设备无关的I/O软件，以实现设备独立性，也称为设备无关性。
  - 其基本含义是：**应用程序中所用的**设备，不局限于使用某个具体的物理设备。
  - 为每个设备所配置的设备驱动程序是与硬件紧密相关的软件。
  - 为了实现设备独立性，必须**再在设备驱动程序之上设置一层软件，称为与设备无关的I/O软件**，或设备独立性软件。

- 与设备无关软件的功能层次
  - 设备驱动程序的统一接口
  - 缓冲
  - 错误报告
  - 分配与释放专用设备
  - 提供与设备无关的块大小


#### 以物理设备名使用设备

- 在早期OS中，应用程序在使用I/O设备时，都使用设备的物理名称，这使应用程序与系统中的物理设备直接相关。

- 当应用进程运行时，如果所请求的物理设备（独占设备类型）己分配给其它进程，而此时尽管还有几台其它的相同设备空闲可用，但**系统只能根据设备的物理名来分配**，无法将另外相同的设备（但具有不同的物理设备名）分配给它，致使该应用进程请求I/O失败而被阻塞。

- 特别是，当应用程序所需要的**设备在系统中已经被更新**时，<u>*该应用程序*</u>将**再也无法在该系统上运行**。

- > 可见，应用程序直接与物理设备相关是**非常不灵活**的，给用户带来了很大的不便，且对提高I/O设备的利用率也很不利。

#### 引入了逻辑设备名

- 为了实现与设备的无关性而引入了逻辑设备和物理设备两个概念。
- 逻辑设备是抽象的设备名。
  - 如/dev/printer,该设备名只是说明用户需要使用打印机来打印输出，但并没有指定具体是哪一台打印机。
  - 这样，如果在应用程序中，使用逻辑设备名称请求使用某类设备，系统在对它进行设备分配时，先查找该类设备中的第一台，如它已被分配，系统可立即去查找该类设备中第二台，若又被分配，系统接着去找第三台，若它尚未分配，便可将这台设备分配给进程。
  - 事实上，只要系统中有一台该类设备未被分配，进程就不会被阻塞。
  - 仅当所请求的**此类**设备己全部分配完毕时，进程才会因请求失败而阻塞。
  - 所以，应用进程就**不会由于某台指定设备退役而无法在本系统上运行**。
- 与设备的无关软件还可实现I/O重定向。
  - 所谓I/O重定向，是指用于I/O操作的**设备可以更换**（即重定向），而**不必改变应用程序**。
    - 例如，我们在调试一个应用程序时，可将程序的所有输出送往屏幕显示。
    - 而在程序调试完后，若须正式将程序的运行结果打印出来，此时便须将I/O重定向的数据结构——逻辑设备表中的**显示终端改为打印机**即可，而不必修改应用程序。
    - I/O重定向功能具有**很大的实用价值**，现已被广泛地引入到各类OS中。

#### 逻辑设备名称到物理设备名称的转换

- 在应用程序中，用逻辑设备名称使用设备虽然方便了用户，但**系统却只识别物理设备名称**，因此在实际执行时，还必须使用物理名称。
- 为此，在系统中，必须具有将逻辑设备名称转换为某物理设备名称的功能。
- 关于逻辑设备名称和物理设备名称的概念，与存储器管理中所介绍的逻辑地址和物理地址的概念非常类似，在应用程序中所使用的是逻辑地址，而系统在分配和使用内存时，必须使用物理地址。
- 在程序执行时，必须先将逻辑地址转换为物理地址。
  - 类似地，为实现从逻辑设备名称和物理设备名称，在系统中需要配置一张**逻辑设备表**。

## 与设备无关的软件🎈

- **与设备无关的软件是I/O系统的最高层软件**，在它下面的是设备驱动程序，其间的界限，因操作系统和设备的不同而有所差异。
  - 比如，对于一些本应由设备独立性软件实现的功能，却放在设备驱动程序中实现。这样的差异主要是出于对操作系统、设备独立性和设备驱动程序运行效率等多方面因素的权衡和考虑。
- 总的来说，在**与设备无关的软件**中，包括了<u>执行**所有设备公有操作**</u>的**软件**，具体有如下几项。
  - 1.设备驱动程序的统一接口
    - 为了使所有的设备驱动程序有着统一的接口，一方面，要求每个设备驱动程序与OS之间都有着相同的接口，或者相近的接口，这样会使添加一个新的设备驱动程序变得很容易，同时在很大程度上方便了开发人员对设备驱动程序的编制。
    - 另一方面，要将抽象的设备名映射到适当的驱动程序上，或者说，将抽象的设备名转换为具体的物理设备名，并进一步可以找到相应物理设备的驱动程序入口。
    - 此外，还应对设备进行保护，禁止用户直接访问设备，以防止无权访问的用户使用。
  - 2.缓冲管理
    - 无论是字符设备还是块设备，它们的运行速度都远低于CPU的速度。
    - 为了缓和CPU和I/O设备之间的矛盾、提高CPU的利用率，在现代OS中都无一例外地分别为字符设备和块设备配置了相应的缓冲区。
    - 缓冲区有着多种形式，如**单缓冲区、双缓冲区、循环缓冲区、公用缓冲池**等，以满足不同情况的需要。
  - 3.差错控制
    - 由于设备中有着许多的**机械和电气部分**，因此，它们比主机更容易出现故障，这就导致I/O操作中的绝大多数错误都与设备有关。
    - 错误可分为如下两类：
      - (1)暂时性错误。暂时性错误是因发生暂时性事件引起的，如电源的波动。它可以通过重试操作来纠正。
        - 例如，在网络传输中，由于传输路途较远、缓冲区数量暂时不足等因素，会经常发生在网络中传输的数据包丢失或延误性的暂时性错误。
        - 当网络传输软件检测到这种情况后，可以通过重新传送来纠正错误。
        - 又如，当磁盘传送发生错误后，开始驱动程序并不立即认为传送出错，而是令磁盘重传，只有连续多次(如10次)出错，才认为磁盘出错，并向上层报告。
        - 一般地，设备出现故障后，主要由设备驱动程序处理，而设备独立性软件只处理那些设备驱动程序无法处理的错误。
      - (2)持久性错误。
        - 持久性错误是由持久性故障引起的，如电源掉电、磁盘上有一条划痕或者在计算中发生除以零的情况等。
        - 持久性错误容易发现，有些错误是只要重复执行相同的程序就会再现的错误。
        - 要排除持久性错误，通常需要查清发生错误的原因。
        - 但也有某些持久性硬件错误可由操作系统进行有效的处理，而不用涉及高层软件。如磁盘上的少数盘块遭到破坏而失效，此时无需更换磁盘，而只需**将它们作为坏的盘块记录下来**，并放入一张**坏盘块表**中，以后**不再使用这些坏块**即可。
  - 4.对独立设备的分配与回收
    - 在系统中有两类设备：独占设备和共享设备。
    - 对于**独占设备，为了避免诸进程对独占设备的争夺，必须由系统来统一分配**，不允许进程自行使用。
    - 每当进程需要使用某(独占)设备时，**必须先提出申请**。
    - OS接到对设备的请求后，先对进程所请求的**独占设备进行检查**，看该设备是否空闲。
      - 若空闲，才把该设备分配给请求进程。
      - 否则，进程将被阻塞，放入该设备的请求队列中等待。等到其它进程释放该设备时，再将队列中的第一个进程唤醒，该进程得到设备后继续运行。
  - 5.独立于设备的逻辑数据块
    - 不同类型的设备，其数据交换单位是不同的，读取和传输速率也各不相同，如字符型设备以单个字符(字)为单位，块设备是以一个数据块为单位。
    - 即使同一类型的设备，其数据交换单位的大小也是有差异的,如不同磁盘由于扇区大小的不同，可能造成数据块大小的不一致。
    - 设备独立性软件应能够**隐藏这些差异而被逻辑设备使用**，并**向高层软件提供大小统一的逻辑数据块**。与设备无关软件的功能

### 设备分配

- 系统为实现对独占设备的分配，必须在系统中配置相应的数据结构。

#### 1.设备分配中的数据结构

- 在用于设备分配的数据结构中，记录了对**设备或控制器进行控制所需的信息**。
- 在进行设备分配时需要如下的数据结构。

##### 1)设备控制表DCT

- 系统为**每一个设备**都配置了一张**设备控制表**，用于记录设备的情况，
- ![image-20220605150612177](https://s2.loli.net/2022/06/05/ObHq6IpzrcDlZJW.png)
- 其中,设备控制器表对应一个设备控制器,(因此,在后面提到的分配控制器的步骤中),可以从DCT中找出该设备连接的控制器的COCT

- 设备控制表中，除了有用于指示设备类型的字段type和设备标识字段deviceid外，
- 还应含有下列字段：
  - (1)设备队列队首指针，凡因请求本设备而未得到满足的进程，应将其**PCB**按照一定的策略排成一个**设备请求队列**，其**队首指针指向队首PCB**；
  - (2)忙/闲标志，用于表示当前设备的状态是忙或闲：
  - (3)与设备连接的控制器表指针，该指针指向该设备所连接的控制器的控制表；
  - (4)重复执行次数，由于外部设备在传送数据时较易发生数据传送错误，因而在许多系统中**规定了设备在工作中发生错误时应重复执行的次数**，在重复执行时，若能恢复正常传送，则仍认为传送成功，仅当重复执行次数达到规定值仍不成功时，才认为传送失败。

##### 2)控制器控制表、通道控制表和系统设备表

###### (1)控制器控制表(COCT)

- 系统为**每一个控制器**都设置了**用于记录控制器情况**的控制器控制表，
- ![image-20220605150850385](https://s2.loli.net/2022/06/05/btGpyBe5qOjnQlJ.png)。

###### (2)通道控制表(CHCT)

- 每个通道都有一张通道控制表。
- ![image-20220605150928879](https://s2.loli.net/2022/06/05/8R3WGFtxIPJjYk7.png)

###### (3)系统设备表(SDT)

- 这是系统范围的数据结构，记录了**系统中全部设备的情况**，每个设备占一个表目，其中包括有设备类型、设备标识符、设备控制表及设备驱动程序的入口等项，
- ![image-20220605150946988](https://s2.loli.net/2022/06/05/wMKSyJDf8ktlABj.png)

#### 2.设备分配时应考虑的因素

- 系统在分配设备时，应考虑如下几个因素：
- 1)设备的固有属性
  - (1)独占设备的分配策略。将一个设备分配给某进程后，便由该进程独占，直至该进程完成或释放该设备。
  - (2)共享设备的分配策略。对于共享设备，可**同时分配给多个进程使用**，此时须注意**对这些进程访问该设备的先后次序进行合理的调度**。
  - (3)**虚拟设备**的分配策略，虚拟设备属于**可共享的设备**，可以将它**同时分配给多个进程使用**。
- 2)**设备分配算法**对设备分配的算法，通常只采用以下**两种分配算法**：
  - (1)先来先服务。该算法是根据诸进程对某设备提出请求的先后次序，将这些进程排成一个设备请求队列，设备分配程序总是把设备首先分配给队首进程。
  - (2)优先级高者优先。在利用该算法形成设备队列时，将优先级高的进程排在设备队列前面，而对于优先级相同的I/O请求，则按先来先服务原则排队。
- 3)设备分配中的**安全性**
  - 从进程运行的安全性上考虑，设备分配有以下两种方式：
    - (1)安全分配方式。
      - 每当进程发出I/O请求后，**便进入阻塞状态**，直到其I/O操作完成时才被唤醒。
      - 在采用该策略时，一旦进程已经**获得某种设备后便阻塞**，不能再请求任何资源，而**在它阻塞时又不保持任何资源**。
      - 因此，摒**弃了造成死锁的四个必要条件之一的“请求和保持"条件**，故设备**分配是安全的**。其缺点是CPU与I/O设备是**顺序工作**的。
    - (2)不安全分配方式。
      - 在这种分配方式中，进程在发出I/O请求后仍继续运行，需要时又发出第二个I/O请求、第三个I/O请求等。
      - 仅当进程所请求的设备已**被另一进程占用时,才进入阻塞状态**。
      - 该策略的优点是，一个**进程可同时操作多个设备，使进程推进迅速**。
      - 其缺点是分配不安全，因为它可能具备“请求和保持”条件，从而可能造成死锁。
      - 因此，在设备分配程序中，应对本次的设备分配**是否会发生死锁进行安全性计算**，仅当计算结果说明分配是安全的情况下，才进行设备分配。

#### 3.独占设备的分配程序

- 1)基本的设备分配程序

  - 我们通过一个例子来介绍设备分配过程。当某进程提出I/O请求后，系统的设备分配程序可按下述步骤进行设备分配：

    - (1)分配**设备**。
      - 首先<u>根据I/O请求中的**物理设备名**</u>**查找系统设备表SDT**,从中**找出该设备的DCT,**
      - 再根据DCT中的设备状态字段，可知该**设备是否正忙**。
        - 若忙，便将请求I/O的进程的**PCB挂在设备队列上**;
        - 否则，便按照一定的算法，**计算本次设备分配的安全性**。
          - 如果不会导致系统进入不安全状态，便将设备分配给请求进程；
          - 否则，仍将其PCB插入设备等待队列。
          - ```mermaid
            graph LR
            A(SDT系统设备表) --查找-->B([DCT设备控制表])
            B --"设备状态(status)"--- C{busy?}
            D(挂到PCB任务队列)
            E[计算本次分配安全性]
            C -->|yes|D 
            C -->|no|E
            F(执行分配)
            G{save?}
            E-->G
            G-->|yes|F
            G-->|No|D

  - (2)分配**控制器**。

    - 在系统把设备分配给请求I/O的进程后，
    - 再到其**DCT中找出与该设备连接的控制器的COCT**,
    - 从**COCT的状态字段**中可知该控制器是否忙碌。

      - 若忙，便将请求I/O进程的**PCB,挂在该控制器的等待队列上**。
      - 否则，便将该控制器分配给进程。

        - ```mermaid
          graph LR
              A(系统将设备分配给进程) --在DCT中查找与设备连接的控制器-->B([COCT])
              B --"控制器状态(status)"--> is_busy{busy?}
              busy_no(挂到PCB任务队列)
              busy_yes[将控制器分配给进程]
              append_controller(挂到该控制器的等待队列)
              is_busy -->|yes|append_controller 
              is_busy -->|no|busy_no
          ```
        - 
  - (3)分配**通道**。

    - 在**该COCT中**又可找到**与该控制器连接的通道的CHCT**,

    - 再根据**CHCT内的状态信息**可知该**通道是否忙碌**。

      - 若忙，便将请求I/O的进程挂在该**通道的等待队列**上；
      - 否则，将该**通道分配给进程**。

    - ```mermaid
      graph LR
         assigned_controller(系统将控制器分配给进程)
         check_chct(查找控制器对应的通道)
         is_chct_busy{busy?}
         chct_busy(挂到该通道的等待队列)
         chct_free(将通道分配给进程)
         assigned_controller-->check_chct--检查CHCT状态字段-->is_chct_busy-->|yes|chct_busy
         is_chct_busy-->|no|chct_free
      ```

  ```mermaid
  flowchart LR
      subgraph  s1 [step1]
          direction TB
      check_SDT(SDT系统设备表)--find-->dct["DCT设备控制表by指针"]
      dct --"设备状态(status)"--- is_busy_device{busy?}
      append_device(挂到PCB任务队列)
      safety[计算本次分配安全性]
      is_busy_device -->|yes|append_device
      is_busy_device -->|no|safety
      is_safe{safe?}
      safety-->is_safe
      is_safe-->|yes|assign_device(执行分配step2)
      is_safe-->|No|append_device
      end
  
      %%assign_device
      subgraph s2 [step2]
          direction TB
      dct2(DCT设备控制表) --在DCT中查找与设备连接的控制器-->coct([COCT])
      coct --"控制器状态(status)"--> is_busy_controller{busy?}
      append_controller(挂到该控制器的等待队列)
      is_busy_controller -->|yes|append_controller 
      is_busy_controller -->|no|assign_controller(执行分配step3)
      end
    
  
  
      subgraph s3 [step3]
          direction TB
  
      %%use the square bracket `[]` to name the group(subgraph) to be connect with other part of the flowchart
      coct2(COCT控制器控制表)--查找-->chct(CHCT)
      is_chct_busy{busy?}
      append_chct(挂到该通道的等待队列)
      assign_chct(将通道分配给进程)
      chct--检查CHCT状态字段-->is_chct_busy-->|yes|append_chct
      is_chct_busy-->|no|assign_chct
      end
      s1-->s2-->s3
  ```

  

> - 只有在设备、控制器和通道三者都分配成功时，这次的设备分配才算成功。
> - 然后，便可启动该I/O设备进行数据传送。

- 2)设备分配程序的改进

  - 在上面的例子中，进程是以物理设备名提出I/O请求的。
  - 如果所指定的设备己分配给其它进程，则分配失败。
  - 或者说上面的设备分配程序不具有与设备无关性。为获得设备的独立性，进程应使用逻辑设备名请求I/O。这样，系统首先从SDT中找出第一个该类设备的DCT。若该设备忙，又查找第二个该类设备的DCT,仅当所有该类设备都忙时，才把进程挂在该类设备的等待队列上。而只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。如安全，便可把设备分配给它。

### 逻辑设备名到物理设备名映射的实现

- 为了实现与设备的无关性，当应用程序请求使用I/O设备时，应当用逻辑设备名。
- 但系统只识别物理设备名，因此在系统中需要配置一张**逻辑设备表**，用于将逻辑设备名**映射为物理设备名**。

#### 逻辑设备表LUT(LogicalUnitTable)

- 在逻辑设备表的每个表目中包含了三项：
  - 逻辑设备名、物理设备名和设备驱动程序的**入口地址**
  - ![image-20220605190553131](https://s2.loli.net/2022/06/05/GFVvupa1XBbcNDy.png)
  - 当进程用逻辑设备名请求分配I/O设备时，系统根据当时的具体情况，为它分配一台相应的物理设备。
  - 与此同时，在逻辑设备表上**建立一个表目**，填上应用程序中使用的逻辑设备名和系统分配的物理设备名，以及该设备驱动程序的入口地址。
  - 当以后进程再利用该逻辑设备名请求I/O操作时，**系统通过查找LUT**,便可找到该逻辑设备所对应的物理设备和该设备的驱动程序。

#### 逻辑设备表的设置问题

- 在系统中可采取两种方式设置逻辑设备表：
  - ![image-20220605190734249](https://s2.loli.net/2022/06/05/Sj9IxuA7FaKWDHw.png)
  - 第一种方式，是在整个系统中只设置一张LUT。
    - 由于系统中所有进程的设备分配情况都记录在同一张LUT中，因而不允许在LUT中具有相同的逻辑设备名，这就要求所有用户都不使用相同的逻辑设备名。
    - 在多用户环境下这通常是难以做到的，因而这种方式主要用于**单用户系统**中。
  - 第二种方式，是为每个用户设置一张LUT,
    - 每当用户登录时，系统便为该用户**建立一个进程**，**同时也为之建立一张LUT,**并将该表放入**进程的PCB**中。
    - 由于通常在多用户系统中都配置了系统设备表，故此时的逻辑设备表可以采用上图格式。





## 设备驱动程序🎈

- 设备处理程序通常又称为设备驱动程序，它是I/O系统的高层与设备控制器之间的通信程序，其主要任务是**接收上层软件发来的抽象I/O要求**，
  - 如read或write命令，再把它**转换为具体要求后**，发送给设备控制器，启动设备去执行：
- 反之，它也将**由设备控制器发来的信号传送给<u>上层软件</u>**。
- 由于驱动程序与硬件密切相关，故通常应为**每一类设备配置一种驱动程序**。
  - 例如，打印机和显示器需要不同的驱动程序。

#### 设备驱动程序的功能

- 为了实现I/O系统的**高层与设备控制器**之间的通信，设备驱动程序应具有以下功能：
  - (I)接收由**与设备无关的软件**发来的命令和参数，并将**命令中的抽象要求转换为与设备相关的低层操作序列。**
  - (2)检查用户I/O请求的**合法性**，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式。
  - (3)发出I/O命令，
    - 如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；
    - 如果设备忙碌，则将请求者的请求块挂在设备队列上等待
  - (4)**及时响应**由设备控制器发来的**中断请求**，并根据其中断类型，**调用相应的中断处理程序进行处理**。

#### 设备驱动程序的特点

- 设备驱动程序属于**低级的系统例程**，它与一般的应用程序及系统程序之间有下述明显差异：
- (1)驱动程序是实现在与设备无关的软件和设备控制器之间通信和**转换的程序**，具体说，
  - 它将抽象的I/O请求转换成具体的I/O操作后传送给控制器。
  - 又把控制器中所记录的设备状态和I/O操作完成情况，及时地反映给请求I/O的进程。
- (2)驱动程序与设备控制器以及I/O设备的硬件特性紧密相关，对于不同类型的设备，应配置不同的驱动程序。但可以为相同的多个终端设置一个终端驱动程序。
- (3)驱动程序与I/O设备所采用的I/O控制方式紧密相关，常用的I/O控制方式是中断驱动和DMA方式。
- (4)由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写。目前有很多驱动程序的基本部分已经固化在ROM中。
- (5)驱动程序应允许可重入。一个正在运行的驱动程序常会在一次调用完成前被再次调用。

### 设备处理方式

在不同的操作系统中，所采用的设备处理方式并不完全相同。根据在设备处理时是否设置进程，以及设置什么样的进程，而把设备处理方式分成以下三类：

- (1)为每一类设备设置一个**进程**，专门用于执行这类设备的I/O操作。
  - 比如，为所有的交互式终端设置一个交互式终端进程；
  - 又如，为同一类型的打印机设置一个打印进程。这种方式比较适合于较大的系统。
- (2)在**整个系统**中设置一个**I/O进程**，专门用于**执行系统中所有各类设备的I/O操作**。也可以设置一个输入进程和一个输出进程，分别处理系统中的**输入或输出操作。**
- (3)不设置专门的**设备处理进程**，而只为各类设备**设置相应的设备驱动程序**，供用户或系统进程调用。
  - 这种方式目前用得较多。

#### 设备驱动程序的处理过程

- 设备驱动程序的主要任务是启动指定设备，完成上层指定的I/O工作。
- 但在启动之前，应先完成必要的准备工作，如检测设备状态是否为“忙”等。
- 在完成所有的准备工作后，才向设备控制器发送一条启动命令。
- 以下是设备驱动程序的处理过程：
  - (1)将抽象要求转换为具体要求。
    - 通常在每个**设备控制器**中都含有若干个**寄存器**，分别用于暂存**命令、参数和数据**等。
    - 由于用户及上层软件对设备控制器的具体情况毫无了解，因而**只能发出命令**(抽象的要求)，这些命令是无法传送给设备控制器的。
    - 因此，就需要将这些**抽象要求转换为具体要求**。
      - 例如，将抽象要求中的**盘块号**转换为**磁盘的盘面、磁道号及扇区**。
    - 而这一转换工作**只能由驱动程序来完成**，因为在OS中**只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况**，也只有**它才知道命令、数据和参数应分别送往哪个寄存器**。
  - (2)对服务请求进行校验。
    - 驱动程序在启动I/O设备之前，必须先检查该用户的I/O请求是不是该设备能够执行的。
      - 一个非法请求的典型例子是，用户试图请求从一台打印机**读**入数据。
      - 如果驱动程序能检查出这类错误便认为这次I/O请求非法，它将向I/O系统报告I/O请求出错。
      - I/O系统可以根据具体情况做出不同的决定。
      - 如可以停止请求进程的运行，或者仅通知请求进程它的I/O请求有错，但仍然让它继续运行。
      - 此外，还有些设备如磁盘和终端，它们虽然都是既可读、又可写的，但若在打开这些设备时规定的是读，则用户的写请求必然被拒绝。
  - (3)检查设备的状态。
    - 启动某个设备进行I/O操作，其前提条件应是该**设备正处于就绪状态**。
      - 为此，在每个设备控制器中，都配置有一个状态寄存器。
      - 驱动程序在启动设备之前，要先把状态寄存器中的内容读入到CPU的某个寄存器中，**通过测试寄存器中的不同位，来了解设备的状态**，
        - 例如，为了向某设备写入数据，此前应先检查状态寄存器中接收就绪的状态位，看它是否处于接收就绪状态。
        - 仅当它处于接收就绪状态时，才能启动其设备控制器，否则只能等待。
  - (4)传送必要的参数。
    - 在确定设备处于接收(发送)就绪状态后，便可向控制器的相应寄存器传送数据及与控制本次数据传输有关的参数。
      - 例如，在某种设备控制器中配置了**两个控制寄存器**，
      - 其中一个是**命令寄存器**，用于**存放处理机发来的各种控制命令，以决定本次I/O操作是接收数据还是发送数据等。**
      - 另一个是**方式寄存器**，它用于控制本次传送数据的速率、发送的字符长度等。
      - 如果是利用RS232C接口进行异步通信，在启动该接口之前，应先按通信规程设定下述参数：波特率、奇偶校验方式、停止位数目及数据字节长度等。
      - 对于较为复杂的块设备，除必须向其控制器发出启动命令外，还需传送更多的参数。
  - (5)启动I/O设备。
    - 在完成上述各项准备工作后，驱动程序便可以向控制器中的命令寄存器传送相应的控制命令。
    - 对于字符设备，若发出的是写命令，驱动程序便把一个字符(或字)，传送给控制器：
    - 若发出的是读命令，则驱动程序等待接收数据，并通过读入控制器的状态寄存器中状态字的方法来确定数据是否到达。
    - 在多道程序系统中，**驱动程序**一旦发出IO命令，启动了一个I/O操作后，<u>驱动程序便把控制返回给I/O系统</u>，**把自己阻塞起**来，**直到中断到来时再被唤醒**。
      - 具体的I/O操作是在**设备控制器**的控制下进行的，
      - 因此，在设备忙于**传送数据时**，处理机又可以去干其它的事情，实现了**处理机与I/O设备的并行操作**。







