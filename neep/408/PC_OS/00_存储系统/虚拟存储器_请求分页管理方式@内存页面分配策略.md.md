[toc]

## 请求分页系统

- **请求分页系统**([Demand paging](https://en.wikipedia.org/wiki/Demand_paging)) 建立在**基本分页系统**([memory paging](https://en.wikipedia.org/wiki/Memory_paging))基础之上
  - 为了<u>支持虚拟存储器功能</u>而增加了
  - **请求调页功能**
  - **页面置换功能**
- 请求分页是**目前最常用的**一种<u>实现虚拟存储器</u>的方法 🎈
- 在请求分页系统中
  - 只要求将当前需要的一部分页面装入内存，便可以启动作业运行 
  - 在作业执行过程中，当所要访问的页面不在内存中时，再通过调页功能将其调入，同时还可通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间 
- 为了实现请求分页，系统必须提供一定的**硬件支持** 
- 除了需要一定容量的内存及外存的计算机系统，还需要有
  - 页表机制
  - 缺页中断机构
  - 地址变换机构



### 页表机制

- 请求分页系统的页表机制不同于基本分页系统，请求分页系统在一个作业运行之前不要求全部一次性调入内存

- 因此在作业的运行过程中，必然会出现要访问的页面不在内存中的情况，

- 如何发现和处理这种情况是**请求分页系统**必须解决的两个基本问题 

  - 为此，在请求页表项中增加了4个字段

  - 请求分页系统中的页表项

    - 页号
    - 物理块号
    - 状态位P
    - 访问字段A
    - 修改位M
    - 外存地址O

  - 增加的4个字段说明如下:(了解完置换算法后再来学习这部分)

    - 状态位P(有效位)
      - 调入状态,用于指示该页是否已调入内存，供程序访问时参考 
    - 访问字段A(引用位)
      - 描述被访问或者被引用的情况
      - 访问计数(时)器:用于记录
        - 本页在一段时间内**被访问的次数**，
        - 或记录本页最近已有多长时间未被访问，
      - <u>供置换算法(替换策略)</u>换出页面时参考 (比如LRU算法用到计数器)
      
    - 修改位M(脏位)
      - 即,脏位,标识该页在调入内存后**是否被修改过**，以确定页面置换时是否写回外存 (回写策略)
    - 外存地址O
      - 用于指出该页**在外存上的地址**，通常是**物理块号**，供调入该页时参考 

### 缺页中断机构

- 在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存 此时应将缺页的进程阻塞（调页完成唤醒)，
  - 若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，
  - 若此时内存中没有空闲块，则要淘汰某页
    - 若被淘汰页在内存期间被修改过，则要将其写回外存) 
  - 缺页中断作为中断，同样要经历诸如保护CPU环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境等几个步骤 
    - 但与一般的中断相比，它有以下两个明显的区别:
      - 在**指令执行期间**而非一条指令执行完后**产生和处理中断信号**，属于**内部异常**
      -  一条指令在**执行期间**，可能**产生多次缺页中断** 

### 地址变换机构

- 请求分页系统中的地址变换机构，是在**分页系统地址变换机构的基础上**，为实现虚拟内存，又**增加了某些功能**而形成的
  - 如产生和处理缺页中断，
  - 从内存中换出一页的功能
  - ...
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/35f1de328eab4f0db2d3b79e5ac74c4b.png)

[toc]

# 页框分配

## 驻留集

- 对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把一个进程的所有页都读入主存。
- 因此，操作系统必须决定**读取多少页**，即决定给特定的进程分配几个页框。
- 给一个进程分配的**物理页框的集合**就是这个**进程的驻留集**🎈
  - 需要考虑以下几点：
  - 1)分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高CPU的利用率。
  - 2)若一个进程在主存中的**页面过少**，则尽管有局部性原理，**缺页率仍相对较高**。
  - 3)若分配的页框过多，则由于局部性原理，对该进程的**缺页率**没有太明显的影响。

## 分配策略

- 在请求分页系统中,可以采取
  - 两种**分配策略**


### 固定分配

- 分配给进程的内存物理块数保持不变



### 可变分配

- 分配给进程的内存物理块数可以变化

## 置换策略


- 两种置换策略

  - 全局置换
  - 局部置换

### 局部置换

- 所谓**局部置换**，是指如果进程在**运行中发生缺页**，
  - 则只能从分配给该进程在内存的页面中选出一页换出，然后再调入一页，
  - <u>以保证分配给该进程的内存空间不变</u>。🎈



### 全局置换

- 所谓**全局置换**，是指如果进程在运行中发生缺页，系统从**空闲物理块队列**中取出一块分配给该进程，并将所缺页调入。

## 策略组合

- 分配策略和置换策略两者组合,共有三种可能的**策略组合**


### 固定分配局部置换

- 内存块数-固定分配-局部置换

- 它为每个进程分配一定数目的**物理块**，在整个运行期间都不改变。


- 实现这种策略时，难以确定应为每个进程分配的物理块数目:
  - 太少会频繁出现缺页中断，
  - 太多又会降低 CPU和其他资源的利用率。

- 🎈固定分配要求进程的内存物理块不变
  - 所以不可以配合全局置换(这试图改变物理块数,导致矛盾)

### 可变分配全局置换

- 这是**最易于实现**的物理块分配和置换策略，

- 它为系统中的**每个进程分配一定数目的物理块**

  - 在进程运行期间,根据情况适当的增加/减少分配给进程的内存物理块

  - 操作系统**自身保持一个空闲物理块队列**。

- 这种方法比固定分配局部置换更加灵活，可以**动态增加进程的物理块**，但也存在弊端，

  - 如它会盲目地**给进程增加物理块，从而导致系统多道程序的井发能力下降**。
  - 先为每个进程分配一定数目的物理块，在进程运行期间可根据情况适当地增加或减少。

  

### 可变分配局部置换🎈

- 它为**每个进程分配一定数目的物理块**，
  - 当某个进程**发生缺页时**，只允许**从该进程在内存的页面中选出一页换出**，因此**不会影响其他进程的运行**。
  - 若进程在运行中**频繁地缺页**，则系统再**为该进程分配若干物理块**，直至该进程**缺页率趋于适当程**
    **度；**
  - 反之，若进程运行中的缺页率特别低，则可适当减少分配给该进程的物理块。

- 比起可变分配全局置换，这种方法**不仅可以动态增加进程物理块的数量**，还能**动态减少进程**
  **物理块的数量**，在保证进程不会过多地调页的同时，也保持了系统的多道程序井发能力。
- 当然它需要更**复杂的实现，也需要更大的开销**，但对比频繁地换入／换出所浪费的计算机
  资源，这种牺牲是值得的。







