[toc]

# cache@主存映射方式@取模运算的规律

- cache行中的信息是主存中某个块的副本,地址映射是指:
  - 把**主存地址空间**映射到**cached地址空间**🎈
    - 映射函数$y=f(x)$
      - $x$是某个主存块的地址
      - $y是x采$用映射规则$f$后对应到的**缓存块号**
  - 把存放在<u>主存中的信息</u>按照某种规则**装入cache**
  - 在cache中要为每一个cache块加一个标记T(tag)
    - 标记指明它对应于主存中的那个块的副本
    - 相当于主存中块的编号
  - 为了说明cache行中的信息是否有效,每个cache行还有一个有效位V(vality)
  - 地址映射方式有3种
    - 直接映射
    - 全相联映射
    - 组相联映射

## 取模的规律🎈

$$
(xn+y)\%n=y\%n
\\或
\\
若有x\%n=0;则(x+y)\%n=y\%n
$$



- 设
  - $x=x_1+x_2$
  - $p=x\%n$
  - $s_1=x_1//n$
  - $s_2=x_2//n$
  - 约定`//`表示整除(取整数部分,表示向下取整)
  - $q_1=x_1\%n$
  - $q_2=x_2\%n$
  - $q=q_1+q_2$
  - $r=q\%n$
  - $p,q_1,q_2\in[0,n-1]$
    - $q\in[0,2n-2]$
  - $p与q的关系?$
    - 没有一般性断论
  - $p与r的关系?$
    - $p=r$
    - $x\%n=(x_1+x_2)\%n=(x_1\%n+x_2\%n)\%n$
- 分析:
  - 例:
    - $取x=9;x_1=4,x_2=5,n=3$
    - $p=9\%3=0$
    - $q=q_1+q_2=1+2=3$
    - $q\%3=0$
    - $p=q\%3$

### 例

- $已知M\%C=0;M,C>0$
  - 则[0,M-1]范围内,最大的可以被C整除的数y是多少?
    - $设y=M-p,y\in[0,M-1]$
  - 分析:
    - 根据前面讨论的规律
    - r=$(M-p)\%C=p\%C$
    - 为了使得M-p最小,且使得上式(r=0)
    - 取p=0,但是不满足$[0,M-1]$
    - 退一步,再取$p=C$,满足所有要求
  - 所以y=M-C是所求的值

## 地址和块号的转换🎈

### 地址的字段/区域划分🎈

- 在**cache-主存地址映射**(简称为**CMA映射(cache memory address mapping)**,CMAM🎈)部分,将需要被映射的地址划分为2大部分
  - 高m位
    - 高m位是分析的重点,不同的地址映射方式主要在高m位上做不同的二次划分
    - 以**R路组相联方式**映射为例,**内存地址高m位**进一步被划分为
      - 高s位
        - s是主存字块标记字段位数
        - r位表示需r个二进制为来组合出R路(分组内的R个不同到的块)
        - r描述了组相联和相联映射方式接近程度
          - 当r=c(c为cache块数),那组相联就退化为全相联(s=m)
        - 对于块数有限的cache,
          - 路数越多(R越大),则
            - 分组Q越少,主存字块标记字段位数s就越长
            - 越接近全相联映射方式
            - 开销越大
            - 命中率越高
      - 低q位
        - 组内地址字段
  - 低b位
    - 这不部分用来编址内存物理块的**块内地址**(比如**字地址**)
    - 在操作系统中,内存管理部分(分页系统中),这b位作为**页内地址**或者页内偏移
    - 块(cache块(cache行),物理块),页,以及页架的大小都是一样的
      - 在不同上下文中称呼不同,但是容量上是一样的(统称为块)
      - 在虚系统中,信息块更大
      - 充当的功能也比较类似,为了确定块中的具体字的位置

#### 小结

- 高m位在内存物理地址中也称为**物理页号**(操作系统的角度理解)
  - 虚拟地址的位数则不一定和物理地址的位数一致
  - 但是虚拟地址和物理地址中的**页内地址(页内偏移)**却是一致的(b位)
  - ..

### CMAM和VAT

- **虚拟存储器**中的**地址变换(翻译)**(VAT(virtual address translation))有相似性
  - VAT中,也有引入快表(TLB,由相联存储器实现)可以像CMM中的组相联那样工作,达到提高<u>地址变换速度</u>的目的
    - 依赖于**页表**(慢表/快表)实现地址翻译
  - VAT是用**逻辑地址(虚地址)**作为输入,计算出物理地址
  - CMAM是用**内存物理地址(实地址)**作为输入的,得到该物理块在cache上的位置),来利用cache

#### 硬件方面

- CMAM中的组相联(全相联方式)的实现如果用软件的方式实现,性能比较差
  - 主要采用硬件(相联存储器CAM)来实现
- VAT中(集中不同的内存管理方式对应的不同VAT都可不采用CAM也能工作,但是性能会变得很差)
  - VAT中,主要目的是为了从逻辑的角度上扩充**内存地址空间**,便于用户使用,同时提高内存利用率和这多道程序度

### 地址和块号

- 假设给定内存(单元)地址A,

- 如果计算机按**字节**编址,cache块大小为L字节,那么地址A(从0开始编址)对应的主存块号j为

  - $j=\frac{A\times{Byte}}{L\times{byte}}=\frac{A}{B}$

- 地址区间0$\sim$A包含的内存存储单元数为<u>A+1</u>

  - 地址0对应内存中的第1个存储单元(第1个字节)

  - 地址1对应第2个存储单元

  - .....

  - 表格形式

    | 地址值(索引)(从0开始编号) | 内存单元序号(从1开始计数) |
    | ------------------------- | ------------------------- |
    | 0                         | 1                         |
    | 1                         | 2                         |
    | 2                         | 3                         |
    | ...                       | ...                       |
    | A                         | A+1                       |

### 组号和块号

- 设每个组包含R个块,共有Q个组,从0开始编址

- | 组号(从0编址) | 组内包含的块号范围(从0编址) |
  | ------------- | --------------------------- |
  | 0             | $[0,R-1]$                   |
  | 1             | $[R,2R-1]$                  |
  | ...           | ...                         |
  | $x$           | $[xR,(x+1)R-1]$             |
  | ...           | ...                         |
  | $Q-1$         | $[(Q-1)R,QR-1]$             |

  - 相邻组间的首尾块编号是连续的
  - 可以利用上一个分组内的最后一个块的编号+1得到下一组的组内首个块的编号

### 例

- 例如,按字节编址的计算机,某个内存单元地址A=3200(十进制)
  - cache块大小为64B
  - 则A对应的块号(从0开始编址)为
  - $j=\frac{3200B}{64B}=50$

## 直接映射

### 逻辑结构示意图

![在这里插入图片描述](https://img-blog.csdnimg.cn/17425a5019194c088b71777d0a8dc146.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_15,color_FFFFFF,t_70,g_se,x_16)

* 设

  * 主存共有$M=2^m$个字块,
  * cache共有$C=2^c$个字块
  * 如果从0开始编号,则对应的编号范围为
    * $[0,M]$
    * $[0,C]$
  * 也就是说,M,C可以表示主持和cache的容量
  * 区分M,m;C,c大小写
    * 区分不同**缓存块**用c位	二进制数来编码区分
    * **主存块**用m位二进制数来区分
  * $m>>c(m远远大于c)$
    * $\frac{M}{C}=\frac{2^m}{2^c}=2^{m-c}\in{\mathbb{Z}},m,c\in\mathbb{Z}$
  * 下面提到的b位则是字块内部的存储单元的地址

* 直接映射关系式为

  * $i = j\mod C=j\%i$

  * 其中(块号理解为地址字段,从0开始编号)

    * $i为cache块号$
      * $i\in[0,C-1]$
    * j为主存块号
      * $j\in[0,M-1]$
    * C为缓存块数(C=$2^c$)
      * c表示<u>缓存地址的**高位部分**(缓存块的块号(二进制串))</u>

  * $i是j的函数$
    $$
    i=f(j)=f(j,C)=j\mod{C}
    $$
    

* 可见

  * `每个主存块`只与 `一个缓存块`相对应

  * **直接映射法**是一种<u>固定的映射方法(僵硬而不灵活的)方式</u>

  * 映射结果表明 `每个缓存块`对应 `若干个主存块`

  * 根据映射规则f

    * $可计算f的反函数f^{-1}$

    * $j=f^{-1}(i)=C$

    * | 缓存块号 | 主存块号                  | Note          |
      | -------- | ------------------------- | ------------- |
      | 0        | $0,C,2C,\cdots,M-C$       | $M=2^m;C=2^c$ |
      | 1        | $1,C+1,2C+1,\cdots,M-C+1$ |               |
      | ...      | ..                        |               |
      | C-1      | $C-1,\cdots,M-1$          |               |

    - Note:

      - 上面说到,$C=2^c$,$M=2^m$;$\frac{M}{C}=m-c$,当然,m,c都是正整数(m>c),它们的差值也是正整数
        - 这意味着,主存的块数是cache块数的整倍数;
          - (从这个语境下看,主存的最后一块会恰好的被映射到cache上的最后一块cache块.)

      - 又因为,我们是从0开始计数的,所以最后一块主存块$2^m-1$将被映射到cache块的最后块$C-1$上.

      - 或者从周期(函数)的角度(周期为T=C),可以方便的根据周期,把缓存块号最为该映射上结果序列上的第一个主存块号,再依次+C,得到映射到该cache块的主存块序列(比如,0,C,2C,3C,...,$2^m-C$)

### 地址结构🎄

- $主存地址n=(t+c)+b$
  - 主存字块标记t位
  - cache字块地址c位
  - 字块内地址b位
  - $其中,m=t+c;$
  - m位还是用来编址区分主存块的,
  - 只不过,这里将高m位进一步划分为t+c位
  - 最高t位作为标记位
  - 实际上,标记位数是通过$t=m-c$来确定的(m和c分别是主存含有的字块数和cache含有的字块数)
- cpu将需要访存的地址(主存地址用映射规则函数解析这个地址,得到一个对应与cache中的某个cache块的地址AddrCache)
  - 然后cpu根据解析得到的地址(AddrCache)在Cache中找到对应的块判断是否命中有效数据字块
  - 有效位是在cache中的**比较器**(t位)处做判断,来判读cache的AddrCache位置的字块是否保存着有效的数据
  - 如果是,那么就是命中,本次访问数据不需要访问主存储器(cache满足需求)

### cache的总容量

- cache的总容量包括:
  - 存储容量$S_{data}$
  - 标记阵列容量$S_{terms}$
    - 根据具体的要求计算标记项中的成分
- $S=S_{terms}+S_{data}$



#### 标记项和标记矩阵

- 每个cache行都对应一个标记项,包括以下字段

  - 有效位

  - 标记位

  - **一致性维护位**(也叫脏位/清浊位)

  - 替换算法控制位

- 直接映射方式中,每行的**标记项**单独一行

- 组相联映射方式中,每组中的r行**排成一个行**(包含r个项)

  - $r\geqslant{2}$时,$q$个组构成一个标记项的二维阵列($r\times{q}$矩阵)
  - $r=1$时,相当于直接映射方式(表现为$c\times{1}$矩阵)

#### cache行验证容量🎆

- 为了便于描述包括**标记项**和cache行存储容量的总和,称其为**cache行验证容量**$L_{t+d}$
- 不过也没必要用这个概念

#### 缓存块的标记位/类🎈

- 用于记录(和cache块建立了对应关系的)主存块的标记(身份标识),可以用来检测冲突/判断命中(配合**有效位**)
- 不妨将映射到同一个cache位置的主存块记为同一**类(class)**
  - 对于直接映射而言,一个类中最多有$2^t$个元素
  - 而cache的每一个块都表示一个**类**
  - 地址中的**高t位**可以用来区分**类**中的不同的[成员**块**]
    - 其后的c位用来计算某个主存块到底属于哪一个**类**



#### 高位地址t+c

* 在缓存中 `主存地址高m位`被分成两部分:

  * `低c位`是指Cache 的字块地址,

  * `高t位`$(t = m-c)$是指 `主存字块标记tag `,它被记录在 `建立了对应关系的缓存块的`“标记"位中。

    * 这里$t=m-c$是指($2^t=\frac{2^m}{2^c})$;
    * 主存块数是cache块数的$2^t$倍(这个倍数用二进制数表示恰好需要t位)

  * 当 `缓存`接到CPU送来的 `主存地址 `后,只需根据 `中间c个bit `的字段(假设为00…01)找到 `Cache字块1(cache行1)  `

    * 然后根据字块1的“标记”`是否与主存地址的高t位相符 `来判断( `t位比较器`硬件做的这个事情)
    * 之所以这么做,是因为,一块cache块,会被多块主存块映射
      * 譬如上表格中所示,0号cache块可以被$0号,C号,2C,..2^m$,
      * 为了区分这些来自主存的且映射到同一个cache块的不同的主存块,这就依赖于预保留出来的前t位来做一个块身份判断
      * 但是考虑到某些情况下(比如机器初始启动,cache中的内容是无效的(空或者无意义的)),需要一个有效位来判断有效性

  * 若符合,且有效位为“1”(即成功命中)(有效位 `用来识别Cache存储块中的数据是否有效`,因为有时Cache中的数据是无效的,❤️

    * 例如,在初始时刻Cache应该是“空”的,其中的内容是无意义的(这样,即使判断标记和主存地址一致,取出的数据也是无意义的(标记不是数据本身),
    * 有效位为1,表示该Cache 块已和主存的某块建立了对应关系(即已命中),则可根据b位地址从Cache中取得信息;

    * 若不符合,或有效位为“0”(即不命中),则 `从主存读入新的字块`来替代旧的字块,同时将信息送往CPU,并修改cache“标记”。
      * 如果原来有效位为“0”,还得将有效位置成“1”。
    * 此外,高t位描述了不同主存块映射到同一个cache块的冲突发生的难易程度
    * t位数越高,冲突越容易发生

### 特点

- 直接映射方式的缺点是不够灵活,因每个主存块只能固定地对应某个缓存块,
- 即使缓存内还空着许多位置也不能占用,使缓存的存储空间得不到充分的利用。
- 此外,如果程序恰好要重复访问对应**同一缓存位置(cache块)**的**不同主存块**,就要不停地进行替换,从而<u>降低命中率</u>。

### 小结

- 计算机的主机包括cpu和存储器

- cache作为一种高速中间设备主要用来提升性能(然而它不是运行中的必要一环)
- cpu根据数据(比如操作数)的地址,到对应地址位置去取数据
  - 这时用到的主存地址可以分为三部分t+c+b
  - 前m=(t+c)位可以精确到主存中的某个块
  - 后b位可以进入到指定的主存块中进行字(节)的定位
- 没有cache的时候,cpu就直接到主存的正确的 `地址`处去取数据
- 现在有了cache,cpu会将这个原本要到主存访问的(主存)`地址`和cache中做对比(主要根据上述主存地址划分中的 `中间c位`字段计算得到对应映射的cache行(块);
  - 再进行对比高t位的对比(如果对比结果发现相同,且对应的cache块的数据部分中的数据是有效的(根据有效位是否为1判定)(这时视为命中),那么就不用在进一步到主存中去取数,直接将命中的cache块中的数据取出来使用



#### 优点

* 实现简单,只需 `利用主存地址的某些位`直接判断,即可确定所需字块是否在缓存中

#### 缺点

* 直接映射方式的缺点是不够灵活,因每个主存块只能固定地对应某个缓存块,即使缓存内还空着许多位置也不能占用,使缓存的存储空间得不到充分的利用。
* 此外,如果程序恰好要 `重复访问`对应 `同一缓存块位置`的 `不同主存块`,就要不停地进行替换,从而降低命中率。
  



|                                                              |                                                              |      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| ![🥰03/07/2022 20:03:44](https://img-blog.csdnimg.cn/img_convert/36a44d0eca98fa427ba458e7406a539d.png) | ![1646656842434.png](https://img-blog.csdnimg.cn/img_convert/2565bbfc787e15007d56219801064bd8.png) |      |
| ![1646657005307.png](https://img-blog.csdnimg.cn/img_convert/c2ba150bbce20b2ba5ec2c0f49e27004.png) |                                                              |      |
|                                                              |                                                              |      |





## 全相联映射🎈

* 全相联映射允许主存中每一字块映射到Cache中的**任何一块位上**(任意性)。
* 这种映射方式可以从已被占满的Cache中替换出任一旧字块。
* 显然,这种方式灵活,命中率也更高缩小了块冲突率。
* 与直接映射相比,它的 `主存字块标记`从t位增加到 `t+c`位
* 这就使Cache“标记”的位数增多,而且访问Cache时**主存字块标记**需要和<u>Cache的全部“标记”位进行比较</u>,才能判断出所访问主存地址的内容**是否已在Cache 内**(由于任意性)
  * 这种**比较**通常采用<u>“按内容寻址”</u>的**相联存储器(AM,CAM)**来完成。

* 总之,这种方式所需的**逻辑电路甚多**,成本较高,实际的Cache还要采用**各种措施来减少地址的比较次数**。

### 映射逻辑结构示意图

![1646657418935.png](https://img-blog.csdnimg.cn/img_convert/a28a2086c3c7be05535ffb7d1de39144.png)

- 每个主存块都可能映射到任意一个cache块(可以占满整个cache  )

### 地址结构🎄

- 主存地址结构:
  - 主存字块标记:$m=t+c$位
    - 相比于直接映射,主存地址的高m位全部被用来作为标记位
  - 字块内地址:$b$位

|                                                              |                                                              |      |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| ![1646657946575.png](https://img-blog.csdnimg.cn/img_convert/13e70746ef5a8377c2926d78858e3f08.png) | ![1646657998977.png](https://img-blog.csdnimg.cn/img_convert/1ca24e03608851b7e1d36c8ee7c11eb9.png) |      |
|                                                              |                                                              |      |

- ![1646657946575.png](https://img-blog.csdnimg.cn/img_convert/13e70746ef5a8377c2926d78858e3f08.png)

- ![1646657998977.png](https://img-blog.csdnimg.cn/img_convert/1ca24e03608851b7e1d36c8ee7c11eb9.png)

### CAM

- CAM;[Content-addressable memory](https://en.wikipedia.org/wiki/Content-addressable_memory)

  - [内容可寻址存储器](https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%8F%AF%E5%AF%BB%E5%9D%80%E5%AD%98%E5%82%A8%E5%99%A8/18884435)
  - 内容可寻址存储器cam（content-addressable memory）以内容进行寻址的存储器，是一种特殊的存储阵列ram。
  - 它的主要工作机制就是将一个输入数据项与[存储](https://baike.baidu.com/item/存储/1582924?fromModule=lemma_inlink)在cam中的**所有数据项自动同时进行比较**，判别该输入数据项与cam中存储的数据项**是否相匹配**，并输出该数据项对应的匹配信息。

- **Content-addressable memory** (**CAM**) is a special type of [computer memory](https://en.wikipedia.org/wiki/Computer_memory) used in certain very-high-speed searching applications.

-  It is also known as **associative memory** or **associative storage** and compares input search data against a table of stored data, and returns the address of matching data.[[1\]](https://en.wikipedia.org/wiki/Content-addressable_memory#cite_note-1)

  - CAM is frequently used in [networking devices](https://en.wikipedia.org/wiki/Networking_device) where it speeds up [forwarding information base](https://en.wikipedia.org/wiki/Forwarding_information_base) and [routing table](https://en.wikipedia.org/wiki/Routing_table) operations. 

  - This kind of associative memory is also used in cache memory. In associative cache memory, both address and content is stored side by side. When the address matches, the corresponding content is fetched from cache memory.



## 组相联映射🎈

* **cache分组-组相联映射**: 是对直接映射和全相联映射的一种折中
  * 可以理解为
    * 组间直接映射
    * 组内全相联


### cache分组

* 它把<u>Cache分为**Q组**🎈</u>,每组有**R块**

  * 继承前面的上下文中意思

  * $C=2^c$,表示缓存块数

  * $M=2^m$,表示主存器包含的块数

  * 设$q,r$满足以下条件:

  * $Q=2^q$;

  * $R=2^r$

    * $q=\log_{2}Q$
    * $r=\log_2{R}$
    * 容易知道,q位,r位二进制数分别可以表示出不同Q种,R种编码
    * 体现在地址中的q位,r位

  * $$
    C=QR
    \\
    c=q+r
    $$


### 映射函数

* $$
  i = f(j,Q)=j\mod Q
  \\为了和直接映射做区分,也可以将i写为I
  \\I=f(j,Q)=j\mod Q
  $$

* j为主存的块号

* i为主存块号j映射到cache后的cache `组号`

* 某一主存块号j按照上述映射函数$f(j,Q)$ ,将其映射到缓存的 `第i组`内

* $Q<C$,模变小了,<u>直接相联的部分变得容易重合</u>

  * 组间采用**直接映射**有较高的**组间冲突率**和较低的cache组利用率
  * 组内采用**全相联映射**,可以具有较低的**组内冲突率**和较高的cache组内利用率

### 映射逻辑结构示意图

![1646657717835.png](https://img-blog.csdnimg.cn/img_convert/8470dde4d0cc39a1f6222604c645e0e7.png)

- 容量为C块的cache被分为Q组
  - 此处提到的常量和<u>cache分组</u>提到的含义是一致的
  - $C=2^c$
  - $Q=2^{q}$
    - 如果给定每cache块小组包含的cache块数R(cache分组大小为R)
    - $R=2^r$
    - $那么Q=\frac{C}{R};即q=c-r$
- 分组编号从0开始编址,所有
  - $i\in[0,Q-1]=[0,2^{q}-1]=[0,2^{c-r}-1]$
  - $j\in[0,M-1]=[0,2^{m}-1]$
  - $C=QR;c=q+r$
    - $Q\in[1,C]$
      - $q\in[0,c]$
    - $R\in[1,C]$
      - $r\in[0,c]$



### 地址结构🎄

- 对比直接映射方式的地址结构描述
- 高m位
  - 组地址
    - q位(q=c-r)
  - 主存字块标记
    - s位
    - s=m-q
    - s=t+r
  - $m=s+q$
- 字块内地址
  - b位

### 特点

- 和直接映射类似,每个**主存块**会被映射到固定的**cache块分组**(包含若干个cache块的小组)
  - 而**直接映射**则是映射到具体的**cache块**
  - 相比于直接映射,组相联映射会映射到cache分组
- 组相联的含义:
  - 主存的某一个字块按照模Q映射到Cache某个分组$I$的任意一个字块k中
    - $I=j\mod{Q}$
    - $k\in[0,R-1]$
      - 设组内字块地址(字段部分)从0开始编址

#### 极端组相联映射

- $r$表示cache分组的大小(块数)
- 当$r=0$时,退化为直接映射(分组数Q=C,每个分组仅包含$R=2^{0}=1$个cache块🎈)
  - $q=\log_2{Q}=\log_2{C}=c$
  - s=t
- 当$r=c$时,退化为全相联映射(分组数Q=1,该组包含了$R=2^c$个(即,所有)cache块)
  - $q=\log_2{Q}=\log_2{1}=0$
  - s=t+c
  
- 结合地址结构分析即可得出上述结论



### cpu访存过程

- 采用组相联映射的情况下,cpu的访存过程:
  - 首先根据访存地址中间的组号(q位),找到对应的cache组号
  - 将对应Cache组中每个**cache行(块)的标记**和主存地址的**高位标记**进行比较;
    - 如果其中某一路比较匹配上(相等),**且**有效位V=1
    - 那么cache命中
      - 根据主存地址中的**块内地址**,在对应的cache行中存取信息
    - 否则,不命中
      - cpu需要访问主存,读出地址改地址所在的一块信息,并调入到某个cache分组中的某个cache块
      - 将有效位置1(1表示有效)
      - 设置标记(位串)
      - 再将地址中的内容送往cpu

# 三种映射方式总结🎈🎈

- |              | 直接映射方式 | 全相联映射方式 |
  | ------------ | ------------ | -------------- |
  | 映射时间开销 | 低           | 高             |
  | 额外空间消耗 | 低           | 高             |
  | 命中率       | 低           | 高             |

  

- 组相联映射方式的性能和开销介于直接映射方式和全相联映射方式

## 例🎈

- 假设计算机的主存地址空间大小为256MB
  - # 按字节编址
  - 数据cache有8个cache行
    - 指令cache此处忽略
  - 行长为64B



### cache容量问题

- 若不考虑用户Cache的脏位和替换算法控制位,采用直接映射方式,该数据cache的容量S=?
  - 内存地址为$\log_2{256M}=\log_2{2^8\times{2^{20}}}=28$
    - 其实也用不着计算地址所有位数
    - 由于cache块大小已经知道了
    - 所以只需要知道<u>高位部分的位数m</u>
  - $M=\frac{256MB}{64B}=4M=2^{22}$
    - m=22
  - $C=8=2^3$
    - c=3
    - 直接映射法的标记位数t=m-c=22-3=19bit
  - $S=S_{terms}+S_{data}$
    - $b_{terms}=S_v+t=1+19=20$
    - $b_v=1,表示有效位占1位$
  - $S_{terms}=cb_{terms}=8\times{20}bit=160bit=20B$
  - $S_{data}=cL=8\times{64B}=2^{9}B$
  - S=20+512=532B=4256bit

### 映射块号🎈

- 主存地址为A=3200(十进制)的内存单元对应的

  - 直接映射方式下的cache行号i是多少?

  - 如果采用直接映射:

    - 方法1:计算块号再取模(公式法)
      - $j=\frac{3200}{64}=50$
      - $C=8$
      - $i=50\%8=2$
      - 因此i=2
    - 方法2:分析二进制地址法
      - $3200=2^5\times{100}$
        - $100=8\times{12}+4=2^3\times{1100_2}+2^2=1,100,000+100=1100100$
        - $3200={100000_2}\times 1100100_2=1100100,00000$
        - 110,010,000,000
        - 块内地址后的c=3位,即,第7,8,9位是映射后的cache块号地址$010_2=2$:
      - 因此块号i=2

  - 二路组相联下的cache组号I是多少,行号i是多少?

  - 如果采用<u>2路组相联</u>(R=2),那么

    - $Q=C/R=8/2=4$

    - $I=j\%Q=2$

    - 即,对应的组号为2

    - 由于每组中含有的cache块数是R=2

    - 由于组号编号从0开始

      - 那么0号组和1号组共含有$(2-0)R=2\times{2}=4$块
      - 所以第2组包含第5~6块,是 i对应的
      - 考虑到从0编号,所以i=4或5,

    - | 组号(从0编址) | 块号(从0编址) |
      | ------------- | ------------- |
      | 0             | $[0,R-1]$     |
      | 1             | $[R,2R-1]$    |
      | 2             | [2R,3R-1]     |

      - $R=2,i\in[4,5]$
      - 十分推荐列表,不仅有利于**归纳**通项,还有利于降低错误机率

### 访存过程问题

- 以直接映射方式为例,cpu在访问$A=0123456H$的地址时的过程?

#### 地址分析

- 地址A共有4*7=28位
- 低b=6位是**块内地址**(具体的字节/字地址)
  - 010110
- 高m=22位:
  - cache块号位c=3位
    - 001
  - 标记位t=22-3=19位
    - 0000 0001 0010 0011 010

#### 标记项比较

- 根据块号位001得知,A处的主存单元内容只可能会被映射到001号cache块
- 检查001号块cache行对应的**主持标记位**和上面计算出来的主存中的t=19位标记位字段,判断是否相同
- 如果相同
  - 再判断有效位,如果有效位为1,那么cache命中,
  - 按照块内地址6位从001号cache行中读取出来相应的内容字节并送入到cpu,完成高速访存
- 否则标记比较不相同,或者有效位是0
  - 那么cache未命中,需要访问主存,从主存的A位置将内容送入cpu和cache对应块中
  - 再设置**标记项**
    - 把主存的高19位tag位存入001行中
    - 置有效位为1

# 🎈对比:虚拟存储器和cache的比较

## 相同之处

- 1)最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。
- 2)都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大。
- 3)都有地址的映射、替换算法、更新策略等问题。
- 4)依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中。

## 不同之处

- Cache主要解决系统速度，而虚拟存储器却是为了解决主存容量。
- Cache全由硬件实现，是硬件存储器，对所有程序员透明：
  - 而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对**系统程序员**不透明，但对**应用程序员**透明。
- 对于不命中性能影响,虚拟存储器系统不命中时对系统性能影响更大。
- CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路
  - 也就是说在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache;
  - 而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。

