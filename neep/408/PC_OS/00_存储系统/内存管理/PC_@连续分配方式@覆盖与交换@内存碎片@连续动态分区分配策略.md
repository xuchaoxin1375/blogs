[toc]

# PC_@连续分配方式@覆盖与交换@内存碎片@连续动态分区分配策略

## refs

- [Memory management - Wikipedia](https://en.wikipedia.org/wiki/Memory_management#Dynamic_memory_allocation)

## 覆盖技术和交换技术

- 在多道程序程序环境下用来扩充内存的两种方法

### 覆盖

- 单个进程内存分配-覆盖
- 把用户内存空间分为
  - 固定区(一个)
    - 存放经常活跃的部分
  - 覆盖区(若干个)
    - 非活跃部分按照调用关系分段
      - 将要访问的段放入覆盖区
      - 其余段放入外存中
        - 在需要调用时系统将其调入到覆盖区,替换覆盖区中原有的段
- 体现了虚拟内存的基本思想(多次性载入程序数据到内存中)
- 但是当同时运行的程序需要的内存大于主存容量时,仍然不能运行
  - 不在覆盖区中的段会常驻内存(固定区)
- 覆盖技术对程序员不透明(程序员可以感受到)

### 交换

- 进程间内存分配-交换

- 把处于等待状态的程序从内存中移动到辅存(外存),把内存空间腾出一部分(称为**换出**)
- 把就绪状态的程序从辅存调入内存(称为**换入**)
- **中级调度**采用的就是<u>交换技术</u>

#### 特点

- 交换需要备份存储，通常是磁盘。
  - 它必须足够大，并提供对这些内存映像的直接访问。
  - 为了有效使用CPU，需要使<u>每个进程的执行时间比交换时间长</u>
- 若换出进程，则必须确保<u>该进程完全处于空闲状态</u>。
- 交换空间通常作为<u>磁盘的一整块</u>，且<u>独立于文件系统</u>，因此使用起来可能很快
- 交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。
  - 普通的交换使用不多，但交换策略的某些变体在许多系统（如UNIX）中仍发挥作用。

### 小结

- 🎈交换技术主要在不同进程（或作业)之间进行，而覆盖则用于同一个程序或进程中。
- 对于主存<u>无法存放用户程序的矛盾</u>，现代操作系统是通过**虚拟内存技术**来解决的
- 覆盖技术则已成为历史
- 交换技术在现代操作系统中仍具有较强的生命力。



## 内存块和内存分区

- 自己的理解🎄

- 划分给某个进程使用的内存区域称为**内存分区**
- 还未被划分(给某个进程使用)的内存区域称为**内存块**

## 碎片

- 内存利用率低下的统称
- 根据难以利用的(或者浪费的)内存区域在内存分区内还是外部,分为
  - 分区-内部碎片
  - 分区-外部碎片

### 内部碎片🎈

- 内存发生<u>分区内的空间利用率低下</u>(利用率低)的现象称为**内部碎片**

### 外部碎片

- 内存中过多的内存分区分割产生越来越多难以利用的小内存块(分布在内存分区和分区间的间隙)
- 导致内存利用率低下的现象这些小内存块称为外部碎片

### 紧凑操作

- 克服外部碎片可以通过紧凑技术来解决
  - 操作系统不时地对进程进行移动和整理
  - 需要动态重定位寄存器的支持
  - 相对费时

## 连续分配管理方式

- 为一个用户程序分配一个连续的内存空间
  - 单一连续分配
  - 固定分区分配
  - 动态分区分配

### 单一连续分配

- 连续-单一分配方式
- 内存在此方式下分为系统区和用户区
  - 系统区仅供操作系统使用,通常在低地址部分
  - 用户区中仅有一道用户程序,整个内存的用户空间由**该程序独占**

#### 特点

- 简单,无外部碎片,有内部碎片,存储器利用率极低
- 内存那种只有一道程序,无序进行内存保护
- 只用用于单用户,单任务的操作系统中

### 固定分区分配

- 连续-固定多分区分配方式
- 是一种最简单的**多道程序存储管理方式**

- 将用户内存空间划分为若干个固定大小的区域
  - 每个分区之装入一道作业
  - 有空闲分区时,可以从**外存**的后备作业队列中选择合适大小的作业装入该空闲分区
- 划分分区的方法
  - 分区大小相等
    - 缺乏灵活性:程序太小造成浪费,程序太大又无法装入
  - 分析大小不等
    - 划分为数量较多的较小分区
    - 数量时钟的中等分区
    - 少量的大分区
- 分区说明表
  - 为了便于内存分配,将分区大小排列
  - 建立分区说明表,各个表项包括每个分区的
    - 起始地址(始址)
    - 大小
    - 状态
  - 有用户程序要装入时,检索该表,找到合适的分区分配
    - 从可以满足运行要求的分区中 选定分区的操作有不同的算法
  - 将分配出去的分区状态记为已分配
  - 如果找不到合适分区,则拒绝为该程序分配内存



#### 特点

- 较大程序可能无法放入任何一个分区中(采用覆盖技术使用内存空间)
- 程序小于固定分区大小时,也要占用一个完整的**内存分区**,这样的分区内部就存在**空间浪费**(内部碎片)

### 动态分区分配

- 连续-动态分区分配,也称为**可变分区分配**

- 在进程装入内存是,**根据进程的实际需要**,动态地为其分配内存(分区的大小整合适合程序的需要)
- 系统中分区的大小和数目是可变的
- 特点
  - 随着时间的推移,内存中产生越来越多难以利用的小内存块(小内存分区),内存中的利用率随之下降
  - 这些小内存块称为外部碎片

## 动态分区分配策略

- 在进程装入或换入内存时,如果内存中有多个足够大的**空闲块**,

### 首次适应算法

- FF:FirstFit
- 空闲分区以地址递增的次序链接。
- 分配内存时从链首开始**顺序查找**，找到大小**能满足要求的第一个空闲分区**分配给作业。

### 邻近适应算法

- NF:（Next Fit）

- 又称**循环首次适应算法**，由首次适应算法演变而成。
- 不同之处是，分配内存时**从上次查找结束的位置开始继续查找**。

### 最佳适应算法

- BF:Best Fit

- 空闲分区按容量递增的次序形成空闲分区链，找到**第一个能满足要求**且**最小**的空闲分区分配给作业，
  - 避免“大材小用

### 最坏适应算法

- WF:(Worst Fit)
- 空闲分区以**容量递减的次序链接**，找到第一个自满足要求的，即**最大的分区**，从中**分割一部分存储空间**给作业。

### 小结🎈

- 首次适应算法**最简单**，通常也是**最好和最快**的
- 不过，首次适应算法会使得内存的**低地址部分出现很多小的空闲分区**，而每次分配查找时都要经过这些分区，因此增加了开销
- **邻近适应算法**试图解决这个问题。
  - 但它常常导致在内存空间的**尾部**（因为在一遍扫描中，内存前面部分<u>使用后再释放时，不会参与分配</u>）分裂成**小碎片**。
    - 通常**比首次适应算法要差**。
  - 最佳适应算法虽然称为“最佳”，但是**性能通常很差**，因为每次最佳的分配**会留下很小的难以利用的内存块**，会**产生最多的外部碎片**。🎈
  - 最坏适应算法与最佳适应算法相反，它选择最大的可用块，这看起来**最不容易产生碎片**，但是却把最大的连续内存划分开，会很**快导致没有可用的大内存块**，因此性能也非常差。
- 在动态分区分配中，与固定分区分配类似，设置一张**空闲分区链(表)**，并按始址排序。
- 分配内存时，检索**空闲分区链**，找到所需的分区
  - 若其大小大于请求大小，便从该分区中按请求大小分割一块空间分配给装入进程
    - 若剩余部分小到不足以划分，则无须分割
    - 余下部分仍留在空闲分区链中。
- 回收内存时，系统根据**回收分区的始址**，从**空闲分区链**中找到相应的**插入点**，
- 此时可能出现四种情况:(根据回收分区的始址和临近分区的位置关系)
  - 记被回收分区为N,前一个空闲分区为A,后一个空闲分区为B(A,B可能不存在)
  - ①回收区与插入点的前一空闲分区相邻A，将这两个分区合并(AN)，并修改前一分区表项的大小为两者之和$AN\to{A}$;
  - ②回收区与插入点的后一空闲分区相邻B，将这两个分区合并NB，并修改后一分区表项的始址和大小$NB\to{N}$;
  - ③回收区同时与插入点的前、后两个分区相邻，此时将这三个分区合并ANB，修改前一分区表项的大小为三者之和，取消后一分区表项$ANB\to{A}$;
  - ④回收区没有相邻的空闲分区(A,B不存在)，此时应为回收区**新建一个表项**，填写始址和大小，并插入空闲分区链。

