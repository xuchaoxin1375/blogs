[toc]

## 页面置换算法

- 此处主要讨论内存-辅存层次的页面置换算法,其是实现虚拟内存的关键之一

- 进程运行时,如果其访问的页面不在内存中,则需要将其从外存调入
- 如果调入之前,内存中已经没有空闲的时候,就需要从内存中调出一页程序或数据,送入磁盘的**对换区**
- **页面置换算法**:选择调出页面的算法

## 页面算法评价

- 好的页面算法具有较低的页面更换评率
  - 做页面调换的时候,算法应该将之后较长时间**不会再次访问**的页面调出
  - 而不是(尽量不要)调出还会被频繁使用的那些页面,否则容易引起**抖动**

## 最佳置换算法OPT

- 最佳置换算法选择的被淘汰页面

  - <u>在最长时间内不再被访问的页面(**包括以后永不使用的页面**)</u>，以便保证获得**最低的缺页率**。

    - 假设长度为n(访问次数)的有序访问序列为$L=0,1,\cdots,n-1$

      - 即L的元素表示访问编号,有顺序区别

    - 假设第i次访存$(i\in[0,n-1)$时发现

      - 分配给进程p的s=3个页架中都有内容,且分别记为

        <!-- $a_{k_1},a_{k_2},a_{k_3},并且k_j\in{},j\in[1,s]$ -->

        - $v_1,\cdots,v_s$
        - 这时需要页面置换,采用OPT算法操作

      - 设$v=v(i)$表示第i次想要访问的页面是v

        - v不一定存在于进程的p的s个页架中,如果不存在,需要从辅存调入

      - 子序列$L(i)=i,\cdots,n-1$

      - 序列$Lv(i)=v(i),\cdots,v(n-1)$

      - 记$\delta=\delta(i,v_{j})=Next(i,v_{j})$表示:进程p第i次要求访存,从要发生页面置换的时刻算起,下一次(最近)再访问到页面$v_j$需要的等待时间(跳数)

        - $i\in[0,n-1]$
        - 在OPT算法中$j\in[1,s];v_j是页架中已经存在的页面$
        - 对于$\delta{(i,v_j)}$的计算,
          - 如果子序列$L_i$的访问的页面$Lv(i)$中不存在$v_j$
          - 那么$\delta(i,v_j)=+\infin$,表示进程p的第i次以及之后的访存都不再访问页面$v_j$
        - 这里就是用跳数$\delta$来衡量'时间'的
        - 在实际笔算的过程中,可通过列表(二维)来求解
          - 在不至于引起混淆的情况下,可以省略掉第一个参数i

      - 计算$ max(\delta(v_j)),j\in[1,s]$

        - 将满足上述条件的页号记为$v_m$

        - 被替换的页面就是$v_m$

- 然而，由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，

- 因而**该算法无法实现**。

- 但可利用该算法**去评价其他算法**

- 该算法可以对某一个给定的**页面访问序列**做模拟替换操作(实际上访问序列是难以确定)

### 例

- 假定页面访问序列为

  - 7,0,1,2,0,3,0,1,2
  - Note:不同的序列(长短/结尾)的不同,都会导致求解过程的不同🎈
  - 访问序列长度为n=20

- 进程p运行时，先将7,0,1三个页面依次装入内存。

  - 由于最初分配个进程p的**3个**内存页面全为空,因此第一次访问一定会发生缺页

  - 本例中,头3次访问的页面都是互不相同的,因此前三次都发生缺页

    - 但是由于分配的3个页面都是空的,所以这三次缺页都不需要用置换算操作
    - 只需要将缺页的页面调入这三个页架中即可

  - 从第4次访存开始,3个页面都已经有内容了,如果发生缺页,就会调用置换算法执行页面置换

  - 本例中,第4次访存将执行页面置换

    - 采用OPT算法,

    - | n次访问的页面序列Lv(i)                                       | Note          | 7    | 0    | 1    | 2              | 0    | 3              | 0    | 1    | 2                            |
      | ------------------------------------------------------------ | ------------- | ---- | ---- | ---- | -------------- | ---- | -------------- | ---- | ---- | ---------------------------- |
      | b1                                                           |               | 7    | 7    | 7    | 2              | 2    | 3              | 3    | 3    | 2                            |
      | b2                                                           |               |      | 0    | 0    | 0              | 0    | 0              | 0    | 0    | 0                            |
      | b2                                                           |               |      |      | 1    | 1              | 1    | 1              | 1    | 1    | 1                            |
      | $v_1,v_2,v_3$                                                |               |      |      |      | 7,0,1          |      | 2,0,1          |      |      | 3,0,1                        |
      | $(\delta(v_1),\delta(v_2),\delta(v_3));$<br />${\delta(v_j)},j\in[1,s]$ |               |      |      |      | ($\infin$,2,5) |      | ($\infin,2,3$) |      |      | ($\infin$,$\infin$,$\infin$) |
      | $v_m|使得max(\delta(v_j))$                                   |               |      |      |      | 7              |      | 2              |      |      |                              |
      | 是否缺页                                                     | 1表示缺页     | 1    | 1    | 1    | 1              |      | 1              |      |      | 1                            |
      | 是否执行OPT算法                                              | 1表示需要执行 |      |      |      | 1              |      | 1              |      |      | 1                            |
      | Note                                                         |               |      |      |      |                |      |                |      |      | @1                           |

      - @1处表示,当OPT算法执行到结尾的时候,同时发生缺页,那么有可能出现多个替换(淘汰)优先级一致的情况,那么可以随意从中选择一个物理块调换即可

## 先进先出算法

- FIFO

## 最近最久未使用算法

- LRU
- 选择最近最长时间未访问过的页面予以淘汰
  - 它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。
- 该算法为**每个页面设置一个访问字段**(记录淘汰权重值)，用来**记录页面自上次被访问以来所经历的时间**，
  - 淘汰页面时选择现有页面中**值最大的**予以淘汰
  - 更详细的细节参考组成原理中cache的LRU替换算法介绍(比较接近于Clock算法)
- 性能接近OPT算法,实现起来开销较大
  - 需要寄存器和栈等硬件支持

## 时钟置换算法

- CLOCK

## 改进型CLOCK算法

- 



