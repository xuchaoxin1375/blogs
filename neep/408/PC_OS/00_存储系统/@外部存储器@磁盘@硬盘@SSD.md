@[toc]
# PC_OS@磁盘HDD_SSD@存储介质(材料工艺)@性能指标@磁盘调度算法

## 外存

- 辅助存储器作为主存的后援设备又称为外部存储器,简称**外存**
- 它与主存一起组成了**存储器系统**的主存～辅存层次。
- 与主存相比,辅存具有容量大,速度慢﹑价格低、可脱机保存信息等特.点,属“非易失性”存储器。
- 而主存具有速度快﹑成本高、容量小等特点,而且大多由半导体芯片构成,所存信息无法永久保存,属“易失性”存储器。
- 计算机系统的辅助存储器有
  - 硬磁盘、软磁盘、磁带﹑光盘等。
- 前三种均属**磁表面存储器**。

## 磁盘存储器

- hdd(hard disk drive)

  - [Hard disk drive - Wikipedia](https://en.wikipedia.org/wiki/Hard_disk_drive)
  - [Operating Systems: Mass-Storage Structure (uic.edu)](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/10_MassStorage.html)
  - [How Hard Disk works, Internal structure and Read/Write data operations – Tech mastery (wordpress.com)](https://technicalmasterblog.wordpress.com/2019/02/22/how-hard-disk-works-internal-structure-and-read-write-operations-data/)

- ssd(solid-state drive)

  - [固态硬盘_百度百科 (baidu.com)](https://baike.baidu.com/item/固态硬盘/453510)
  - [Everything You Need to Know About Solid-state drive (SSD) - Guide (minitool.com)](https://www.minitool.com/lib/ssd.html)
  - [Solid-state drive - Wikipedia](https://en.wikipedia.org/wiki/Solid-state_drive)
  - [Coding for SSDs – Part 2: Architecture of an SSD and Benchmarking | Code Capsule](https://codecapsule.com/2014/02/12/coding-for-ssds-part-2-architecture-of-an-ssd-and-benchmarking/)

  

- | ![在这里插入图片描述](https://img-blog.csdnimg.cn/f968b90501234ff19e110cc689e017e4.png) | ![](https://img-blog.csdnimg.cn/643d8cd3b4474a4686ff570bf3bd4459.png) |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  |                                                              |                                                              |
  | ![在这里插入图片描述](https://img-blog.csdnimg.cn/3193187ec1214deea6af6629e613c9b3.png) | ![在这里插入图片描述](https://img-blog.csdnimg.cn/5b4cefabcc3c4dd98563352d6678cc3b.png) |
  | **Exploded line** drawing of a modern hard disk, showing the major components.<br />现代硬盘的分解线图，显示了主要部件 <br />[ref link](https://www.karlstechnology.com/blog/hard-disk-operational-overview/explodedviewharddrive/) | Architecture of a solid-state drive(SSD)                     |

  



### 组成

#### 磁盘驱动器

- 磁盘驱动器/磁盘:由磁头,磁盘读写电路等组成,简称为**磁盘**
- 核心部件:
  - 磁头组件
  - 盘片组件
- 温彻斯特盘:
  - 可以移动磁头,固定盘片的磁盘存储器

#### 磁盘控制器

- 硬盘存储器和主机的**接口**
- 内部包含两个接口
  - 对主机的接口(系统级)
  - 对硬盘设备的接口(设备级)
    - 又称**设备控制器**
- 主流标准:
  - IDE
  - SCSI
  - SATA

#### 盘片platter

- 一个磁盘（如一个 1T 的机械硬盘）由多个盘片叠加而成 
- 盘片的表面涂有磁性物质，这些磁性物质用来记录二进制数据 
- 因为正反两面都可涂上磁性物质，故一个盘片可能会有两个**盘面**(surfaces of platter)  

### 存储区域

- 一块硬盘含有若干**记录面**
- 每个记录面划分为若干**磁道**(一系列的同心圆环)
- 每条磁道划分为若干**扇区(块)**

### 磁盘结构



#### 磁道track

- 每个**盘片**被划分为一个个磁道
- 磁盘各**磁道**的上所记录的信息量是相同的
  - 但是**位密度**不同
- 一般泛指磁盘位密度时,指的是内圈磁道上的位密度(最大位密度)

##### 道距

- 响铃两条磁道中心线之间的距离称为道距P
- 道密度$D_t=\frac{1}{P}$
  - 密度Density
  - $D_t$:Density Of Track

##### 位密度

- $D_b=\frac{f_t}{\pi{d_{min}}}$
- $f_t$:每条道(track)上的总位数(bits)
- $d_{min}$:道(track)轨迹 同心圆的最小直径

#### 扇区sector🎈/块Block🎆

- 每个磁道又划分为一个个扇区 
  - 扇区中包含
    - 数据
    - 地址
    - 校验
    - ....等信息
- 磁盘读写的**最小单位**是**扇区**(或者称为**块**)🎈
  - 磁盘按**块**存取
  - 不同于主存,可以读取字节
- 其中，<u>最内侧磁道上的扇区面积最小</u>，因此**数据密度最大** 

- **扇区数**:表示**每条磁道**上有多少个扇区

#### 磁头(Head)

- **磁头**用于读取/写入盘片上记录的信息
- 磁头数即记录面数,表示磁盘有多少个**磁头**
- <u>一个记录面对应一个磁头🎈</u>

#### 圆柱面cylinder

- 在一个盘组中,<u>不同**记录面**</u>的**相同编号(位置)**的诸多<u>磁道</u>构成一个**圆柱面**
  - 所有盘面中<u>相对位置相同的磁道</u>组成柱面 
  - 空间几何上可以类比**圆柱体的侧面**
  - 不同**柱面**底面半径各不相同

- 每个**盘面**对应一个**磁头** 所有的磁头都是连在同一个**磁臂**上的，因此<u>所有磁头只能“共进退”</u> 
- **柱面数**:表示硬盘**每面**上有多少条**磁道**

## 磁记录原理

- 磁头和磁性记录介质**相对运动**时,通过**电磁转换**完成读写操作
- 编码方法
  - 按照某种方案,把一连串的二进制信息变换称存储介质磁层中一个磁化翻转状态序列
  - 使得读写电路容易/可靠地实现转换
- 磁记录方式:
  - 通常采用调频FM和改进型调频制MFM的方式记录

## 磁盘类型分类

- 磁盘按不同的方式可分为若干类型：
  - 磁头相对于盘片的**径向方向固定**的，称为**固定头磁盘**，每个磁道一个磁头：
  - 磁头可移动的，称为**活动头磁盘**，**磁头臂可来回伸缩定位磁道**：
  - 磁盘永久固定在磁盘驱动器内的，称为固定盘磁盘；
  - 可移动和替换的，称为可**换盘磁盘**。
- 操作系统中几乎每介绍一类资源及其管理时，都要涉及一类调度算法。
- 用户访问文件，需要操作系统的服务，文件实际上存储在磁盘中，操作系统接收用户的命令后，经过一系列的检验访问权限和寻址过程后，最终都会到达磁盘，控制磁盘把相应的数据信息读出或修改。
- 当有多个请求同时到达时，操作系统就要决定先为哪个请求服务，这就是磁盘调度算法要解决的问题。

## 磁盘性能指标

### 记录密度 🎈

- 记录密度是指盘片单位面积上记录的二进制信息量，
- 通常以道
  - 密度
  - 位密度
  - 面密度
  - ....表示
- 道密度是沿<u>磁盘半径方向</u>**单位长度**上的<u>磁道数</u>，
- 位密度是<u>磁道</u>**单位长度**上能记录的**二进制代码位数**，
- 面密度是<u>位密度和道密度</u>的乘积 

### 磁盘的容量🎈

- 磁盘容量有**非格式化容量**和**格式化容量**之分 

#### 非格式化容量

- 是指磁记录表面<u>可利用的磁化单元总数</u>，
- 它由道密度和位密度计算而来;
- 称为**硬盘容量**

#### 格式化容量

- 是指按照<u>某种特定的记录格式</u>所**能存储信息的总量** 

- 格式化后的容量比非格式化容量**要小** 🎈
- 称为格式化后的**实际容量**(有效容量)(用户可以使用的容量)



### 数据传输率🎈

- 磁盘存储器在**单位时间**内**向主机传送数据的字节数**，称为**数据传输率** 

- 设

  - 磁盘转数为**r转/秒**

  - 每条磁道容量N字节

    - 设扇区容量为$V_{sec}$
    - 每个磁道有$N_{sec}$
    - $N=V_{sec}N_{sec}$

  - 则数据传输率(DataRate:$D_r$)为

    - $$
      D_r=rN=rV_{sec}N_{sec}
      $$

#### 磁盘转速

- 表示单位时间内磁盘完成几个周(round)的旋转
- 通常用
  - $r转/秒或者m转/分钟表示$
    - $m转/分钟=\frac{1}{60}m转/秒$

#### 旋转周期T

- 有时也用**旋转周期时间**$T_r,简化记为T$来描述磁盘转速:

  - 完成一转(round)需要的时间 

  - $ 1round:1T$

  - $T=1/r$

    - r表示磁盘转速是r转/秒
  
  - 如果知道转速为:m 转/分钟:
  
    - 化为`转/秒`为单位:$r=\frac{m}{60}转/秒$
  
    - $$
      m\ round:1\ min
      \\1r:\frac{1}{m}min=\frac{60}{m}s
      $$

      
  
      - 根据周期的定义,$T=\frac{1}{m}min=\frac{60}{m}s$
  

#### 扇区时间

- 指磁头扫过一个扇区耗费的时间

- 设转速为r转/秒,磁盘的每磁道被分为n个扇区,

- 那么扇区时间为

  - $T_u=(1/n)/r=\frac{1}{nr}$
    - $u=\frac{1}{n}$表示每个扇区相当于$\frac{1}{n}$圈(转)
  - 旋转一周的时间,(磁盘旋转周期$T=nT_u=\frac{1}{r}$)

  



#### 例

- 某磁盘转速为7200 round/min

- 每个磁道上有160扇区(sectors)

- 每扇区512字节

- 理想情况下的传输速率DataRate?

  - $$
    D_r=\frac{7200\times{160}\times{512B}}{60s}=(9600K)B/s
    $$

  

### 平均存取时间🎈

- 平均存取时间由一下几个部分构成

  
  

#### 寻址时间

- 包括两部分,并且都是取平均值的
- 注意,寻址不同于寻道,前者基于后者还要进一步寻找具体扇区

##### 寻道时间$T_s$

- 磁头寻找目标磁道的时间(寻道时间$t_s$)

  - search track

    

##### 旋转延迟时间$T_w或T_r$

- 找到磁道后,磁头等到(**欲读写的**)<u>磁道区段</u>旋转到<u>磁头下方</u>所需要(旋转延迟时间或等待时间$t_w$)
  - wait sectors
  - rotate to sectors

#### 传输时间$T_t$@纯读/写时间

- 从磁盘读出或者向磁盘写入数据所经历的时间

- 这个时间取决于

  - 每次读写的字节数b

  - 磁盘的旋转速度r

    - 每秒的转数(圈数)

  - 一个磁道上的字节数N

  - $$
    T_t=\frac{b}{rN}
    $$

    

- 磁头从需要读取的若干个扇区中的第一个扇区开始旋转到结束扇区的这段时间

- 想时间不考虑延迟和寻道的时间(只计算直接读取所需要扇区的时间)

  - 即,机械运动操作的时间都以0处理

### 取平均值

- 由于**寻道和找扇区**的<u>距离远近不一</u>，故**寻道时间**和**旋转延迟时间(扇区定位)**通常取**平均值** 

  - 从<u>最外圈磁道找到最内圈磁道</u>以及 <u>寻找相邻磁道磁道</u>所需要时间是不等的

  - 磁头等待不同区段所花费时间也是不等的


- 取平均值作为平均寻址时间$T_a$
  - $T_a=t_{sa}+t_{wa}$
    - 下标解释:
      - a:average(平均)
      - sa表示平均寻道(search track)时间
      - wa:平均等待时间
    - $T_{sa}=\frac{1}{2}(t_{smax}+t_{smin})$
    - $T_{wa}=\frac{1}{2}(t_{wmax}+t_{wmin})$
  - 设转速为r,那么$T_{wa}=\frac{1}{2}{(0+1/r)}=\frac{1}{2r}$
    - 1表示1圈
    - r表示单位时间旋转的圈数是r圈

- 另一个角度推导(下的推导就是一个大概,全概率公式)

  - 平均查找扇区的时间定为磁盘旋转一周的时间的一半
  - 设磁道上有n个扇区
  - 移动到相邻扇区时间为$t_0$
  - 磁盘旋转一周的时间T=$nt_0$
  - 平均访问时间$T_a=\frac{1}{n}\sum\limits_{i=0}^{n-1}i\cdot t_0=\frac{1}{n}\frac{n(n-1)}{2}t_0=\frac{1}{2}{(n-1)}t_0\approx\frac{1}{2}nt_0=\frac{1}{2}T$
  - 把定位时间记为$T_{sec}=\frac{1}{2}{T_r}$

  



#### 总时间(平均化)



- $$
  T_{avg}=T_{track}+T_{sec}+T_{trans}+T_{ctrl}
  $$

  

  

- 寻道时间($T_{track}或T_{search}$,简记为$T_s$)（磁头移动到目的磁道的时间)
  - $T_s=kv+d$
    - k表示某次寻道跨越了k个磁道
    - v表示跨越磁道的速度(常数指标)
    - d表示启动磁臂的时间,(一般大约2ms),有时候忽略掉
  - 不过往往直接给出$T_s$
- 磁道内扇区定位时间($T_{sec}$):<u>旋转延迟时间</u>（磁头定位到要读写**扇区**的时间）
  - sec:sector Delay
- 磁盘控制器延迟($T_{ctrl}$)
  - ctrl:Controller Delay
  - 有些地方会忽略处理这部分耗时
- 传输时间$T_{trans}$（传输数据所花费的时间）
  - data transfer time
- 🎈简单写就是$T_a=T_s+T_r+T_t=T_s+\frac{1}{2r}+\frac{b}{rN}$
  - 举一个具体例子来说明这个公式
    - 设某磁盘的每个磁道都有n个扇区
    - 假设某次访存需要读取磁道t的第i个扇区到第j个扇区(的连续区域),记为[i,j]
      - 其中含有u=j-i+1个扇区块
    - 那么
      - $T_s$表示找到磁道t花费的时间(平均时间)
      - $T_r=\frac{1}{2r}$表示磁头定位到扇区i所耗费的时间
      - $T_t=b/(rN)$表示磁头从扇区i扫过扇区j这个区间(u个扇区块)耗费的时间(也就是传输数据的时间)
      - 容易看到$T_r,T_t$都是和磁盘转速密切相关的物理量!
  - 假设某次访问磁盘要读取某个磁道的n个扇区,那么计算公式退化为$T_a=T_s+1/r$
  - 更一般的,如果要访问的字节数为b字节(可能分布在不同的磁道上),每个磁道含有的字节数为N,
    - 那么访问时间为$T_a=(T_s+1/r)\frac{b}{N}$

#### 例

- 已知某磁盘的平均转速为**p秒/转**，平均寻找时间为T秒，每个磁道可以存储的字节数为N,

  - p秒/转
    - p秒:1转
    - 1转:p秒
    - 也就是旋转周期T=p秒,利用旋转周期也可以衡量磁盘速度
    - 磁盘转速r=(1/p)转

- 现向该磁盘读写b字节的数据，采用随机寻道的方法，**每道的所有扇区组成一个簇**，

- 其平均访问时间是:(p+T)b/N

- 分析

  - 将每道的所有扇区组成一个簇，意味着可以将一个磁道的所有存储空间组织成一个数据块组，这样有利于提高存储速度。

  - 读写磁盘时，磁头首先找到磁道，称为寻道，然后才可以将信息从磁道里读出或写入。

  - 读写完一个磁道后，磁头会继续寻找下一个磁道，完成剩余的工作，

  - 所以在随机寻道的情况下，**读写一个磁道的时间要包括寻道时间和读写磁道时间**，即T+r秒(平均时间)

  - 由于总的数据量是b字节，它要占用的磁道数为b/N个，所以总平均读写时间为(r+T)b/N秒。

    

#### 例

- 磁盘转速为V=7200 round/min

  - $T=\frac{60}{7200}s=(1/120)s$
  - 则:扇区定位**平均**时间$T_{sec}=\frac{1}{2}T=\frac{1}{240}s\approx{0.00417}s=4.17ms$

- **磁盘平均寻道**$T_{track}$时间为8ms

- 每一个磁道有n=1000扇区,那么读取一个扇区的纯读取时间为

  - $$
    \frac{1}{n}T=\frac{1}{1000}\frac{1}{120}
    =0.083\times10^{-4}s
    \\
    =0.083\times{10^{-1}\times{10^{-3}}}s
    =0.0083ms
    \\
    \approx{0.01}ms
    $$

    

  - 因此:读取一个扇区的读取时间大约为0.01ms

- 访问一个扇区的平均存取时间为?

  - S=寻道时间+扇区定位时间+纯读写时间=8ms+4.17ms+0.01=12.18ms

    



#### 例

- 设某磁盘
  - 磁盘的平均寻道时间为6ms
  - 磁盘传输速率为$D_r$=20MB/s
  - 磁盘控制器延迟为0.2ms
  - 扇区大小$V_{sec}=4KB$
- 又设该磁盘转速为$10^4$round/min
  - 工作周期为:$T=\frac{1}{10^4}min=60\times{10^{-4}}s=6\times{10^{-3}s}=6ms$
  - 平均磁道内扇区定位时间为$T_{sec}=\frac{1}{2}T=3ms$
- 读取一个扇区的**理想时间**(纯读取时间):
  - $T_{read}=\frac{V_{sec}}{D_r}=\frac{4KB}{20MB/s}=\frac{1}{5K}s=0.2ms$
  - 理想时间不考虑延迟和寻道的时间(只计算直接读取所需要扇区的时间)
    - 即,机械运动操作的时间都别设想为0
- 读取总时间(包括延迟)
  - 寻道时间+扇区定位时间+控制器延迟时间+理想读取时间
  - t=6+3+0.2+0.2=9.4ms

## 磁盘调度算法@寻道时间优化策略

- 在磁盘存取时间的计算中，**寻道时间**与<u>磁盘调度算法</u>相关：
- 而**延迟时间**和**传输时间**都与磁盘旋转速度相关，且为线性相关，
  - 所以在硬件上，**转速**是**磁盘性能的一个非常重要的参数**。
- 下列的算法,对于手算问题,采用数轴法折现示意图可以高效求解磁道移动数量

### FCFS

- 先来先服务(First Come First Served,FCFS)算法

- FCFS算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法，

- 该算法的优点是具有公平性。

- 若只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能：

- 若有大量进程竞争使用磁盘，则这种算法在性能上往往接近于随机调度。

- 所以，实际磁盘调度中会考虑一些更为复杂的调度算法。

- 例如

  - 磁盘请求队列中的请求顺序分别为55,58,39,18,90,160,150,38,184，磁头的初始位置是磁道100，

  - 采用FCFS算法时磁头的运动过程中,磁头共移动了（45+3+19+21+72+70+10+112+146)=498个磁道，平均寻找长度=498/9=55.3.

  - $$
    s=\sum_{i=1}^{n}{\Delta_{i}}
    \\t_i表示t_{track_i},表示第i次访问的磁道
    \\
    \Delta_i=|t_i-t_{i-1}|
    \\定义t_0为初始磁道位置
    $$

    

### SSTF

- 最短寻找时间优先(Shortest Seek Time First,,SSTF)算法
- SSTF算法选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以便使每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但能提供比FCFS算法更好的性能。
- 这种算法会产生“饥饿”现象。如 若某时刻磁头正在18号磁道，而在18号磁道附近频繁地增加新的请求，则SSTF算法使得磁头长时间在18号磁道附近工作，将使184号磁道的访问被无限期地延迟，即被“饿死”。
- 例如，
  - 磁盘请求队列中的请求顺序分别为55,58,39,18,90,160,150,38,184，磁头初始位置是磁道100，采用SSTF算法时磁头的运动过程
  - 磁头共移动了10+32+3+16+1+20+132+10+24=248个磁道，平均寻找长度=248/9=27.5.

### SCAN

- 扫描(SCAN)算法（又称电梯调度算法）

- SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象，实际上就是在最短寻找时间优先算法的基础上规定了磁头运动的方向,

- 由于磁头移动规律与电梯运行相似，因此又称电梯调度算法。

- 假设访问序列(磁道号(而非扇区号))为S0=$A_1,\cdots,A_i,\cdots,An$

  - 序列中理论上不应该(不必要)出现重的磁道(没有相等的元素,除非条件刻意强调)
  - 因为,对于某个确定的(有限的)访问序列,可以在磁头到达某个磁道后将所有需要所有块一并读出到内存
    - 之后的若干次访存即可,而不需要重复访问磁盘(相同磁道(以及该磁道上的任何扇区))

  - 假设S1是对S0排序后的结果序列$B_1,\cdots,B_i,\cdots,Bn$

- $A_0$表示初始磁头所在的磁道号

- 典型情况

  - 如果序列S0中同时存在$Ap<A_0$和$Aq>A_0$
  - 那么,SCAN算法<u>至少引入一次空服务端点转折</u>
  - 实际磁道的访问序列从$B_i\to\cdots{\to}{B_n}\to{B_j}\cdots\to{B_1}$
    - $B_i=A_0$
    - $B_j<A_0$

- SCAN算法对最近扫描过的区域不公平，因此它在访问局部性方面不如FCFS算法和SSTF算法好。

- 例如

  - 磁盘请求队列中的请求顺序分别为55，58,39，18，90，160，150，38，184，磁头初始位置是磁道100。采用SCAN算法时，不但要知道磁头的当前位置，而且要知道磁头的移动方向，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程 :

  - 移动磁道的顺序为100,150,160,184,200,90,58,55,39,38,18。

  - 磁头共移动了（50+10+24+(16+110)+32+3+16+1+20）=282个磁道，平均寻道长度=282/9=31.33

    






### C-SCAN

- 循环扫描（CircularSCANC-SCAN）算法
- 在**扫描算法**的基础上规**定磁头单向移动**来提供服务，**回返**时**直接快速移动至起始端**而不服务任何请求。
- 由于SCAN算法**偏向于处理那些接近最里或最外的磁道的访问请求**
- 所以使用改进型的C-SCAN算法来避免这个问题(C-SCAN可以同时兼顾最内到和最外道及其附近磁道的访问)
- 采用SCAN算法和C-SCAN算法时，磁头总是严格地遵循从**盘面的一端到另一端**
- 假设访问序列(磁道号(而非扇区号))为S0=$A_1,\cdots,A_i,\cdots,An$

  - 假设S1是对S0排序后的结果序列$B_1,\cdots,B_i,\cdots,Bn$
- $A_0$表示初始磁头所在的磁道号
- 如果序列S0中同时存在$Ap<A_0$和$Aq>A_0$
- 实际磁道的访问序列从$B_i\to\cdots{\to}{B_n}\to{B_1}\to\cdots\to{B_k}$

  - $B_i=A_0$
  - $B_k<A_0$
- 那么C-SCAN算法至少会分别经过一次磁盘最外道和磁盘最内道(2次空服务转折)

  - <u>至少引入2次空服务端点转折</u>
- 例如
  - 磁盘请求队列中的请求顺序为55,58,39,18,90,160,150,38,184，磁头初始位置是磁道100。
  - 磁道号范围为0$\sim$200
  - 采用C-SCAN算法时，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程
  - 移动磁道的顺序为100,150,160,184,200,0,18,38,39,55,58,90。
  - 磁头共移动50+10+24+16+200+18+20+1+16+3+32=390个磁道，
    - 速算(200-100)+(200-0)+(90-0)=390
    - 具体看C-LOOK处的总结C-SCAN的边界出有些不同,其余大致相同
  - 平均寻道长度=390/9=43.33.
- 但是,通常的SCAN算法和C-SCAN算法指的是它们的改进版本:LOOK和C-LOOK

### LOOK@C-LOOK

- SCAN和C-SCAN在实际使用时还可以改进，即**磁头移动只需要到达最远端的一个请求即可返回**，<u>不需要到达磁盘端点</u>。
  - 注意最**远端请求**和**磁盘端点(**最内到或最外道)是两回事
  - 最远端请求的取值和具体的磁道访问序列有关,其取值限界也不超过最内道和最外道
- 这种形式的SCAN算法和C-SCAN算法称为LOOK调度和C-LOOK调度
- 🎈LOOK磁头移动过的磁道数:
  - 以序号增大的方向为例
    - 最靠近$A_0$的磁道被最先访问

    - 最小号磁道最后被访问

  - $(B_n-B_i)+(B_n-B_1)$
    - $B_i就是A_0$
- 🎈C-LOOK
  - $(B_n-B_i)+(B_n-B_1)+(B_i-B_1)$


####  例

- [2015统考真题]某硬盘有200个磁道(**最外侧磁道号为0**)，
- 磁道访问请求序列为130,42,180,15,199,当前磁头位于第58号磁道并从外侧向内侧移动。
- 按照SCAN调度方法处理完上述请求后，磁头移过的磁道数是（）。
  - A.208
    B.287
    C.325
    D.382

- 分析
  - SCAN算法就是电梯调度算法。
  - 默认用的是其改进版本(LOOK)算法
  - 顾名思义，若开始时磁头向外移动，就一直要到最外侧，然后返回向内侧移动，就像电梯若往下则一直要下到底层才会再上升一样。
  - 当前磁头位于58号并从外侧向内侧移动，
  - 磁道序列排序:(最外侧(0)):`[15,42,130,180,199]`(最内侧200)
    - 先依次访问130、180和199，然后返回向外侧移动，依次访问42和15，
  - 因此磁头移过的磁道数是(199-58)+(199-15)=325。

### 对比几种磁盘调度算法

- FCFS算法太过简单，性能较差，仅在请求队列长度接近于1时才较为理想；

- SSTF算法较为通用和自然：

- SCAN算法和C-SCAN算法在磁盘负载较大时比较占优势。

  |                    | 优 点                         | 缺 点                                       |
  | ------------------ | ----------------------------- | ------------------------------------------- |
  | FCFS算法           | 公平、简单                    | 平均寻道距离大,仅应用在磁盘I/O较少的场合    |
  | SSTF算法           | 性能比"先米先服务"好          | 不能保证平均寻道时间最短,可能出现"饥饿"现象 |
  | SCAN算法(LOOK)     | 寻道性能较好,可避免"饥饿"现象 | 不利于远离磁头一端的访问请求                |
  | C-SCAN算法(C-LOOK) | 消除了对两端磁道请求的不公平  | 总体较好                                    |

## 旋转延迟时间的降低策略

- 除减少寻找时间外，减少延迟时间也是提高磁盘传输效率的重要因素。
- 可以对盘面扇区进行交替编号，对磁盘片组中的不同盘面错位命名。
- 磁盘是连续自转设备，磁头读/写一个物理块后，需要经过短暂的处理时间才能开始读/写下一块。
- 假设逻辑记录数据连续存放在磁盘空间中
  - 若在盘面上按扇区交替编号连续存放，则连续读/写多条记录时能减少磁头的延迟时间：
  - 同柱面不同盘面的扇区若能错位编号，连续读/写相邻两个盘面的逻辑记录时也能减少磁头延迟时间。
- 理想的情况是不需要定位而直接连续读取扇区，没有延迟时间，这样磁盘数据存取效率可以成倍提高。
- 但由于读取扇区的顺序是不可预测的，所以延迟时间不可避免。 

## 传统磁盘性能优化小结

- 磁盘寻块时间分为
  - 寻址时间
    - 寻道时间
    - 延迟时间(即,寻扇时间)
  - 传输时间
- 寻道时间和延迟时间属于“找”的时间，凡是“找”的时间都可以通过一定的方法削减，
- 传输时间是磁盘本身性质(转速)所决定的，不能通过其他措施减少。
- 1)在磁盘上进行一次读写操作需要哪几部分时间？其中哪部分时间最长？
  - 在磁盘上进行一次读写操作花费的时间由寻道时间、延迟时间和传输时间决定。
  - 其中寻道时间是将磁头移动到指定磁道所需要的时间，延迟时间是磁头定位到某一磁道的扇区（块号）所需
    要的时间，传输时间是从磁盘读出或向磁盘写入数据所经历的时间。
  - 一般来说，寻道时间因为要移动磁臂，所以占用时间最长。
- 2)存储一个文件时，当一个磁道存储不下时，剩下部分是存在同一个盘面的不同磁道好，还是存在同一个柱面上的不同盘面好？
  - 寻道时间对于一次磁盘访问的影响是最大的，若存在同一个盘面的不同磁道，则磁臂势必要移动，这样会大大增加文件的访问时间，而存在同一个柱面上的不同盘面就不需要移动磁道，
  - 所以一般情况下存在同一个柱面上的不同盘面更好。

## 磁盘地址🎈

- 驱动器号
- 柱面号(磁道号)
- 盘面号
- 扇区号
- Note:
  - 如果不特别指明多个驱动器,一般一个磁盘内就考虑后面三个级别


### 例

- 假系统中有4个磁盘驱动器(需要2bit区分)
  - 每个驱动器带1个磁盘
    - 每个磁盘
      - 256个磁道$2^8=256$(需要8bit区分磁道)
      - 16个盘面(需要$\log_2{16}=4$bit区分盘面)(比如:磁盘带有8个双面盘片)
        - 每个盘面划分为16个扇区(需要4bit区分扇区)

- 每个扇区地址要2+8+4+4=18bit二进制代码

## 磁盘阵列RAID

- RAID(磁盘阵列(Redundant Array of Independent Disks)）
  - 是指将<u>多个独立的物理磁盘</u>组成一个<u>独立的</u>**逻辑盘**

  - 数据在多个物理盘上**分割交叉存储、并行访问**

  - 具有更好的
    - **存储性能**

    - 可靠性

    - 安全性 

- 在 RAID1~RAID5几种方案中，**无论何时**有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据**不会损坏**，提升了系统的**可靠性** 
  -  RAIDO:无冗余和无校验的磁盘阵列 
  -  RAID1:镜像磁盘阵列 
  -  RAID2:采用纠错的海明码的磁盘阵列 
  -  RAID3:位交叉奇偶校验的磁盘阵列 
  -  RAID4:块交叉奇偶校验的磁盘阵列 
  -  RAID5:无独立校验的奇偶校验磁盘阵列 
- RAID0
  - 把连续多个数据块交替地存放在不同物理磁盘的扇区中
  - 几个磁盘交叉并行读写，不仅扩大了**存储容量**，而且提高了**磁盘数据存取速度**
  - 但RAIDO没有容错能力 
    - 最基础的阵列方案
    - 没有引入冗余🎈
    - 其他几个级别都引入冗余或数据校验

- RAID1:
  - 为了提高可靠性，RAID1使两个磁盘同时进行读写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据 
  - 两个磁盘当一个磁盘使用，意味着容量减少一半 

- 提高RAID可靠性的方法
  - 磁盘镜像
  - 数据校验(比如:奇偶校验)

- 总之
  - RAID通过**同时使用多个磁盘**，提高了**传输率**;
  - 通过**在多个磁盘上并行存取**来大幅提高存储系统的**数据吞吐量**;
  - 通过**镜像功能**，提高**安全可靠性**;
  - 通过**数据校验**，提供**容错能力**

## SSD

- 固态硬盘（SSD)是一种基于闪存技术的存储器 
- 它与U盘并没有本质上的差别，只是容量更大，存取性能更好 
- 一个 SSD由一个或多个**闪存芯片**和**闪存翻译层**组成，
  - **闪存芯片**替代传统旋转磁盘中的**机械驱动器**，而闪存翻译层将来自CPU的逻辑块读写请求翻译成对底层物理设备的读写控制信号
  - **闪存翻译层**相当于扮演了**磁盘控制器**的角色 

### 存储介质🎈

- 固态硬盘的[存储介质](https://baike.baidu.com/item/存储介质?fromModule=lemma_inlink)分为两种
  - 一种是采用[闪存](https://baike.baidu.com/item/闪存?fromModule=lemma_inlink)（[FLASH](https://baike.baidu.com/item/FLASH?fromModule=lemma_inlink)芯片）作为[存储介质](https://baike.baidu.com/item/存储介质?fromModule=lemma_inlink)
    - 基于[闪存](https://baike.baidu.com/item/闪存?fromModule=lemma_inlink)的固态硬盘（[IDE](https://baike.baidu.com/item/IDE?fromModule=lemma_inlink)FLASH DISK、Serial ATA Flash Disk）：采用[FLASH芯片](https://baike.baidu.com/item/FLASH芯片?fromModule=lemma_inlink)作为存储介质，这也是通常所说的SSD。
      - 它的外观可以被制作成多种模样，
        - 例如：[笔记本硬盘](https://baike.baidu.com/item/笔记本硬盘?fromModule=lemma_inlink)、[微硬盘](https://baike.baidu.com/item/微硬盘?fromModule=lemma_inlink)、[存储卡](https://baike.baidu.com/item/存储卡?fromModule=lemma_inlink)、[U盘](https://baike.baidu.com/item/U盘?fromModule=lemma_inlink)等样式。
        - 这种SSD固态硬盘最大的优点就是可以移动，而且数据保护不受[电源控制](https://baike.baidu.com/item/电源控制?fromModule=lemma_inlink)，能适应于各种环境，适合于个人用户使用。
  - 另外一种是采用[DRAM](https://baike.baidu.com/item/DRAM?fromModule=lemma_inlink)作为[存储介质](https://baike.baidu.com/item/存储介质/486592?fromModule=lemma_inlink)。
    - 基于[DRAM](https://baike.baidu.com/item/DRAM?fromModule=lemma_inlink)的固态硬盘：采用[DRAM](https://baike.baidu.com/item/DRAM?fromModule=lemma_inlink)作为[存储](https://baike.baidu.com/item/存储?fromModule=lemma_inlink)介质，应用范围较窄。
      - 它仿效传统硬盘的设计，可被绝大部分[操作系统](https://baike.baidu.com/item/操作系统?fromModule=lemma_inlink)的[文件系统](https://baike.baidu.com/item/文件系统?fromModule=lemma_inlink)工具进行卷设置和管理，并提供工业标准的PCI和FC接口用于连接主机或者[服务器](https://baike.baidu.com/item/服务器?fromModule=lemma_inlink)。
      - 应用方式可分为SSD硬盘和SSD硬盘阵列两种。
      - 它是一种高性能的[存储器](https://baike.baidu.com/item/存储器?fromModule=lemma_inlink)，理论上可以**无限写入**，美中不足的是需要**独立电源来保护数据安全**。
      - DRAM固态硬盘属于比较非主流的设备
    - 最新还有[英特尔](https://baike.baidu.com/item/英特尔/305730?fromModule=lemma_inlink)的XPoint颗粒技术
      - 原理上接近[DRAM](https://baike.baidu.com/item/DRAM/149572?fromModule=lemma_inlink)，但是属于非易失存储。
      - 读取延时极低 ，并且有接近无限的存储寿命。
      - 缺点是密度相对[NAND](https://baike.baidu.com/item/NAND/4761?fromModule=lemma_inlink)较低，成本极高

## 闪存芯片/半导体盘🎈

- [闪存芯片_百度百科 (baidu.com)](https://baike.baidu.com/item/闪存芯片/10365487?fromModule=lemma_inlink&fromtitle=FLASH芯片&fromid=1636597)

### 分类

- **闪存**也有不同类型，其中主要分为**NOR型**和**NAND型**两大类。

- NOR型与NAND型闪存的区别很大

#### NOR型

- 闪存更像内存，有独立的[地址线](https://baike.baidu.com/item/地址线?fromModule=lemma_inlink)和数据线，但价格比较贵，容量比较小；

#### NAND型

- 更像硬盘，地址线和数据线是共用的I/O线，类似硬盘的所有信息都通过一条硬盘线传送一般，
- 而且NAND型与NOR型闪存相比，成本要低一些，而容量大得多。
- **内存**和**NOR型闪存**的基本[存储单元](https://baike.baidu.com/item/存储单元?fromModule=lemma_inlink)是bit，用户可以随机访问任何一个bit的信息。
- 而NAND型闪存的**基本存储单元是页（Page）**
  - （可以看到，NAND型闪存的页就类似硬盘的扇区，硬盘的一个扇区也为512字节）。
  - 每一页的有效容量是512[字节](https://baike.baidu.com/item/字节?fromModule=lemma_inlink)的倍数。
  - 所谓的有效容量是指用于数据存储的部分，实际上还要加上16字节的校验信息，因此我们可以在闪存厂商的技术资料当中看到“（512+16）Byte”的表示方式。
  - 2Gb以下容量的NAND型闪存绝大多数是（512+16）字节的页面容量，
  - 2Gb以上容量的NAND型闪存则将页容量扩大到（2048+64）字节。

### NAND型主要特点

- [NAND（计算机闪存设备）_百度百科 (baidu.com)](https://baike.baidu.com/item/NAND/4761?fromModule=lemma_inlink&fromtitle=NAND闪存&fromid=8051173)

- NAND型比NOR型更加常见,下面主要是关于NAND型的描述

- NAND(NAND flash memory)闪存是一种比硬盘驱动器更好的存储设备，在不超过4GB的低容量应用中表现得尤为明显。
- 结合了EPROM和EEPROM结构
- NAND闪存是一种非易失性存储技术，即断电后仍能保存数据。
- 它的发展目标就是降低每比特存储成本、提高存储容量。

#### EPROM

- EPROM是指其中的内容可以通过特殊手段擦去，然后重新写入。
- 常采用浮空栅雪崩注入式**MOS电路**，简称为FAMOS。
- 它与MOS电路相似 
- ....

#### EEPROM

-  与EPROM相似，它是在EPROM基本单元电路的浮空栅极的上面**再生成一个浮空栅**，前者称为第一级浮空栅，后者称为第二级浮空栅。

- ....

  

#### 速度

- 这里我们还需要端正一个概念，那就是闪存的速度其实很有限，它本身操作速度、频率就比内存低得多，而且NAND型闪存类似硬盘的操作方式效率也比内存的直接访问方式慢得多。
- 因此，不要以为闪存盘的性能瓶颈是在接口

- 前面提到NAND型闪存的操作方式效率低，这和它的架构设计和接口设计有关，
  - 它操作起来确实挺像硬盘（其实NAND型闪存在设计之初确实考虑了与硬盘的兼容性）
  - 它的性能特点也很像硬盘：小数据块操作速度很慢，而大数据块速度就很快，
  - 这种差异远比其他**存储介质**大的多。 

#### 擦除操作

- NAND型闪存以块为单位进行擦除操作。
- 闪存的写入操作必须在空白区域进行，如果目标区域已经有数据，必须先擦除后写入，因此**擦除操作是闪存的基本操作。**
- 一般每个块包含32个512[字节](https://baike.baidu.com/item/字节?fromModule=lemma_inlink)的页，容量16KB；
- 而大容量闪存采用2KB页时，则每个块包含64个页，容量128KB。

- 每颗NAND型闪存的[I/O接口](https://baike.baidu.com/item/I%2FO接口/2682517?fromModule=lemma_inlink)一般是8条，每条数据线每次传输（512+16）bit信息，8条就是（512+16）×8bit，也就是前面说的512字节。
- 但较大容量的NAND型闪存也越来越多地采用16条I/O线的设计，

#### 寻址

- 寻址时，NAND型闪存通过8条I/O接口数据线传输地址信息包，每包传送8位地址信息。
- 由于闪存芯片容量比较大，一组8位地址只够寻址256个页，显然是不够的，因此通常一次地址传送需要分若干组，占用若干个[时钟周期](https://baike.baidu.com/item/时钟周期?fromModule=lemma_inlink)。
- NAND的地址信息包括列地址（页面中的起始操作地址）、块地址和相应的页面地址，传送时分别分组，至少需要三次，占用三个周期。
- 随着容量的增大，地址信息会更多，需要占用更多的时钟周期传输，因此<u>NAND型闪存的一个重要特点就是容量越大，寻址时间越长。</u>
- 而且，由于传送地址周期比其他存储介质长，因此NAND型闪存比其他存储介质更<u>不适合大量的小容量读写请求</u>。

#### 小结

- NOR型闪存比较适合**频繁随机读写**的场合，通常用于存储程序代码并直接在闪存内运行，手机就是使用NOR型闪存的大户，所以手机的“内存”容量通常不大；
- NAND型闪存主要用来存储资料，我们常用的闪存产品，如闪存盘、数码存储卡都是用NAND型闪存。



##  SSD结构

-  一个闪存由B块组成，每块由Р页组成 

- | ![在这里插入图片描述](https://img-blog.csdnimg.cn/ca643ffc719a4f789033e2b5eaf965ff.png) | expload View Solid state Drive |      |
  | ------------------------------------------------------------ | ------------------------------ | ---- |

- 基于[闪存](https://baike.baidu.com/item/闪存?fromModule=lemma_inlink)的固态硬盘是固态硬盘的主要类别，其内部[构造](https://baike.baidu.com/item/构造?fromModule=lemma_inlink)十分简单

  - 固态硬盘内主体其实就是一块[PCB板](https://baike.baidu.com/item/PCB板/4717623?fromModule=lemma_inlink)，而这块PCB板上最基本的配件就是
    - 控制芯片
    - 缓存芯片（部分低端硬盘无缓存芯片）
    - 用于存储数据的[闪存芯片](https://baike.baidu.com/item/闪存芯片/10365487?fromModule=lemma_inlink)

### 主控芯片

-  主控芯片是固态硬盘的[大脑](https://baike.baidu.com/item/大脑?fromModule=lemma_inlink)，其作用
   - 一是合理调配数据在各个闪存芯片上的负荷，
   - 二则是承担了整个[数据](https://baike.baidu.com/item/数据/33305?fromModule=lemma_inlink)中转，连接闪存芯片和外部[SATA接口](https://baike.baidu.com/item/SATA接口/1491074?fromModule=lemma_inlink)。
   - 不同的<u>主控之间能力相差非常大</u>，在数据处理能力、算法，对[闪存芯片](https://baike.baidu.com/item/闪存芯片/10365487?fromModule=lemma_inlink)的读取写入控制上会有非常大的不同，直接会导致固态硬盘产品在<u>性能上差距高达数倍</u>。

### 缓存颗粒(辅助)

- [主控芯片](https://baike.baidu.com/item/主控芯片/9957744?fromModule=lemma_inlink)旁边是**缓存颗粒**，
  - 固态硬盘和传统[硬盘](https://baike.baidu.com/item/硬盘?fromModule=lemma_inlink)一样需要**高速**的**缓存芯片**辅助主控芯片进行数据处理。
  - 这里需要注意的是，有一些廉价固态硬盘方案为了节省成本，省去了这块[缓存](https://baike.baidu.com/item/缓存?fromModule=lemma_inlink)芯片，
    - 这样对于使用时的性能会有一定的影响，尤其是<u>小文件的读写性能和使用寿命上</u>。

### 闪存芯片(主体)

- 除了[主控芯片](https://baike.baidu.com/item/主控芯片?fromModule=lemma_inlink)和缓存芯片外，[PCB板](https://baike.baidu.com/item/PCB板/4717623?fromModule=lemma_inlink)上其余大部分位置都是[NAND Flash](https://baike.baidu.com/item/NAND Flash/4883033?fromModule=lemma_inlink)闪存芯片。

- [NAND Flash](https://baike.baidu.com/item/NAND Flash/4883033?fromModule=lemma_inlink)[闪存芯片](https://baike.baidu.com/item/闪存芯片/10365487?fromModule=lemma_inlink)又分为
  - SLC（Single-Level Cell，[单层单元](https://baike.baidu.com/item/单层单元/10955743?fromModule=lemma_inlink)） 
  - [MLC](https://baike.baidu.com/item/MLC?fromModule=lemma_inlink)（Multi-Level Cell，双层单元） 
  - TLC（Trinary-Level Cell，三层单元） 
  - QLC（Quad-Level Cell，四层单元）这四种规格。
  - 另还有一种eMLC（Enterprise Multi-Level Cell，企业多层单元）是[MLC NAND](https://baike.baidu.com/item/MLC NAND/112900?fromModule=lemma_inlink)闪存的一个“增强型”的版本，它在一定程度上弥补了SLC和MLC之间的性能和耐久差距。 

### 特点

- 通常，页的大小是512B~4KB，每块由32～128页组成，块的大小为16KB~512KB

- 数据是以**页**(page)为单位读写的 只有在一页所属的块全部被擦除后，才能写这一页 

  - 不过，一旦一个块被擦除，块中的每个页都可以直接再写一次 某个块进行了约10万次重复写之后，就会磨损坏，**不能再使用** 
  - **随机写比随机读慢得多**，有两个原因首先，
    - <u>擦除块比较慢</u>，1ms 级，比访问页高一个数量级
    - 其次，如果写操作试图修改一个包含已有数据的页P那么这个块中所有含有用数据的页都必须被复制到一个新（擦除过的）块中,才能进行对页P写

- 优点(比起传统磁盘)

  - 它由**半导体存储器**(而非磁介质存储器)构成，没有移动的部件，因而**随机访问时间**比机械磁盘要快很多，
    - 随机**写**比随机**读**慢,但是依然比机械操作的传统磁盘快得多
  - 也没有任何机械噪声和震动，
  - 能耗更低，
  - 抗震性好，
  - 安全性高等 

- 缺点

  - 因为反复写之后，**闪存块会磨损**，所以SSD也容易磨损 

- 闪存翻译层中有一个**平均磨损逻辑**

  - 试图通过**将擦除平均分布在所有的块上**来最大化每个**块**的寿命 

### SSD磨损均衡

- Wear Leveling
- 固态硬盘也有缺点，闪存的擦写寿命是有限的，一般是几百次到几千次。
- 如果读写数据时会集中在SSD的一部分闪存，这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块SSD也就损坏了。
-  为了弥补SSD的寿命缺陷，引入了磨损均衡。
- SSD磨损均衡技术大致分为两种
- 1)动态磨损均衡。
  - 写入数据时，自动选择较新的闪存块。 
- 2)静态磨损均衡。
  - 这种技术更为先进，就算没有数据写入，SSD也会监测并自动进行数据分配，
  - 让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，
  - 平常的读写操作在较新的闪存块中进行。
- 如此一来，各闪存块的寿命损耗就都差不多。
