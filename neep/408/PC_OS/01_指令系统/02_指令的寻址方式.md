[toc]

## 寻址方式

- 寻找**指令或者操作数**<u>有效地址</u>的方式,即,确定本条指令的**数据地址**以及<u>下一条指令的地址</u>的方法
  - 包含指令寻址和数据寻址两类
- 指令中断地址码字段不代表操作数的真是地址,则称这种地址为**形式地址(A)**
- 形式地址结合寻址方式可以计算出操作数在存储器中的真实地址(称为**有效地址**(EA))
- (A)表示地址为A的数值
  - A可以是寄存器编号
  - 也可以是内存单元地址
  - 对应的(A)就是寄存器中的数值(或相应内存单元的数值)
  - EA=(A)表示有效地址EA就是A处保存的值
  - (EA)就表示操作数本身

## 指令寻址

- 寻找下一条将要执行的指令地址称为指令寻址

  - 顺序寻址

  - 跳跃寻址

    - 如果发生跳跃,跳跃结果是当前指令修改PC值,所以下一条指令依然是通过PC给出
    - 但是PC中的值可能不再是默认+1的结果

    

## 数据寻址

- 寻找本条指令的(操作数)**数据地址**称为数据寻址

  - 在指令中表示一个操作数的地址

  - 并且如何用这种表示,得到操作数或者如何计算出操作数的地址

    - 将地址码字段进一步划分为**寻址特征**和**形式地址**

    - $$
      \begin{array}{|c|c|c|c|}
      \hline
      OP操作码&寻址特征&形式地址A\\
      \hline
      \end{array}
      $$

- 对于按字寻址的机器
  - 程序计数器PC的位数取决于存储器的容量(字数)
  - 指令寄存器的长度取决于指令字长

### 隐含寻址

- 不明显地给出操作数地址
  - 在指令中隐含操作数地址
- 特点:
  - 缩短指令长度
  - 由于隐地址不需要在指令中显式指出操作数地址,因此可以最大程度简化指令(地址)结构
  - 需要增加**存储操作次数**或者**隐含地址的硬件**
  - 这就是为什么隐含寻址的指令中虽然没有操作数地址码,但是速度并不快

### 立即数寻址🎈

- 这种类型的指令的**地址字段**指出的不是操作数地址,而是**操作数本身**,又称为**立即数**
- 特点:
  - 指令在执行阶段不访问主存,指令执行时间最短
    - 甚至不需要通过访问寄存器来获得操作数(地址),因此立即数寻址的速度**最快**
  - 缺点是位数**限制了立即数的范围**

### 直接寻址

- 指令中的形式地址A是操作数的真是地址EA
  - 即EA=A
- 特点:
  - 简单(在执行阶段仅需要访问一次主存,不需要专门计算操作数的**有效地址**)
  - A的位数决定了**指令操作数**的寻址范围,操作数的地址不易修改

### 间接寻址

- 相对于直接寻址而言的
- 设操作数为$x$
- $EA=(A)$
- $x=(EA)=((A))$
- 如果是2次间接寻址,那么:
  - EA=((A))
  - $x=(EA)=(((A)))$
- 依次类推
- 特点
  - 间接寻址可以扩大寻址范围
  - 形式地址A的位数往往比有效地址位数更少
  - 但是自行阶段需要多次访存
    - 每多1次间址,就需要多访存一次(根据**存储字的最高位**确定访问次数)
    - 这是非常坏的,效率很低

### 寄存器寻址

- 在**指令字**中直接给出**操作数**所在**寄存器编号**
  - $EA=R_i$($R_i$表示编号为i的寄存器,可以将$R_i$理解为地址,而且是可以高速访问的地址)
  - $x=(EA)=(R_i)$,$R_i$寄存器中的内容就是操作数$x$
- 特点:
  - 指令在执行阶段不需要访存只访问寄存器
    - 因为寄存器数量少,对应的地址码(寄存器编号)长度较小,使得指令字短,不需要访存
    - 支持向量/矩阵运算
  - 但是,寄存器价格高,寄存器的数量有限

### 寄存器间接寻址

- 

- 在寄存器$R_i$给出的表示操作数本身,而是操作数所在主存单元的地址

  - $EA=(R_i)$

  - $x=(EA)=((R_i))$

- 特点
  - 相比于一般间接寻址的速度快(第一次访问的地址是寄存器,速度快)
  - 指令执行阶段需要访问主存

### 相对寻址

- 将PC中的内容加上<u>指令格式中的形式地址A</u> ,形成操作数的有效地址EA
  - $EA=(PC)+A$
  - A是相对于当前指令地址的位移量
- 从公式上看,容易理解,A的位数决定了操作数的范围

- 相对寻址提供的**相对地址**实质上是:
  - 以**下一条指令**在内存中的**首地址**为**基准位置**的**偏移量**
  - 因为,寻址阶段位于取值阶段之后
    - 众所周知,取指阶段结束后,PC已经完成了自增,此时的PC内容是下一条(默认情况下)的指令的首地址
    - EA=(PC)+A正是在取指阶段后的寻址阶段执行的,因此,偏移量A是相对于当前正在执行的指令的下一条指令的首地址的偏移量
- 优点是:
  - 操作数的地址是不固定的
  - 它随着PC的变化而变化,且与指令之间总是相差一个**固定值**
- 相对寻址相对于多到程序设计最为重要
  - 多道程序设计中,各个程序段可能需要在内存中浮动
  - 相对寻址特别有利于程序浮动,广泛应用于**转移指令**🎈

### 基址寻址

- 将cpu中的**基址寄存器BR**的内容**加上**指令格式中的**形式地址A**形成的操作数有效地址EA
  - $EA=(BR)+A$
  - BR可以采用专用寄存器或者通用寄存器实现

- 特点
  - 基址寄存器BR是面向操作系统的
    - 内容有操作系统/管理程序确定
      - 采用通用寄存器作为BR时,虽然用户可以决定哪个GPR作为BR,但是内容依然有操作系统决定
    - 主要是用来解决**程序逻辑空间**和**存储器物理空间**的无关性
    - 程序执行过程中,BR的内容不变(作为**基地址**)
    - 形式地址**可以变**(作为偏移量)
  - 优点:
    - 可扩大寻址范围
      - BR的位数大于形式地址A的位数
    - 用户不必考虑自己的程序存于主存的哪个空间区域,**有利于多道程序设计**
      - 相对寻址也是有利于多道程序设计
      - 可以编制浮动程序,但偏移量(形式地址A)位数较短
      - 因此主要说相对寻址方式对于多道程序设计/浮动程序的设计最为重要

###  变址寻址

- $EA=(IX)+A$
  - 变址寄存器IX(index Register)
- 特点:
  - 变址寄存器面向用户
  - 在程序执行过程中,IX的内容可以作为偏移量,由用户改变
    - 偏移量的位数足以表示整个存储空间
  - 形式地址A不变(和基址寻址特点相反)
  - 也可以扩大寻址范围
  - 便于编制循环程序

### 堆栈寻址

- 堆栈是存储器(寄存器组)中一块特定的,按照后进先出(LIFO)的原则管理的存储区
- 该存储区中读写单元的**地址(指针)**是用一个特定的寄存器给出
  - 该寄存器称为**堆栈指针**
- 寄存器堆栈又称为硬堆栈
  - 成本高
- 从主存中划分一段区域来做堆栈称为软堆栈(比较常用)
- 在采用堆栈结构的计算机系统中,大部分指令表面上都表现为**无操作数**指令心事
  - 应为操作数地址都隐含使用了SP
  - 通常,在读写堆栈中的一个单元的前后,都便有自动完成对SP内容的增量/减量操作

### 小结

- $$
  \begin{array}{c|c|c}
  \hline \text { 寻 址 方 式 } & \text { 有 效 地 址 } & \text { 访 } \text { 存 次 数 } \\
  \hline \text { 隐含寻址 } & \text { 程序指定 } & 0 \\
  \hline \text { 立即寻址 } & \mathrm{A} \text { 即是操作数 } & 0 \\
  \hline \text { 直接寻址 } & \mathrm{EA}=\mathrm{A} & 1 \\
  \hline \text { 一次间接寻址 } & \mathrm{EA}=(\mathrm{A}) & 2 \\
  \hline \text { 寄存器寻址 } & \mathrm{EA}=\mathrm{R}_{i} & 0 \\
  \hline \text { 寄存器间接一次寻址 } & \mathrm{EA}=\left(\mathrm{R}_{i}\right) & 1 \\
  \hline \text { 相对寻址 } & \mathrm{EA}=(\mathrm{PC})+\mathrm{A} & 1 \\
  \hline \text { 基址寻址 } & \mathrm{EA}=(\mathrm{BR})+\mathrm{A} & 1 \\
  \hline \text { 变址寻址 } & \mathrm{EA}=(\mathrm{IX})+\mathrm{A} & 1 \\
  \hline
  \end{array}
  $$

- 













