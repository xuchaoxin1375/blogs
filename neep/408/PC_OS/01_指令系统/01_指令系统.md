[toc]

## 指令

- 指令,一般指**机器指令**,只是计算机<u>执行某种操作</u>的**命令**
- 指令集(指令系统):一台计算机的所有指令的**集合**,构成该**机器**的**指令系统**
- 指令系统是一台机器能够执行的指令全体
- 热呢和程序运行前都需要转为机器语言程序
- 指令系统是软硬件的界面,和机器语言是相关的(指令系统是计算机硬件的语言系统)

## 指令格式

- 一条指令是机器的一个语句

- 是一组二进制代码

- 一条指令通常包含

  - **操作码**字段

  - **地址码**字段

  - $$
    \begin{array}{|c|c|}
    \hline
    操作码字段&地址码字段(若干操作数的地址码)\\
    \hline
    \end{array}
    $$
    
  

### 操作码

- 指出指令应该执行什么性质的操作,具有何种功能
- 操作码是
  - 识别指令
  - 了解指令功能
  - 区分操作数地址内容的组成和使用方法等的关键信息

### 地址码

- **地址码**指出指令的以下方面信息(的若干个)
  - **源操作数**的地址(可以有若干个)
  - 结果的地址
  - 下一条指令的地址

- 地址码给出**被操作的信息**(指令或者数据)的地址,包括
  - 地址可以是内存地址,比如
    - 参与运算的一个或多个**操作数**所在地址
      - **操作数**本身可能是**地址**(比如跳转指令的跳转目标地址作为操作数Ad(IR)则可能是地址的地址)
    - 运算结果保存地址
    - 程序转移地址
    - 被调用子程序的入口地址
  - 可以是寄存器地址
  - 也可以是IO设备的地址

#### 地址码长度

- 地址码长度表示指令的每一个操作数地址占用的位数
  - 地址字段等于地址码
  - 地址码字段包含若干个地址码
  - 每个地址码对应一个指令所需要的操作数的地址
  - 指令需要的操作数不一定都体现在指令的地址码字段上
- 假设指令的地址码长度为x,那么对于一个二地址指令A而言,A的字**地址码字段**长度2倍**地址码**长度
- 区别地址码字段和地址码

### 指令的长度

- 一条指令包含的二进制代码的位数
  - 操作码的长度
  - 操作数地址码的长度
  - 地址数地址的个数

- 指令长度和机器字长没有固定关系
  - 通常把指令长度等于**机器字长**的指令称为单字长指令
  - 类似的,有半字长指令和双子长指令(基准长度是**机器字长**)

## 指令分类

### 定长和不定长指令结构

- 定长指令字结构
  - 如果**指令系统**的所有指令长度都是相等的,则称该指令集为**定长指令字结构**
  - 特点是:
    - 执行速度快
    - 控制简单
- 变长指令字结构
  - 指令集内的指令的长度随指令的功能而有所差异
  - 主存一般是按照字节编址,所以指令字长为字节的整数倍

### 操作数地址码数

- 指令中的**操作数地址码**的数目的不同,分为
- Note$\clubsuit$:指令字所包含的操作数地址码数不代表指令的操作数数量
  - 主要是某些指令具有**隐含的操作数**

#### 零地址指令

- 零地址:

  - $$
    \begin{array}{|c|}
    \hline
    OP\\
    \hline
    \end{array}
    $$

- 只给出操作码OP,没有显示地址

  - 不需要操作数的指令
    - 空操作指令
    - 停机指令
    - 关中断指令
  - 需要操作数的运算类指令
    - 仅用在堆栈计算机中
    - 通常参与运算的两个操作数隐含的从栈顶和次栈顶弹出,送到运算器进行运算
    - 在将结果隐含的压入堆栈

#### 一地址指令

- $$
  \begin{array}{|c|c|}
  \hline
  OP & A_1\\
  \hline
  \end{array}
  $$

  

- 这种指令也是有两种的形态(根据操作码来区分)

  - 只有目的地址的**单操作数指令**

    - 按照$A_1$读取操作数
    - 进行OP操作结果保存回**原地址**($A_1$)
    - $OP(A_1)\to{A_1}$

    - 例如:
      - 加1
      - 减1
      - 求反
      - 求补

  - 隐含约定目的地址的双操作数指令

    - 指令(操作数)地址码$A_1$读取源操作数
    - 指令可以隐含约定另一个操作数有ACC(累加寄存器)提供
      - 这类操作数来自于**隐含寻址**
    - 运算结果放回ACC中
    - $(ACC)\to{OP(A_1)}\to{ACC}$
    - 假设:
      - 指令字长32bit
      - 操作码占8bit
      - 操作数地址码占24bit
      - 指令的操作数的直接寻址范围为$2^{24}=16M$

#### 二地址指令

- $$
  \begin{array}{|c|c|c|}
  \hline
  OP&A_1&A_2\\
  \hline
  \end{array}
  $$

  

- 指令含义:$(A_1)OP(A_2)\to{A_1}$

- 对于常用的算数逻辑运算指令,往往要求2个操作数,需要分别给出<u>目的操作数</u>和<u>源操作数</u>的**地址**
- 其中**目的操作数地址**还**复用**作保存本次运算结果
  - 假设OP占8位,$A_1,A_2$都各占12位,那么操作数**直接寻址范围**为$2^{12}=4K$

#### 三地址指令

- $$
  \begin{array}{|c|c|c|c|}
  \hline
  OP&A_1&A_2&A_3\\
  \hline
  \end{array}
  $$

  - 指令含义$(A_1)OP(A_2)\to{A_3}$

- 如果指令字长32bit,操作码,以及三个**地址码**都是8bit,指令操作数的直接寻址范围为$2^8=256$

- 如果地址字段都是主存地址,则完成一条三地址指令需要4次访问存储器(1次是取指令,2次用来取操作数,1次保存结果,它们的先后顺序是严格的)

#### 四地址指令

- $$
  \begin{array}{|c|c|c|c|c|}
  \hline
  OP&A_1&A_2&A_3&A_4\\
  \hline
  \end{array}
  $$

  - $(A_1)OP(A_2)\to{A_3},A_4=Next$
    - Next:下一条将要执行的指令的地址

- 如果指令字长为32位,操作码OP占8bit,44个地址各占6bit

- 操作数的直接寻址范围$2^6=64$



## 定长操作码的指令格式

- 区分两条指令是不同的,关键是指令的**操作码**是不同的
  - 这可以体现在操作码二进制串
    - 长度
    - 各位是否相等(前缀)
      - 容易联想到haffman编码方法

- 在指令字的**最高位部分**分配固定的若干位表示操作码
- 一般n位操作码的指令系统能够表示$2^n$条指令
- 定长操作码对于简化计算机硬件设计,提高指令译码的速度有利
  - 当计算机字长为32位或者更长,这是常规用法

## 扩展操作码指令格式

- 为了在指令字长有限的前提下,仍然保持较多的指令种类,采取可变长度的**操作码**

- 指令系统的所有指令的操作码位数不固定
- 分散地存放在指令字的不同位置上
  - 这增加了译码和分析的难度
  - 使得控制器的设计复杂化
- 最常见的操作码是**扩展操作码**
  - 使得操作码的长度随地址码的减少而增加
  - 不同地址数的指令可以具有不同长度的操作码
  - 可以有效缩短指令字长

## 指令设计要点

- 不允许短码是长码的前缀
  - 即短操作码不可以是长操作码的前缀

- 不同指令的操作码不相同

  - 拥有较短的操作码的指令可以执行指令的复杂度不见得一定比较长操作码的指令来的简单(取决于计算机怎么设计的)

- 譬如,8位操作码的指令和12位操作码的指令之间的区分:

  - 12位操作码的指令的操作码的前8位不可以和8位操作码的指令的操作码有重复
  - 应该能够做到,cpu要取具有8位操作码指令的时候,仅仅根据指令的前八位操作码,就可以认出该指令是不是8位操作码指令(而不是4位操作码指令或者12位操作码指令)
    - (从上例途中的安排方式)我们也可以看出,从(0\~3)位操作码我们可以排除4位操作码的指令;从(4\~7)位操作码我们可以排除具有超过8位操作码的指令

- 另外,对于**长操作码的指令**的分配会减少**短操作码指令**的(数目)

- 通常,将使用频率较高的指令分配较短的操作码,对使用频率较低的指令分配较长的操作码

  - 有利于减少指令译码和分析的时间

    

### 例

- 假设有**指令字长**为16位

  - 采用变长操作码指令编制指令

  - 给出一个中可能的划分方案(要求每个操作数地址码占4位)

    - 3地址指令和x地址指令的数量:
      - $OP;A_1A_2A_3$
      - OP占4位,3个(操作数)地址码字段各占4位
      - 4位二进制数可以组合出16中情况($b_0\cdots{b_3}$)
      - 但是为了通过**扩展指令码**方式扩展指令码的种类数,不能够将16中码都用作三地址指令
      - 否则会造成无法区分3地址指令和x地址指令($x\in\set{0,1,2}$)
        - 比如某条二地址指令OP占了8bit(记为$b_0b_1\cdots{b_7}$)
        - $b_0\cdots{b_3}$这部分会和3地址指令中的**某一条**的操作码重合
        - 在机器读取到$b_0\cdots{b_3}$会无法区分到地是二地址还是三地址
        - 因此不能够将所有的$b_0\cdots{b_3}$都用于三地址指令
        - 至少需要保留其中的一个(或者更多)
        - 为了便于描述,我们假设保留下来的4位二进制码为
          - $c_0\cdots{c_3}$
          - 这样,当机器读取了某条指令的前4位就知道,该指令是不是一个三地址指令
          - 如果判断出来该指令不是三地址指令,继续测试是否为二地址指令
          - 类似的原因,如果要编址1地址指令,那么用于2地址指令的操作码也需要保留一个或者多个用于扩展操作码之用
          - 编制2地址指令的操作码时,所保留8bit记为$d_0\cdots{d_7}$
    - 特别的,0地址指令不需要预留扩展码
      - 因为0地址指令的所有位都是操作码的一部分,操作码无法继续扩展(位数)

    - 那么有可以这一年分配:
      - 15条三地址指令(OP:4)
        - $0000\sim{1110}$
      - 15条二地址指令(OP:8)
        - $1111\ 0000\sim{1111\ 1110}$
        - 即,前4bit都是三地址预留下来的1111(没有被占用)
        - 有所不同的在于第5$\sim$8位这4位
      - 15条一地址指令(OP:12)
        - $1111\ 1111\ 0000\sim{1111\ 1111\ 1110}$
        - 前8bit都是2地址指令预留下来的1111 1111
        - 有所不同的是9$\sim$12位
      - 16条0地址指令(OP:16)(所有为都别操作码占有,无需再预留)
        - 1111 1111 1111 0000$\sim$1111 1111 1111 1111
    - 处理上述的分配方案,还有其他的方案,
      - 不同的方案可以产生的总的指令条数不同
      - 如果3地址指令减少一条,那么二地址指令条数就可以增加一倍

  - 从操作码的长度角度来看,如果

    - 假设减少一条操作码长度为x的指令
    - 则可以多出多少条长操作码的指令?
  - 再举一种可行的分配方案
    - 15条三地址指令
      - $0H\sim{EH}$
    - 12条2地址指令
      - $F0H\sim{FBH}$
    - 63条1地址指令
      - $Fx0H\sim{FxF}H,x\in\set{C,D,E}$
      - $FF0H\sim{FFEH}$
      - $因此共有3\times{2^4}+15=48+15=64$
      - 不过也可以废弃掉某些范围内的操作码,比如只采用
        - $FE0H\sim{FFEH}$
        - 则只有16+15=31条一地址指令
    - 1条0地址指令
      - $FFF0H\sim{FFFFH}$

### 例

- 假设指令字长为16位

  - 每个操作数的地址码为k=6位

  - 根据地址码数,指令有三种格式

    - 0地址
    - 1地址
    - 2地址

  - 列表分析:

    - | x地址指令($x\in\set{0,1,2}$) | 操作码(字段)位数 | 地址码字段位数 | x地址指令条数 | 预留给$x-1$地址指令的编码数量 | x地址指令的数量上限(最大值) |
      | ---------------------------- | ---------------- | -------------- | ------------- | ----------------------------- | --------------------------- |
      | 2地址指令                    | 4                | 6+6            | $N_2$         | $R_1=2^4-N_2$                 | $2^4$                       |
      | $1地址指令$                  | 10               | 6              | $N_1$         | $R_2=2^6\times{R_1}-N_1$      | $2^6\times{R_1}$            |
      | 0地址指令                    | 16               | 0              | $N_0$         | $R_3=0$                       | $2^6\times{R_2}$            |

      - x地址指令表示指令字中地址码字段包含了几个操作数地址码
        - x不一定表示指令的操作数个数(因为某些指令的操作数是隐含的,不体现操作码字段中🎈)
        - 为了便于描述,将体现在指令的地址码字段中的操作数地址码称为**显式操作数地址码**
        - 此类问题我们不关心指令涉及到的操作数的个数
        - 只需要关心地址码字段的划分段数(显式操作数地址码)即可

    - 规律分析

      - 从表格中可以看出,如果x地址指令每预留一种编码给(x-1)地址指令,那么就会(**最多**)增加$2^k=2^6$条(x-1)地址指令
      - 如果考虑预留给x-2地址指令,那么还要减去预留数量

    - 此外,还可以从操作码位数的角度列表

      | 操作码位数                                     | max(该操作码长度下的最大数量指令数量)   | real(该操作码长度的实际分配数量) | residula(短操作码预留下来的"编码数量"<br />(可以扩展操作码)) |
      | ---------------------------------------------- | --------------------------------------- | -------------------------------- | ------------------------------------------------------------ |
      | 4bit                                           | $2^4$                                   | X(题目给的条件,已知)             | $2^4-X$                                                      |
      | $10(=4+6)bit$(扩展一个地址码之后,操作码的位数) | $(2^4-X)\times2^6$(6是单个地址码的长度) | M(待求未知数)                    | $(2^4-X)\times2^6-M$                                         |
      | $16(=4+6+6))bit$                               | $((2^4-X)\times2^6-M)\times2^6$         | Y(已知)                          | 0(此种指令操作码已经占用所以指令字长bit)                     |

    - $((2^4-X)\times2^6-M)\times2^6=Y$

  - 问

    - 如果操作码位数固定(所有指令的操作码位数一致)

      - 一地址指令有P条
      - 二地址指令有Q条
      - 那么有多少条0地址指令?
      - 解:
        - 由于采用固定操作码,应该考虑具有最长操作数地址码长度的情况为基准
        - 以保证确定下来的操作码位数是正常的
        - 操作码位数为16-6*2=4bit
        - 那么指令最多有$2^4=16条$
        - 0地址指令最多有$16-P-Q$条

    - 如果采用变长操作码编制指令,同时

      - 2地址指令有X种

      - 0地址指令有Y种

      - 问一地址指令最多有几种?

      - 解:

        - 设一地址指令最多有M种

        - 2地址指令预留给1地址指令的编码数量$R_1=2^4-X$

          - 1地址指令数量的最大值$M_1=R_1\times{2^6}$

        - 1地址指令预留给0地址指令的编码数量$R_2=M_1-M$

          - 0地址指令的最大数量$M_0=R_2\times{2^6}$

        - 现在,有告诉你已知0地址指令的数量是Y

        - 则

          - $$
            Y\leqslant{M_0=R_2\times2^{6}=(M_1-M)\times{2^6}}
            \\=(R_1\times2^6-M)\times{2^6}
            \\=((2^4-X)\times{2^6}-M)\times{2^6}
            $$

            

          - 从而$M\leqslant{2^6(2^4-X)}-2^{-6}Y$

        - 一地址指令最多有: ${2^6(2^4-X)}-2^{-6}Y$

### 例

- 计算机按照字节编址(意味着指令字长应该是8bit的倍数)
  - 在遇到不足8bit的情况下应该补足,最少的位数,使其满足8的倍数
  - 假设某指令字长为x>0,那么需要补充的位数为$(8-x\%8)\%8$
- 某计算机按照字节编址,指令字长固定
  - 且只有两种格式:
    - 三地址指令29条
    - 二地址指令107条
    - 每个地址字段为6位
    - 则指令字长至少为多少位?
  - 分析:
    - 记操作码位数为OP
    - 则指令格式包含:
      - $OP;A_1,A_2$
      - $OP;A_1,A_2,A_3$
    - 由于最多地址的指令(三地址指令)有29条
      - $2^4<29<2^5$
      - 操作码至少5位
    - 检验5bit的操作码是否满足二地址指令的数量:
      - 二地址指令数量的最大值:$(2^5-29)2^6=3\times{64}=192>107$
      - 可见,5bit操作码足够了
    - 现在统计指令字长:5+6+6+6=23
    - 而根据**按字节编址**的要求,指令字长应该为要补齐为最近的8bit整数倍
    - 即24位

## 指令的操作类型

- 按照功能划分

  - 数据传送
    - 寄存器之间的传送MOV
    - 内存单元读取数据到cpu寄存器LOAD
    - 从cpu寄存器写数据到内存单元中STORE
  - 算数和逻辑运算
    - 加(ADD)
    - 减(SUB)
    - 比较(CMP)
    - 乘(MUL)
    - 除(DIV)
    - 加1(INC)
    - 减(DEC)
    - 与(AND)
    - 取反(NOT)
    - 异或(XOR)
    - ...
  - 移位操作
    - 算数移位
    - 逻辑移位
    - 循环移位
  - 转移操作
    - 无条件转移JMP
      - 在任何情况下都执行转移操作
    - 条件转移(BRANCH)
      - 简写为BAN
      - 满足条件的情况下执行转移操作
      - 转移条件一般是某个标志位的值(或者某些个标志组合)
      - 例🎈
        - 条件转移指令bgt(无符号整数比较**大于**时转移)
        - 机器中有一个标志寄存器FR(PSW):
          - 包括进位/借位CF
            - 指最高位发生借位
          - 零标志ZF
          - 符号标志SF
          - 溢出标志OF
        - 假设参与比较的两个无符号数为A,B
        - bgt执行A-B测试运算
          - 只有A-B>0时发生转移
            - A-B运算不会发生借位(CF=0)
            - A-B>0(0标志ZF是0(即,结果不是0),否则A=B)
          - 所以,当上述两个事件同时发生:
            - $CF=0;ZF=0$
            - (或者说$\overline{CF+ZF}=1$)
          - 值得一提的是,无符号数相减,不会发生溢出!
    - 返回(RET)
    - 调用(CALL)
      - 执行调用指令必须保存下一条执行的地址(返回地址)
      - 当子程序执行结束时,根据返回地址返回到主程序继续执行
      - 调用和转移的区别在于,转移指令不返回
    - 陷阱(陷入)(TRAP)
    - ...
    - 转移指令用来解决指令<u>变动程序中指令执行次序的需求</u>
      - 而不是数据调用的次序变动需求
  - 输入输出操作
    - 这类指令用于完成cpu与外部设备交换数据或者传送控制命令及状态信息
  - 程序控制类指令
    - 改变程序执行的顺序,使得程序具有分析/测试/判断/循环执行的能力
    - 包括
      - 无条件转移指令
      - 有条件转移指令
      - 返回指令
      - 子程序调用指令
      - 循环指令
      - ....
    - 🎈而中断隐指令是硬件实现(不属于指令系统中的真实指令)

## 常用标志位



- | Code | Bit  | Name                                                       | Description                                                  |
  | :--- | ---- | ---------------------------------------------------------- | ------------------------------------------------------------ |
  | CF   | 0    | Carry flag                                                 | Set if an arithmetic operation generates: * a [carry](https://datacadamia.com/data/type/number/function/primitive/carry) * or a [borrow](https://datacadamia.com/data/type/number/function/primitive/borrow) out of the [most significant bit](https://datacadamia.com/data/type/number/bit/significant) of the result; cleared otherwise. This flag indicates an [overflow](https://datacadamia.com/computer/overflow) condition for unsigned-integer arithmetic. It is also used in multiple-precision arithmetic. |
  | PF   | 2    | Parity flag                                                | Set if the [least-significant byte](https://datacadamia.com/data/type/number/bit/significant) of the result contains an even number of 1 bits; cleared otherwise |
  | AF   | 4    | Auxiliary Carry flag                                       | Set if an arithmetic operation generates: * a [carry](https://datacadamia.com/data/type/number/function/primitive/carry) * or a [borrow](https://datacadamia.com/data/type/number/function/primitive/borrow) out of bit 3 of the result; cleared otherwise. This flag is used in [binary-coded decimal (BCD)](https://datacadamia.com/computer/cpu/type/bcd) arithmetic. |
  | ZF   | 6    | Zero flag                                                  | Set if the result is zero; cleared otherwise.                |
  | SF   | 7    | Sign flag                                                  | Set equal to the [most-significant bit](https://datacadamia.com/data/type/number/bit/significant) of the result, which is the sign bit of a signed integer. (0 indicates a positive value and 1 indicates a negative value.) |
  | OF   | 11   | [overflow](https://datacadamia.com/computer/overflow) flag | Set if the integer result is: * too large a positive number * or too small a negative number (excluding the sign-bit) to fit in the destination [operand](https://datacadamia.com/computer/instruction/operand); cleared otherwise. This flag indicates an [overflow](https://datacadamia.com/computer/overflow) condition for signed-integer (two’s complement) arithmetic. |
