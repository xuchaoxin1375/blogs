[toc]

- CN_@可靠的传输机制@流量控制技术@滑动窗口@ARQ

# 流量控制技术(协议)

- 流量控制涉及对链路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧 
  - 例如，在面向帧的自动重传请求系统中，当**待确认帧的数量增加**时，有可能超出**缓冲存储空间**而造成过载 
  - **流量控制**的基本方法是**由接收方**控制**发送方**发送数据的**速率**
- 常见的方式有两种：
  - 停止-等待协议(类)
  - 滑动窗口协议(类)

## 停止-等待流量控制

- 发送方每发送一帧，都要等待接收方的应答信号，之后才能发送下一帧：
- 接收方每接收一帧，都要反馈一个应答信号，表示可接收下一帧，
- 如果接收方不反馈应答信号，那么发送方必须一直等待 
- **每次只允许发送一帧**，然后就**陷入等待接收方确认信息的过程**中，因而**传输效率很低** 
- 停止-等待流量控制是一类流浪控制技术,区别于停止-等待协议SW-ARQ(这该控制技术的具体的协议)

## 滑动窗口流量控制

### 发送窗口

- 在任意时刻，**发送方**都维持一组**连续的允许发送的帧的序号**，称为发送窗口；

### 接收窗口

- 同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口 

### 基本原理

- **发送窗口**用来对发送方进行流量控制
  - **发送窗口**的大小$W_T=W_{Transmit}$,
    - 代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧 
  - **接收窗口**的大小$W_R=W_{Receive}$
    - 设置于接收端,是为了控制<u>可以接收哪些数据帧和不可以接收哪些帧</u> 
- 在接收方，只有收到的**数据帧的序号**落入**接收窗口**内时，才允许将该数据帧收下 
  - 若接收到的数据帧落在接收窗口之外，则一律将其丢弃

# 可靠的传输机制

- 数据链路层的可靠传输通常使用
  - <u>确认</u>和<u>超时重传</u>**两种机制**来完成
- 不过,实际应用中,主要在传输层中讨论/考虑可靠传输机制(比如TCP协议)

## 确认机制ACK

- 确认是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收 有些情况下为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认 

## 超时重传机制RTO

- RTO：Retransmission TimeOut

- **超时重传**是指发送方在发送某个数据帧后就开启一个计时器
  - 在一定时间内如果没有得到发送的数据帧的确认帧，那么就**重新发送该数据帧，直到发送成功为止** 

### ARQ处理差错

- 自动重传请求(Automatic Repeat reQuest,ARQ)
- ARQ通过<u>接收方请求发送方**重传**出错的数据帧</u>来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一 

### 自动重传请求ARQ协议🎈

- [自动重传请求  (wikipedia.org)](https://zh.wikipedia.org/zh-cn/自动重传请求)
  - **自动重传请求**（Automatic Repeat-reQuest，ARQ）是[OSI模型](https://zh.wikipedia.org/wiki/OSI模型)中[数据链路层](https://zh.wikipedia.org/wiki/数据链路层)和[传输层](https://zh.wikipedia.org/wiki/传输层)的错误纠正协议之一 
  - 它通过使用**确认**和**超时**这两个机制，在不可靠服务的基础上实现可靠的信息传输 
  - 如果发送方**在发送后一段时间之内没有收到确认帧，它通常会重新发送** 
  - ARQ可能包括
    - 停止等待ARQ协议
    - 连续ARQ协议，
  - 涉及许多机制:
    - 错误检测（Error Detection）、
    - 正面确认（Positive Acknowledgment）、
    - 超时重传（Retransmission after Timeout）
    - 负面确认及重传（Negative Acknowledgment and Retransmission）等机制 

- 传统自动重传请求分为三种
  - 即停止-等待(Stop-and-Wait):SW-ARQ
  - 后退N帧(Go-Back-N):GBN-ARQ
  - 选择性重传(Selective Repeat):SR-ARQ
- 这三种协议是基于**滑动窗口技术**和**请求重发技术**
  - 请求重发技术:使用可靠性技术中的<u>确认和超时重传</u>机制的技术
  - 第一种协议是**单帧-滑动窗口**结合了请求重发技术的低性能ARQ协议
  - 后两种协议是**多帧-滑动窗口技术**与<u>请求重发技术</u>的结合
  - 多帧和单帧指定是发送窗口单次最多可以发送的帧数🎈
  - 由于**窗口尺寸**开到足够大时，帧在线路上可以连续地流动，因此又称其为**连续ARQ协议** 
  
- 在**数据链路层**中**流量控制机制**和**可靠传输机制**是交织在一起的

# ARQ具体协议

## 单帧ARQ协议

### 停止-等待协议SW-ARQ

- SW-ARQ:单帧-滑动窗口-停止-等待协议
- 在停止等待协议中，源站发送单个帧后必须等待确认，在目的站的回答到达源站之前，源站不能发送其他的数据帧 
- 从**滑动窗口机制的角度**看，停止-等待协议**相当于**发送窗口和接收窗口大小均为1的**滑动窗口协议** 
- 基本步骤
  - 停止等待 
    - 发送方每次只发送一个分组 在收到确认后再发送下一个分组 

  - 编号
    - 对发送的每个分组和确认都进行编号 

  - 自动重传请求 
    - 发送方为每个发送的分组设置一个超时计时器 
    - 若超时计时器超时，发送方会自动重传分组 

- 在停止等待协议中，除数据帧丢失外，还可能出现以下两种差错 
  - 到达目的站的帧可能已遭破坏，接收站利用前面讨论过的差错检测技术检出后，简单地将该帧丢弃 
    - 为了对付这种可能发生的情况，源站装备了计时器 
    - 在一个帧发送之后，源站等待确认，如果在计时器计满时仍未收到确认，那么再次发送相同的帧 如此重复，直到该数据帧无错误地到达为止 

  - 另一种可能的差错是<u>数据帧正确</u>而**确认帧被破坏**，此时接收方已收到正确的数据帧，但发送方收不到确认帧，因此发送方会**重传已被接收的数据帧**，接收方收到同样的数据帧时会丢弃该帧，并重传一个该帧对应的确认帧 
  - 发送的帧交替地用0和1来标识，确认帧分别用ACK0和ACK1来表示，收到的确认帧有误时，重传已发送的帧 
  - 对于停止-等待协议，由于每发送一个数据帧就停止并等待，因此用1bt来编号就已足够 
  - 在停止-等待协议中，若连续出现相同发送序号的数据帧，表明发送端进行了超时重传 
  - 连续出现相同序号的确认帧时，表明接收端收到了重复帧 
  - 此外，为了超时重发和**判定重复帧**的需要，发送方和接收方都须设置一个**帧缓冲区** 
    - 发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传 
    - 只有在收到对方发来的确认帧ACK时，方可清除此副本  


#### 例

- 主机甲采用ST-ARQ协议项主机乙发送数据,数据传输速率为C=3kb/s

- 单向传播时延D=200ms

- 忽略确认帧的传输时延

- 当信道利用率等于0.4的时候,数据帧的长度L=?

- 分析:

  - 计算发送周期$T=T_s+2D$

  - $T_s=L/C$

  - 信道利用率

    - $$
      \eta=\frac{T_s}{T}=\frac{T_s}{T_s+2D}=\frac{L/C}{L/C+2D}=\frac{L}{L+2DC}=0.4
      \\L=0.4(L+2DC)
      \\0.6L=0.8DC
      \\L=\frac{4}{3}DC=\frac{4}{3}\times 200ms\times{3kb/s}=800bit
      $$

      


## 连续ARQ协议

### 后退N帧协议(GBN)

- GBN:GoBackN(frame)

- 接收点丢弃从第一个没有收到的数据包开始的所有数据包 

- 发送点收到NACK后，从NACK中指明的数据包开始重新发送 

#### GBN多帧滑动窗口

- 多帧-发送窗口

- 在后退N帧式ARQ中，发送方无须在收到上一个帧的ACK后才能开始发送下一帧，而是可以连续发送帧 
- 当接收方检测出失序的信息帧后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧；
- 或者当发送方发送了N个帧后，若发现该N个帧的前一个帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，此时发送方就不得不重传该出错帧及随后的N个帧 
- 换句话说，接收方只允许按**顺序接收帧** 
- 例如, **源站**向**目的站**发送数据帧 
  - 当源站发完0号帧后，可以继续发送后续的1号帧、2号帧等 
  - 源站每发送完一帧就要为该帧设置超时计时器 
  - 由于连续发送了许多帧，所以确认帧必须要指明是对哪一帧进行确认 

##### 累计确认

- GBN协议中,接受端通常采用**累计确认**的方式

  -  GBN协议还规定接收端不一定每收到一个正确的数据帧就必须立即发回一个确认帧，

  -  而可以在连续收到好几个正确的数据帧后，才对最后一个数据帧发确认信息，
  -  或者可在自己有数据要发送时才将对以前正确收到的帧加以捎带确认 
- 这就是说，对某一数据帧的确认就**表明该数据帧和此前所有的数据帧均已正确无误地收到** 
  - ACKn表示对第n号帧的确认，表示接收方已正确收到<u>第n号帧及以前的所有帧</u>，下一次期望收到第n+1号帧(也可能是第0号帧) 
  - 接收端只按序接收数据帧 
  - 虽然在有差错的2号帧之后接着又收到了正确的6个数据帧，但接收端都必须将这些帧丢弃 
  - 接收端虽然**丢弃**了这些**不按序的无差错帧**，但应<u>重复发送已发送的最后一个确认帧ACK1</u>(这是为了防止已发送的确认帧ACK1丢失） 

#### 帧号范围/发送窗口大小限制@GBN

- 后退N帧的**接收窗口大小为1**,可以保证接收数据帧

- 对于GBN,若采用**n** bit对**帧编号**,发送窗口的尺寸$W_T$$n,W_T$应该满足

  - $W_T\in[1,2^n-1]$

- 如果给定用于帧编号的编号数m,那么

  - $N\geqslant{W_T}+1$
  - 需要占用的二进制位数为$\lceil\log_2{N}\rceil\geqslant{\lceil\log_2{(W_T+1)}\rceil}$

- 否则会造成无法分辨新帧和旧帧

- 举一个具体的例子进行说明

  - 例如用**n=3**比特可编出8个不同的序号，因而发送窗口的最大值**似乎**应为8 
  - 但**实际**上，设置发送窗口为8将使协议在某些情况下无法工作(无法分辨新帧和旧帧)
  - 设发送窗口W=8,发送端发送完0~7号共8个数据帧 
  - 因发送窗口已满，发送暂停 假定这8个数据帧均已正确到达接收端，并且对每个数据帧，接收端都发送出确认帧 下面考虑两种**极端**的情况 
    - 第一种情况是(最好情况)：所有确认帧都正确到达了**发送端A**，因而发送端接着又发送**8个新的数据帧**,其编号应是0~7 
      - 注意，**序号(帧号)**是循环使用的 🎈
      - 因此序号虽然相同，但8个帧都是新的帧 
        - 这是可以确认新旧的,因为接受到的确认帧表明,新来的8个帧是新的
        - 旧的8个帧都被确认了
    - 第二种情况是：(最坏情况)所有确认帧都丢失了 
      - 经过一段由超时计时器控制的时间后，发送端重传这8个旧的数据帧，**其编号仍为0~7.**
      - 于是，当接收端**第二次收到编号为0~7的8个数据帧时**，就**无法判定**这是8个新的数据帧
        还是8个重传的旧数据帧 
        - 无法判定新旧批次的话,接受端可能会接受多次(重复)同一批帧,不仅浪费资源还引起错误
      - 因此，将发送窗口设置为($2^n=8$)显然是不行的 
  - 如果将窗口设置为$2^n-1=8-1=7$,那么可能出现的帧号为$0\sim{6}$
  - 发送窗口若干次(相邻批次)发送的帧号序列:
    - 0,1,2,3,4,5,6;
    - 7,0,1,2,3,4,5;
    - 6,.
  - 可见,这种情况下,接收端B就可以区分发送端发送来的相邻两批数据是不是同一批
    - 也就是可以区分新旧

  

##### 例

- 发送方:发送了0$\sim$6帧,
  - 在计时器超时的时候,发送方只收到了来自接收方传回的对1,3,5号帧的确认帧
  - 那么发送端需要重传的帧是?
- 由于GBN采用累计确认方式,所以我们只关注发送端收到的最大的确认号(记为m),即可知道0$\sim$m都已经被正确接受
- 本例m=5,所以只需要重传帧号6的帧

#### 例

- [2014统考真题]主机甲与主机乙之间使用后退N帧协议(GBN)传输数据，甲的发送窗口尺寸为1000，数据帧长为1000字节，信道带宽为100M6/s,乙每收到一个数据帧立即利用一个**短帧（忽略其传输延迟）**进行确认，若甲、乙之间的单向传播时延是50s,
- 则甲可以达到的最大平均数据传输速率约为（C）。
  - A.10Mb/s
    B.20Mb/s
    C.80Mb/s
    D.100Mb/s
- 分析:
  - 考虑制约甲的数据传输速率的因素。
    - 首先，信道带宽能直接制约数据的传输速率，传输速率一定是小于等于信道带宽的。
    - 其次，因为甲、乙主机之间采用**后退N帧协议传输数据**，要考虑**发送一个数据到接收到它的确认之前，最多能发送多少数据(量)**，
    - 所以甲的最大传输速率是这两个值中小的那一个。
  - 甲的发送窗口的尺寸为1000，即**收到第一个数据的确认之前**，最多能发送1000个数据帧，也就是发送1000×1000B=1MB的内容
  - 而从发送第一个帧到接收到它的确认的时间是<u>一个帧的发送时延加上往返时延(确认帧的传输时间被忽略)</u>，即
    - $t_0=\frac{1000B}{100Mb/s}=\frac{10B}{1Mb}s=\frac{80b}{1Mb}s=8\times{10^{-5}}s=0.00001s$
    - $t_0+2\times 50ms=0.10008s$
    - 此时的最大传输速率为1MB/0.10008s≈10MB/s=80Mb/s。
    - 信道带宽为100Mb/s,因此答案为min{80Mb/s,100Mb/s}=80Mb/s

#### 例

-  主机甲通过C=128kb/s卫星链路，采用滑动窗口协议向主机乙发送数据，

  - 链路单向传播时延为D=250s,
  - 帧长为S=1000字节。
  - 不考虑确认帧的开销，
  - 为使链路利用率不小于80%，帧序号的比特数至少是?

- 分析:

  - 此类问题,**对一个发送周期**进行讨论,并求出周期内发送的帧数:

    - 发送周期:开始发送帧到收到第一个确认帧为止的过程

    - 用时为:

      - T=**第一个帧**的**传输**时延+第一个帧的**传播时延**+确认帧的**传输时延**+确认帧的**传播时延**
        - 这里忽略<u>确认帧的传输时延</u>
      - 即:$T=T_s+2D$
        - $T_s=\frac{S}{C}=\frac{1000B}{128kb/s}=2^{-4}=\frac{1}{2}\times{\frac{1}{8}}=0.5\times0.125=0.0625s$

      - 因此$T=T_s+RTT=2^{-4}s+2\times 250ms=2^{-4}+2^{-1}=0.5625s$,

  - 接着计算在T内需要发送多少数据(设为$L$)才能满足利用率不小于80%。

  -  $(L/128kb/s)/T≥0.8$，

    - $$
      \frac{L}{2^7kb/s\times{(2^{-4}+2^{-1})}s}\geqslant{0.8}
      \\
      \frac{L}{1kb/s\times{(2^{3}+2^{6})}s}=\frac{L}{ {(8+64)}kb}
      =\frac{L}{72kb}\geqslant{0.8}
      \\L\geqslant{0.8\times{72kb}}=8\times{7.2kb}=7.2kB
      $$

      

    - $L/S=7.2kB/1kB=7.2(帧)$

    - 即在一个发送周期内至少发7.2个帧才能满足要求，

    - 设需要编号的比特数为n,则$2^n-1\geqslant7.2$，因此n至少$ceil(\log_2{7.2})=4$



### 选择重传协议SR

- 发送点连续发送数据包但对每个数据包都设有个一个计时器 
- 当在一定时间内没有收到某个数据包的ACK时，发送点**只重新发送那个没有ACK的数据包** 
  - 包括
    - 出现差错的数据帧
    - 计时器超时的数据帧
  - 需要将接受窗口从1进行扩大,便于接收<u>发送</u>**序号不连续**,但是仍然处在接收窗口中的那些数据帧(将要被发送过来的);
    - 等到<u>所缺序号的</u>数据帧收到后再一并送给主机
  - 每个发送缓冲区对应一个计时器,当计时器超时,缓冲区的帧就会重传
    - 一旦接收方怀疑帧出错,就会发送一个否定NAK给**发送端**,
    - 要求发送方对NAK指定的帧进行重传
  - $W_T,W_R>1$,每次可以发送或者接收多个帧,而且一般$W_T=W_R$
    -  选择重传协议是**对单帧进行确认**，所以发送窗口大于接收窗口**会导致溢出**
    - 发送窗口小于接收窗口会使得接收窗口多出发送窗口的那部分变得没有意义
    - 且最大值都为序号范围的一半，若采用n比特对帧编号，则需要满足：$W_{Tmax}=W_{Rmax}=2^{n-1}$
      - 因为如果不满足该条件，即窗口大小大于序号范围一半
        - 当一个或多个**确认帧**(从接收方传回给发送方的帧)丢失时，**发送方**就会超时重传之前的数据帧
        - 但**接收方无法分辨**是新的数据帧还是重传的数据帧
      - 为了避免接收端向前移动窗口后,新窗口与旧窗口产生重叠,所以接收窗口的最大尺寸不应该超过序号范围的一半
        - $W_R\leqslant{2^{n-1}}$

#### 帧号范围/发送窗口大小限制@SR

- 对于选择重传协议，若有**n比特进行编号(作为帧号/分组号)**，则**接收窗口**$W_R$的最大值为$W\leqslant{2^{n-1}}$
- 设**发送窗口**大小为$W_T$, 
  - 因为$W_T+W_R\leqslant{2^n}$，$W_R\leqslant{W_T}$,
  - 则:
    - $W_R+W_R\leqslant{W_T+W_R}\leqslant{2^{n}}$
    - $2W_{R}\leqslant{2^n};即:W_R\leqslant{2^{n-1}}$
  - 所以关于接受窗口大小的两个限制条件:
    - $W_R$取最大值$2^{n-1}$.
    - $W_R\leqslant{2^n-W_T}$🎈
    - 并且取其中更严格的一个(同小取小)
-  一般情况下选择重传协议的发送窗口和接收窗口的大小是相等的  
- 如果SR协议中**接收窗口**值大于1，(也就是SR是**无序接收滑动窗口协议**,GNB是有序接收的,两者的窗口大小约束不一样)
  - **接收窗口**要等到**接收范围内所有帧**收到**才能更新**，
  - **发送窗口**要**等接收窗口更新后**才会更新，那么发送窗口比接收窗口**多出来的那部分窗口就没有意义**了 

#### 例

- 对于滑动窗口协议,如果分组采用n=3bit编号,发送窗口大小$W_T=5$
- 则接收窗口大小$W_R最大为?$
  - $W_R\leqslant{2^3-5}=3$
  - $W_R\leqslant{2^{3-1}=4}$
  - 所以$W_R最大为3$

#### 例

- 数据链路层采用选择重传协议SR传输数据,发送方已经发送了$0\sim{3}$号数据帧
- 现在已收到1号帧的确认
- 0,2号依次超时,此时需要重传的帧?
- 分析:只有0,2号需要重传,因为SR协议只需要重传未确认的分组(数据帧)
  - 至于3号帧,问题中没有给出到底是出错还是超时,认为还处于传输的过程中,不计入重传对象

#### 例

- 两台主机之间的数据链路层采用GBN传输数据

  - 传输速率为v=16kb/s
  - 单向传播时延为270ms
  - 数据帧长范围是$128\sim{512}$Byte
  - 接收方总是以总数据帧等长的帧进行确认
  - 为了使得信道利用率达到最高,帧序号的比特数n至少为?

- 分析:

  - 本题主要求解的是从发送一个帧到接收到这个帧的确认为止的时间内最多可以发送多少数据帧。

  - 要尽可能多发帧,提高信道利用率，应以短的数据帧计算，因此首先计算出发送一帧的时间

  - 数据帧长度是不确定的，范围是128~512B

  - 但在计算至少窗口大小时，为了保证无论数据帧长度如何变化，信道利用率都能达到**最高**，

    - 这个`最高`在不同帧长下计算的结果不同,虽然具体的最高值不确定,但是这个最高在帧长范围区间的边界取到是容易判断的,这又有两种可能,以

      - 最短帧长计算
      - 最长帧长计算

    - 结论是,应以最短的帧长计算

    - 因为,如果以最长512B计算，那么求得的参数在传输帧长为128B的最短帧情况下，<u>达不到最高信道利用率</u>。

    - 首先计算出发送一帧的时间

      - $t_0=128×8/(16×10^{-3})=64ms:$

      - 发送一帧到收到确认为止的**总时间**(发送周期)为$t=t_0+RTT+t_0=t_0+2D+t_0=64+270×2+64=668ms$:

      - 这段时间总共可以发送668/64=10.4帧，发送这么多帧至少需要用$ceil(\log_2{10.4})=4$位比特进行编号。

      - 类似于指令流水,每个帧的发送时间越短,发送周期内可以发送出去的帧就越多

        

## 小结

### 滑动窗口特性

- 只有接收窗口向前滑动（同时接收方发送了确认帧）时，发送窗口才有可能（只有发送方收到确认帧后才一定）向前滑动 

- 从滑动窗口的概念看，停止-等待协议后退N帧协议和选择重传协议只在**发送窗口大小**与**接收窗口大小**上有所差别：

  - 停止-等待协议：发送窗口大小=1，接收窗口大小=1 

  - 后退N顿协议：发送窗口大小>1，接收窗口大小=1 

  - 选择重传协议：发送窗口大小>1，接收窗口大小>1 

- 接收窗口的大小为1时，可保证帧的有序接收 
- **数据链路层**的滑动窗口协议中，**窗口的大小在传输过程中是固定的**
  - 与传输层的滑动窗口协议的区别
    - 在TCP协议中,滑动窗口大小是有变换的

#### 例

- 若滑动窗口机制采用SR协议来进行流量控制,允许发送方在收到应答前连续发出多个帧,

  - 若帧序号长度为kbit,接收窗口的大小$W\leqslant{2^{k-1}}$,才能避免接收端向前移动窗口后,新的窗口和旧的窗口产生重叠

  - 设发送窗口的帧序列区间为[L,U],窗口大小为$y=U-L+1$;发送窗口大小的初始值为W

    - $0\leqslant{y}\leqslant{W}$

    - $$
      0\leqslant U-L+1\leqslant{W}
      \\
      U-W+1\leqslant{L}
      \\
      L\geqslant{U-W+1\mod{2^{k}}}
      $$

### 连续ARQ 协议与停止等待协议比较



- |                | 连续ARQ协议       | 停止-等待协议    |
  | :------------: | ----------------- | ---------------- |
  | 发送的分组数量 | 一次发送多个分组  | 一次发送一个分组 |
  |    传输控制    | 滑动窗☐协议       | 停等-等待        |
  |      确认      | 单独确认+累积确认 | 单独确认         |
  |   超时定时器   | 每个发送的分组    | 每个发送的分组   |
  |      编号      | 每个发送的分组    | 每个发送的分组   |
  |      重传      | 回退N,多个分组    | 一个分组         |





