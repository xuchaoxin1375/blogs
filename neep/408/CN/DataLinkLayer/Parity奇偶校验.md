[toc]



#  奇偶校验码

- 奇偶校验码就是在信息码后面加一位校验码，分`奇校验`和`偶校验`。


## 奇校验：
- 添加一位校验码后，==使得==整个码字里面1的个数是奇数。

### 使用(验证)方法

- 接收端收到数据后就校验数据里1的个数，
  - 若检测到奇数个1,则认为传输没有出错；
  - 若检测到偶数个1,则说明传输过程中，数据发生了改变

## 偶校验：
- 添加一位校验码后，`使得`整个码字里面1的个数是偶数。

### 验证方法

- 接收端收到数据后就校验数据里1的个数，

  - 若检测到偶数个1,则认为传输没有出错；

  - 若检测到奇数个1,则说明传输过程中，数据发生了改变，要求重发。

##  小结

- 在原编码上加**一个校验位**(增加的冗余位称为**奇偶校验位**)，它的**码距**等于2，
- 可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能够检测出偶数位错误，
- 奇偶校验实现的方法：
  - 由若干位有效信息(如1B)再加上一个二进制位（校验位）组成校验码，
  -  校验位的取值(0或1)将使整个校验码中“1”的个数为奇数或偶数，所以有两种可供选择的校验规律。
  - 奇校验码:整个校验码（有效信息位和校验位）中“1”的个数为奇数。
  - 偶校验码:整个校验码（有效信息位和校验位）中“1”的个数为偶数。

### 奇偶校验码结构

- 奇偶校验**码**有两部分组成

  - 奇偶校验位
    - 1bit
  - 有效信息位
    - n位

  

# exercise:补全给定二进制串的奇偶校验码

- 给出两个编码A=1001101和 B=1010111的奇校验码和偶校验码:


- 设最高位为校验位p,余n=7位是信息位，则对应的奇偶校验码为

  - A=1001101

  - | 数据编号 | 数据取值 | 1的个数 | 0的个数(不重要,不看) | 奇校验码  | 偶校验码  |
    | -------- | -------- | ------- | -------------------- | --------- | --------- |
    | A        | 1001101  | 4       | 3                    | 1 1001101 | 0 1001101 |
    | B        | 1010111  | 5       | 2                    | 0 1010111 | 1 1010111 |

- 从另一个角度上看(给定一个奇校验码或偶校验码,求解缺失的某一个bit)

  - 将一个**信息码X**前面加1/0,分别得到两个数,这两个数中一个是奇校验码,另一个就是偶校验码
  - 将两个数分别记为$X_0$,$X_1$
  - 并且可以断言,$X_i,i=0或1$要么是X的奇校验码(简称为奇码),要么是X的偶校验码(简称为偶码)
    - 总结:$X_0,X_1$满足:非奇即偶,一奇一偶
    - 如果$X_i$中的一个已经知道是P校验码,那么另一个就是Q校验码
      - P,Q的可能取值组合为:
        - P=奇,Q=偶
        - P=偶,Q=奇
  - 🎈那么:分别计数$X_0,X_1$这两个n+1位校验码中包含的的**1的个数**,
    - 如果是奇数,那它就是奇校验码,
    - 如果是偶数,就是偶校验码
    - <u>0的个数就不看啦</u>
  - 奇偶校验只能够检测出奇数个位同时出错的情况(且一定能)
    - 比如,发生了1bit错误,那么1的个要么增多1,要么减少1,1的个数$n_{odd}$的奇偶性必然发生变化
  - 如果是偶数个错误,则不能检测出来

### 例

- 字符S的ASCII编码从低到高依次为1100101，采用**奇校验**，在下述收到的传输后字符中，错误（D）不能检测。

  - A.11000011

  - B.11001010

  - C.11001100

  - D.11010011

- 分析:

  - 对于奇校验,如果被校验的**奇校验码**(记为$u$中含有奇数个1,会被认为是正确的,这种情况下,如果$u$实际上是错误数据,那么奇校验无法检测到错误:
    - 例如,u中有两位发生了错误,得到u',(也就是u中有俩个bit发生了翻转)
    - 通过枚举所有可能:
      - $00\to{11}$
      - $01\to{10}$
      - $10\to{01}$
      - $11\to{00}$
      - 发现,u'中的1的个数可能+0或+2或-2,这不影响1的个数的奇偶性
      - 因为,$x+2n,n=-1,0,1$的奇偶性和$x$的奇偶性一致(枚举可知)
    - 这就导致同时发生2位(或者说偶数位)错误,奇校验是无法发现的
  - 如果是偶校验,有类似的结论,主不过,报错的条件是和奇校验想反(u中含有的1的个数为奇数)
  - 因此上例中,4个选项的(4个奇校验码中,对比需要传输的源串1100101,四个选项是都错的串)
    - 也就是说都应该报错,但是奇校验的检错能力有限,不一定能够检测出来
      - 前是三个选项中,1的个数是偶数个,因此会报错(能够检测出来)
      - 但是第4个选项D,包含了奇数个1,因此奇校验认为它是对的,没能够争取反映真实情况(错误未能检测出来)

