@[toc]



# 模二运算:

- **CRC码是基于模2运算而建立编码规律的校验码🎈**

##  模2加/模2减
- 模二加和模二减可以视为亦或(xor)运算
- 模2运算的特点是
  - **不考虑进位和借位的运算**
- 其规律如下：
  - 模2加和模2减的结果是相等的，x modadd 2=x modsub 2
  - 即0±1=1,0±0=0,1±0=1,1±1=0
- 总结,二进制数(0,1)的模2加和模2减结果上都等同于**异或运算**
  - 可见，两个相同数的模2和恒为0.


## 模2乘/除

- 模2乘是按模2和求**部分积之和**
- 模2除是按模2减求**部分余数**

- 解释:

  - 模2乘除法的计算方法和笔算乘法类似步骤类似

    - 但是

      - 乘法时的使用的若干次普通加法被改成了模2加
      - 除法时的使用的若干次普通减法被改成了模2减
      - 又因为模二加和模二减效果一样,所以它们都可以通过**按位异或**得到本位运算结果

      

### 模2除

- 上商的原则是：

  - 当**部分余数**的**首位**为1时，上商1；
  - 当部分余数的首位为0时，上商0;
  - 这是因为,被除数的最高位总是非0的,对于二进制而言,总是1
    - 就好像我们做十进制除法,,被除数不会写0开头的(总是处理成非0开头的(1~9))
    - 除数也是一样的情况(对于二进制,也总是1开头)
    - 所以对于二进制,除数和被除数都是形如$s=1\cdots{x_0},d=1\cdots{d_0}$:

- 每求一位**商**应**使部分余数减少一位**🎈

  - 指部分和的高位(用过就不再用了)
    - 且,根据上面的分析,上商后,**部分余数最高位**和**除数乘以本位商**最高位是一致的
  - 低位部分是要继续用的

  - 当部分余数的位数小于除数的位数时，该余数即为**最后余数**。

- 对于除法,注意由于没有进位和借位,🎈

  - 除数的位数m小等于被除数或部分余数的位数n,那么依然继续上商

### 部分积之和的比较

- 类似于我们列竖式计算的中间计算过程的各行中间结果
- 部分积的算术和:
  - 就是各个中间结果的直接加和
- 部分积的模二和:
  - 以模二和的加法规则(也就是按位异或)来求和中间结果

##  异或运算的相关规律🎈

### 任意数量的0相异或结果为0

- 由$0\oplus{0}=0$
  - n个0相异或会被化简为$n-1$个0相异或
  - 递推下去,只剩下一个0
  - $0\oplus0\oplus\cdots\oplus0=0$

### n个1相异或

- $1\oplus{1}=0$
- $0\oplus{1}=1\oplus0=1$
- 异或运算满足交换律

- $y_{n+1}=y_n\oplus{1}$

- | n    | $y=\underset{i=1}{\overset{n}{\oplus}}1$ |
  | ---- | ---------------------------------------- |
  | 2    | 0                                        |
  | 3    | 1                                        |
  | 4    | 0                                        |
  | 5    | 1                                        |
  | ...  | ...                                      |
  | 2i   | 0                                        |
  | 2i+1 | 1                                        |
  | ...  | ...                                      |

- 可以得出以下结论:

  - 偶数个1 相亦或 ,结果为0

  - 奇数个1 相亦或,结果为1 

- 事实上,在二进制范畴内:(用枚举真值表的方式可以轻松证明)
  - 和1异或相当于取反
    - $b\oplus{1}=\overline{b}$
  - 和0异或相当于保持:
    - $b\oplus{0}=b$

- 由于这种`保持特性`,对于任意一个二进制串,的项异或结果和去掉所有的0后再相异或的结果是一致的
  - 例如:
    - $1\oplus{0}\oplus{1}\oplus{1}\oplus{0}=1\oplus{1}\oplus{1}=1$

### 结合律

- 根据上面的分析,可以知道,异或运算满足**结合律**

### 总结🎈

- 给定任意一个二进制串,求它们的异或,关键要看1的个数,

  - 如果1的个数为奇数,那么结果为`1`

  - 否则,该结果位上的亦或结果为`0` 	

    - 如果只有0没有1,则认为1的个数是0(归属于1的个数是偶数的情况)

    

###  计算模二乘/除

- 在模二乘法时,您可以用上述异或运算的结论快速完成计算:
  - 将1的个数为偶数的列对应的结果为写为0,
  - 其余位都用1补齐(分批处理)

###  实例

![在这里插入图片描述](https://img-blog.csdnimg.cn/217b447337d347b8a230c2414adac83d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 乘法

- 
  $$
  \begin{array}{r}
  &1010\\
  \times&101\\
  \hline
  &1010
  \\&0000\ \
  \\&1010\ \ \ \
  \\
  \hline
  &100010
  \end{array}
  $$
  

  - |             |      |      |      |      |      |      |
    | ----------- | ---- | ---- | ---- | ---- | ---- | ---- |
    | s1          |      |      | 1    | 0    | 1    | 0    |
    | s2          |      | 0    | 0    | 0    | 0    |      |
    | s3          | 1    | 0    | 1    | 0    |      |      |
    | $r_0$(可选) | 1    |      |      |      | 1    |      |
    | $r_1$(可选) |      | 0    | 0    | 0    |      | 0    |
    | result      | 1    | 0    | 0    | 0    | 1    | 0    |

  - 由于模二加/减运算不用考虑进位/借位,所以可以向上面那样列表处理

  

#### 除法:



- |      |      |      |      |      |      |      |      |      |          |          |          | 1        | 0        | 1        |      |      |      |      |      |      |      |
  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -------- | -------- | -------- | -------- | -------- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
  |      |      |      |      |      |      |      |      | 101  | $\Huge)$ | 1        | 0        | 0        | 0        | 0        |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |          | <u>1</u> | <u>0</u> | <u>1</u> |          |          |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |          |          | 0        | 1        | 0        |          |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |          |          | <u>0</u> | <u>0</u> | <u>0</u> |          |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |          |          |          | 1        | 0        | 0        |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |          |          |          | <u>1</u> | <u>0</u> | <u>1</u> |      |      |      |      |      |      |      |
  |      |      |      |      |      |      |      |      |      |          |          |          |          | 0        | 1        |      |      |      |      |      |      |      |

  - 表格中,

    - 不带下划线的是**部分余数**(或者最开始的被除数)
      - 被除数记为$S=10000$,除数记为$D$=101
      - 除数的位数为d=3位
    - 有划线的表示**本位商**乘以**除数**的乘积,称为**nextProd**
      - 所谓的**本位商**就是根据<u>部分余数的最高位</u>**上商**
      - 商记为$Q=q_k,\cdots,q_1,q_0$的第i位记为$q_i$
      - $nextProd=q_i\times{D}$

    - 当部分余数位数少于除数的位数,停止计算(结束)

## CRC基本信息

- 循环冗余码(Cyclic Redundancy Code)

  - 也称为多项式码

- 任何一个由二进制数**位串**组成的代码都可以和一个只含有0和1种系数的多项式建立一一对应的关系

- 一个$k$ bit的帧M=M(x)可以视为$X^{k-1}\cdots{X^0}$的$k$次多项式

  - 如果给定二进制位串M=$m_{k-1},\cdots,m_1,m_0$

  - 这个多项式的阶数为$r=k-1$

  - 这一点类似于二进制按权展开转化为十进制值

  - $$
    M=M(x)=\sum_{i=1}^{k-1}m_iX^{i}
    \\m_i=0或1
    $$

  - 例如:

    - $M=1110011$,位数k=7;表示为多项式就是$M(x)=X^6+X^5+X^4+0+0+X^1+X^0$
    - 也可以列表填充

  - 例如:

    - $M(x)=X^5+X^4+X^2+X$

    - $阶数r_M=5$

    - 对应的二进制位串长度为k=r+1=6

      - 从成分上也可以直接看出M串中含有4,个1,k-4=6-4=2个0

    - | M(x)的各个项(权) | 5    | 4    | 3    | 2    | 1    | 0    |
      | ---------------- | ---- | ---- | ---- | ---- | ---- | ---- |
      | M(系数序列)      | 1    | 1    | 0    | 1    | 1    | 0    |

      - $M=110110$



###  生成多项式

- 生成多项式与其对应的**二进制代码**之间的关系

  - 生成多项式中**各项**的**系数收集起来**就是该**生成多项式的二进制代码**(将作为模二除法的除数)

    - 如果某一阶对应的**项缺失**,表示该项对应的系数(二进制代码)为0,
    - 如果存在,则为1

- $$
  G(x)=1011=1\times x^3+0\times{x^2}+1\times x^1+1\times x^0
  =x^3+x+1
  $$

  

- 给定一个m bit的**帧或报文**，发送器生成一个r bit的序列，称为**帧检验序列(FCS)**
- 这样所形成的帧将由**m+r**比特组成。
- 发送方和接收方事先商定一个多项式G(x)(最高位和最低位必须为1)，
  - 使这个带检验码的帧**刚好能被预先确定的多项式G(x)整除**
  - 接收方用相同的多项式去除收到的帧，**如果无余数，那么认为无差错**
- 带有r个bit的FCS的多项式编码可以检测到所有长度小等于r的突发性错误
- CRC校验可以用硬件完成

### 计算FCS

- 假设一个帧有m位，其对应的多项式为G(x),则计算冗余码的步骤如下：
  - 1)加0
    - $假设G(x)的阶为r_G,后续r默认都指的是生成多项式G(x)的阶$
      - 而不是M(x)的阶
    - 在帧的低位端加上**r个0**,将结果数据串记为$L_r$
  - 2)模2除
    - 利用模2除法，用G(x)对应的数据串G去除数据串$L_r$，得到的余数即为冗余码(共r位，前面的0不可省略)。
- 多项式以2为模运算
  - 按照模2运算规则，加法不进位，减法不借位，它刚好是异或操作
  - 乘除法类似于二进制的运算，只是在做加减法时按模2规则进行

#### 例🎈

- 冗余码的计算举例：
  - $设G(x)=1101(即阶数r=3),$
    - $记G(x)的位数为L,那么通常阶数r=L-1$
  - 待传送数据M=101001(即被除数位数m=6)
    - $L_r=M\times{2^r}$
    - $L_r=101001,000$
      - 即,从M尾部拼接r=3个0
  - 经**模2除法**运算后的结果是：
    - Q=$L_r\ mod2div\ {G(x)}\cdots{R}$
    - 商Q=110101（这个商没什么用），
    - 余数R=001
  - 所以发送出去的数据为101001,001(即$2^rM+FCS$),共有m+r 位

##  CRC实例

![在这里插入图片描述](https://img-blog.csdnimg.cn/ba4979cad407422ebc645754e7387611.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

##  模二除法快进特点(实例)🎈

- 快进到非0位
  - 在第三次上商的时候,您将发现快进
  - 根据前面的分析,每次求新的部分余数都可以执行一定程度的前进
  - 设除数的位数为d=5位
  - 下一次上商之前,从部分余数的第一个非0位开始(第一个1,这个1前面有w个0),继续下放知道凑足d=5位,
  - 继续上商
    - 先补上w个0
    - 在上1(按照一般情况的基本规则继续计算)
    - 基本原理在于前面提到的,每确定一位商,部分余数的位数(高位就会少1位)
      - 相应的,部分余数高位减少w位,也应该确定下来w位的上🎈
    - 不过快进归快进,减法的时候,只有第一位不写,其他的0都要写!

![在这里插入图片描述](https://img-blog.csdnimg.cn/58a1f78bd65f46169b5e55a974fb3a0b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/57e4de1298f34b2187f3866c83704e71.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)


#### 例

- 要发送的数据是M=1101011011，采用CRC校验，生成多项式G(x)是10011，那么最终发送的数据应是（C）。
  - A.11010110111010
    B.11010110110110
    C.1101011011**1110**
    D.11110011011100
  - 经过计算
    - $r=r_G=5-1=4$
      - 生成多项式G(x)的阶为4
    - FCS通过对M做G(x)=10011的模二除法,得到其
      - 余数为R=1110
      - 商Q=11 0000 1010(不关心,只留作草稿)
    - $发送端数据CRC=2^rM+R$

###  帧检验序列FCS(Frame Check Sequence)
- 在选用CRC检测法时

- 上例中的最终余数010即为帧检验序列FCS(也叫冗余码)

## ref

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/031394e785834165bceb61ce3fcec414.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

##  设计CRC生成多项式的原则

来自wiki 百科
![在这里插入图片描述](https://img-blog.csdnimg.cn/083513f3a85f47da905547ca04a4d4aa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)