[toc]

## 组帧

- 为了描述方便,将数据链路层(DataLinkLayer)记为DLL🎈
- 数据链路层的PDU(帧)是最下的传输单元
- 为了能够区分各个帧(**比特流串**)的开头和结尾,需要同时添加首部和尾部
  - 而高于DLL的各层的PDU(比如分组)在封装上一层的数据时不需要加上尾部,而仅需要首部即可
  - 比如分组,它是包含在帧的数据段部分

## 帧定界

### 字符计数法

- 帧**头部**使用以**计数字段**来表明帧内字符数
  - 计数字段提供的字节数**包含**自身所占用的一个**字节**(8bit)
- 最大的弊端在于,如果计数字段出错,导致帧定界判断失效,收发双方失去同步

### 字符填充的首尾定界法

- 字符填充法使用特定字符来定界一个帧的开始(start)和结束(end),这两个字符称为**首尾定界符**,记为SE
  - 可以将
    - 开始符记为$\alpha=$SOH(start of head)
    - 结束符记为$\beta=$EOT(end of tail)
    - 🎈视情况,可以有$\alpha=\beta$
  - SOH放在帧的最前面,
  - EOT放在帧的最后面

- 为了使**信息位**中出现的**特殊字符**(比如首尾定界符中的某个字符)不被误判为帧的**首尾定界符**
  - 🎈可在**特殊字符**前面<u>填充一个转义字符`ESC`来加以区分,</u>
    - 记为$\gamma=ESC$,记为$\gamma$,是为表明ESC代表某1个字符的名字
- 注意，转义字符ESC(转义的英文是Escape,逃跑/转义)ASCII码中的**控制字符**
  - 是一个字符，而非“E”“S”“C”三个字符的组合）
  - 就像键盘上的ESC,是有一个按键叫做ES 
- 接收方收到转义字符后，就知道其后面紧跟的是**数据信息**，而不是**控制信息**(定界符)🎈
  - 这个条件是字符填充法能够奏效的前提
- 数据是从**网络层**发送给数据链路层的,由(**数据链路层**)执行填充操作(帧定界处理)
- 形式化描述:
  - 设某个数据片段形如:
    - L=$c_1,\cdots,c_n$
  - 为其加上首尾定界符
    - $\alpha{c_1,\cdots,c_n}\beta$,
    - 这个串可能会被错误的截断,因此需要做以下处理
  - 记S=$\{\alpha,\beta,\gamma\}$是需要转义的字符集合
    - 在做填充处理时,遇到S中的字符,需要在其前面插入一个$\gamma$进行转义
    - 将S中的元素统称为s
  - 为了防止L片段中出现属于界定符SE中的元素,L需要做字符填充判断和处理
    - 假设$c_{k_1},\cdots,c_{k_m}\in{L},m\leqslant{n}$
    - $L_c= L_c=e_1c_1\cdots{e_n}c_n$
      - 如果$k_j=i,则,e_i=\gamma$
      - 否则,$e_i为空字符$
    - 所以得到的L经过填充处理后的结果串$L_c$长度$r=\mathrm length(L_c)$关系满足:
      - $r=n+m,r\leqslant{2n}$
    - 数据链路层传输的判断被拼接为$R_c=\alpha{L_c}\beta$
  - 接收端根据约定,执行逆过程,将 $L_c$中的$\gamma{s}$结构的**字符对**处理为$s$
    - 即,删除字符中的第一字符$\gamma$
    - 其中,$\gamma{s}\in\{\gamma{}\alpha,\gamma{}\beta,\gamma{}\gamma\}$
      - 其中$s\in{S}$
  - 接受端接受到$R_c$结构的片段时,就可以识别出这是一个帧,而且数据部分不会因为误读任何**控制字符**导致截断问题
    - 这样 $L_c$经过逆处理,被还原为L

### 零比特填充法

- 0比特填充法(简称为`0法`)比较接近字符填充法,
  - 更加灵活
  - 在实现上提供了便利,性能更好
  - 实际应用上,0bit的通用性最好
- 0法允许数据帧包含任意个数的bit,也允许每个字符的编码包含任意个数的比特
- 0法使用一个特定的**比特模式(串)**,记为pattern,或**p串**
  - p被用来标志一个帧frame的开始和结束
- 为了不使数据字段中的**信息位**中出现了和p串一样的子序列,(这会导致错误定界判断),需要**插0处理**
  - 例如设定一个模式p=0<u>111</u>*111*0(包含6个连续的1),
  - **发送端**的数据链路层在处理**信息位**序列L时,如果遇到5个连续的1时,自动在其后插入一个0
    - 这样就保证了信息位序列中找不到模式串p,从而不会被错误定界🎈
  - 做完补0操作后,得到的结果序列记为$L_0$
    - 为$L_0$头尾分别拼接上模式**p串**,得到$R_0$=$pL_0p$结构
    - 接受端接受到$R_0$,可以扫描到$R_0$的前后缀是p串,因此取出$L_0$
  - **接收端**对$L_0$执行相反的检查处理操作(去0处理)
    - 把所有形如**L 111110 R**处理为形如**L 11111 R**
      - L,R分别表示序列的左侧部分和右侧部分
    - 还原出了L,并且不会被错误定界

### 违规编码法

- 适用范围窄,但是开销最小
- 在**物理层**进行**比特编码**时，通常采用**违规编码法**。
  - 例如，曼彻斯特编码方法
    - 合规编码设定
      - 将数据比特“1”编码成“高低”电平对，将数据比特“0”编码成“低-高”电平对，
    - 违规编码
      - 而“高-高”电平对和“低低”电平对在数据比特中是违规的（即没有采用）。
  - 可以借用这些违规编码序列来定界帧的**起始和终止**。
  - 局域网EEE802标准就采用了这种方法。
  - 违规编码法**不需要采用任何填充技术，便能实现数据传输的透明性**，
  - 但它只适用于采用冗余编码的特殊编码环境。

### 小结

- 由于字节计数法中计数字段的脆弱性和字符填充法实现上的复杂性与不兼容性，目前较常用的组帧方法是比特填充法和违规编码法。

## 例

- 在一个数据链路协议中使用下列字符编码：(字符的二进制编码是用来二进制化表示用的)
  A:01000111
  B:11100011
  $\gamma$=ESC:11100000
  p=FLAG:01111110

- 在使用下列成帧方法的情况下，说明为传送4个字符A、B、ESC、FLAG所组织的顿而
  实际发送的二进制位序列(使用FLAG作为首尾标志，ESC作为转义字特)，

  - 1)字符计数法。
  - 2)使用字特填充的首尾定界法。

  - 3)使用比特填充的首尾标志法。

- 解:
  - 1)第一字节为所传输的**字符计数5**，转换为二进制为00000101，
    - 后面依次为$L_r=$A,B,ESC,FLAG的二进制编码：
    - 00000101 01000111 11100011 11100000 01111110
  - 2)首尾标志位FLAG(01111110),在所传输的数据中，
    - 若出现控制字符，则在该字符前插入转义字符ESC(11100000):
    - 填充处理后的序列$L_{c}$=A,B,**ESC**,ESC,**ESC**,FLAG,长度为6
    - 首尾拼接定界符:$R_c=$FLAG,$L_c$,FLAG,长度为6+2=8
    - 将$R_c$中每个字符翻译称二进制:
      - 0111111001000111111000111110000011100000111000000111111001111110
  - 3)首尾标志位FLAG(01111110),在所传输的数据中$L_r$，
    - 若连续出现5个“1”，则在其后插入“0”,得到$L_0$
    - 然后拼接为$R_0=pL_0p$
    - $R_0$二进制:
      - 011111100100011111010001111100000001111101001111110

- 从本例中,看到,$R_0$相比$R_c$要短许多,但是不一定不总是这样,如果字符编码和模式串配合的不好,那么也会使得0填充法需要填充较多位数,同时要和传输的内容序列本身有关🎈





