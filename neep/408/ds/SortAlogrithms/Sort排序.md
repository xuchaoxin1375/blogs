@[toc]

# 排序

## ref

- [排序算法 (wikipedia.org)](https://zh.wikipedia.org/wiki/排序算法)
- [Sorting algorithm - Wikipedia](https://en.wikipedia.org/wiki/Sorting_algorithm)

## 排序的对象

- 排序对象是:记录(也叫元素)的序列$\set{R_i}$
- 每个记录$R_i$都含有若干个字段,对于排序而言,最重要的是$R_i$其中的关键字字段$key_i$
  - 当记录最简单化,就是数值排序(比如实数排序/整数排序)

### 排序分类

- 内部排序
  - 排序元素全部载入内存进行排序
- 外部排序
  - 被排序元素在排序过程中,需要在内,外存间移动

### 排序算法的稳定性SortAlgorithmStability

- 待排序列$R_i,...R_j$具有前后关系,且$key_i==key_j$
  - 如果排序算法排序后,仍然有$R_i在R_j$前面,则该排序算法稳定

## 性能分析

### 比较排序算法的性能分析原则

- 比较排序算法性能(时空复杂度)主要是取决于**比较和移动的次数**

## 基于比较的排序算法的比较次数

### 决策树(desicion tree)

- 因为<u>任何正确的排序算法</u>都能够<u>生成输入的每一个排列</u>
  - 所以对一个<u>正确的比较排序算法</u>来说:
    - $n$个元素的$n!$种可能的排列<u>都应该出现在决策树的叶结点上</u>。
    - 给定任意一个待排序序列,经过某一个比较排序算法处理,得到排序完的结果序列
      - 假设这个排序过程中发生的元素间调整操作的序列SOS(sort operation serials)
      - 含有n个元素的待排序序列可能有n!中序列
      - 这些序列在同一个排序算法对应不同的操作序列(操作序列的长度也可能不等长)
        - 有的序列规律性强(例如最好的情况),需要的操作步骤少,有的则相反(最坏的情况)
        - 最坏的情况对应于排序树从根结点到叶子结点的最长的一条路径(主要研究最坏的情况)
      - 不同的待排序序列对应到了不同叶结点
      - 因此叶子结点至少有n!个
        - 由这个约束,我们可以确定比较排序的决策树的高度下限
  - 而且，(每一个**叶结点**都必须是可以**从根结点经由某条路径到达**的，**该路径<u>对应于</u>比较排序的一次实际执行过程**(我们称这种叶结点为“可达的”)。
  - 因此，我们只考虑(每一种排列都是一个可达的叶结点的决策树)。

![在这里插入图片描述](https://img-blog.csdnimg.cn/3beef211689d47cf9e0c58402655041b.png)


- 上述输入序列的元素序列:6,8,5

- 根据插入排序算法构建的插入排序决策树

- 排序目标时升序排列

- 最坏的情况下需要从根结点比较到最长路径的叶子结点

  - 例如上例中的粗线路径(插入排序比较过程)
    - 从$a_1开始插入a_2,a_3$

- 最好的能够确定全序列有序情况是:

  - $a_1>a_2$

  - $a_1<a_3$

  - 因为,上述两个比较足以确定下来$a_2<a_1<a_3$

  - $对应于例图中的<2,1,3>叶子结点$

    

### 决策树分析

- 在最坏情况下，任何比较排序算法都需要做$(n\lg n)$次比较。
  - 证明︰根据前面的讨论，对于一棵每个排列都是一个可达的叶结点的决策树来说，树的高度完全可以被确定。
  - $考虑一棵高度为h、具有l个可达叶结点的决策树，它对应一个对n个元素所做的比较排序。$
  - 因为输入数据的$n!$种可能的排列都是叶结点，所以有$n!\leqslant l$。
  - 由于在一棵高为h的二叉树中，**叶结点**的数目不多于$2^{h-1}$,如果根结点所在高度为0,则叶结点数上限为$2^h$
  - 我们得到$l$的取值确界:
    - $n!\leqslant l\leqslant 2^{h}$
- 对该式两边取对数，有
- $h≥\lg(n!)=\Omega(n\lg n)$

### 渐近最优的比较排序算法

- 堆排序和归并排序都是渐近最优的比较排序算法。
  - 堆排序和归并排序的运行时间上界为O($n\lg n$)

## 判断给定序列的有序性(数值序列)

- 有序序列包括顺序和逆序
- 一个简单的思路是,但发现任意三个元素中是无序的,则整个序列无序
  - 对于无序序列往往不需要扫描完整个序列就可以判定无序
    - 不超过n-1次
  - 对于序列,则必须至少比较n-1次才可以确定是有序的
    - 但也不超过n-1次

```python
def judgeOrder(l, i=0, order=0,log=0):
    len_l = len(l)
    asc_mark = 0
    dsc_mark = 0

    while (i < len_l - 1):
        # print(asc_mark, dsc_mark)
        if l[i] <= l[i + 1]:
            asc_mark += 1
        else:
            dsc_mark += 1
        if asc_mark and dsc_mark:
            if log:
                print(l, "disorder!!")
            return False
        else:
            i += 1

    # if(log):
    print(l, "ascend👆" if asc_mark else "dscend⏬", "orderd!")
    if (not order):
        return True
    elif (order == 1 and asc_mark):
        return True

    elif (order == -1 and dsc_mark):
        return True
    return False


# def judgeOrderRecursiveDescend(l, i=0):

if __name__ == "__main__":
    n=40
    print(ordered_list)
    # ordered_list=[42,311,111,110]
    judgeOrder(ordered_list)
    for i in range(n):
        rand.shuffle(ordered_list)
        judgeOrder(ordered_list,log=1)
    print("--------------------升序----------------")

    for i in range(n):
        rand.shuffle(ordered_list)
        if(judgeOrder(ordered_list,order=1)):
            print("True")
    print("-------------------降序-----------------")
    for i in range(n):
        rand.shuffle(ordered_list)
        if(judgeOrder(ordered_list,order=-1)):
            print("True")
```



## 总结

![在这里插入图片描述](https://img-blog.csdnimg.cn/fb91c10f11c344bea67950c00ced6348.png)

### 存储结构对排序算法的性能/可行性影响

- HeapSort和shellSort利用了顺序存储的随机访问的特性,因此只适用于顺序存储
  - 否则,性能会变得很差或难以进行

### 序列可能是那种排序算法的中间过程或结果

- 对于快速排序,每次排序都会有一个元素被排到最终位置

  - 并且这个元素必须是该趟元素的枢轴

  - 在判断的时候,先找到一个待定的枢轴p,它两侧侧的元素要么都大于p,要么都小于p

    - 单侧要求,p的同一侧所有元素必须全部同时>=p或者同时全部<=p
    - 双侧要求,如果p两侧都有元素:
      - 仅满足一侧要求是不够的
      - 双侧要求建立在单侧基础上,满足双侧的p一定满足单侧
      - 还要求某一侧的元素均>=p,那么另一侧的元素必须均<=p,否则这个p就不可能是枢轴
    - 并不是任意序列都能够找到这样的元素p,例如:
      - 2,5,1,4
        - 2,4不满足单侧
        - 5,1,不满足双侧
          - 但是由于它们是最值元素,因此必定满足单侧要求
    - 而能够找到p的元素的序列,例如:
      - 2,5,7,4
        - 7满足了双侧要求(可以称为p)
        - 遗憾的是,尽管7满足了双侧要求,但是7并不位于最终有序位置上,因此这个序列仍不可是快速排序的某趟排序结果

  - 然后再检查这个p是否已经处于最终有序序列(可以人为的排序好整个序列,方便判断诸多选项)

  - n趟快速排序后,最多可以确定几个元素的最终有序位置?

    - | 第i趟 | 可以确定最终有序位置的元素数量 | note                                                         |
      | ----- | ------------------------------ | ------------------------------------------------------------ |
      | 1     | +1                             | 第一趟只能确定一个元素                                       |
      | 2     | +2                             | 发生在,第一趟的pivot将序列划分为两部分都非空的序列<br />那么第二趟排序对两个非空序列分别进行排序,又可以确定下来两个元素的最终有序位置<br /> |
      |       | ...                            |                                                              |
      | h     | +$2^{h-1}$                     |                                                              |

    - 在最坏的情况下,第i趟只能够在判断一个元素(即枢轴pivot)的最终有序位置

    - 否则可以再确定2个

  
