@[toc]

# 插入排序:简单插入排序(InsertionSort)和希尔排序(shellSort)

## 简单插入排序(insertionSort)

### 基本插入排序(直接插入排序)

- 如果待排序列有n个元素
- 直接插入排序将序列划分为:
  - 有序区OL
  - 待排序区WL
  - 从WL中选择第一个元素,记为L[i],假设计数从1开始
    - i>1(因为有序区在初始的是有就已经有一个元素)
    - 相应的,有序区的最后一个元素记为L[i-1]
    - 为了完成一个元素的插入,需要从L[i-1]往前比较直到出现第一个元素L[j]小等于L[i]
      - 那么认定位置j+1就是要插入的位置
      - 为了插入顺序表,必须将表中的L[j+1]~L[i]这段元素逐个的向后移动一位
      - 为了避免L[i]丢失,所以及时的复制到一个变量中(作为哨兵),经常是不存储元素的L[0]
      - 腾出位置后,将原先L[i]元素的备份插入到L[j+1]





#### 性能分析

- 比较简单,时间复杂度为$O(n^2)$
- 空间复杂度为O(1)
- 适用于元素基本有序的情况时,会表现出不错的性能

#### 最坏的情况下(最多比较次数)

- 最坏的情况下,所有待排元素形参逆序序列
  - 需要比较的次数为$\sum\limits_{i=1}^{n-1}i=\frac{1}{2}n(n-1)$

#### 最好的情况下

- 待排序列是有序的,那么只需要比较n-1次,就可以结束算法(不需要任何移动)

## 简单插入排序算法实现代码

###  直接插入排序函数(C版)

```c
/*"排序.c"*/
/*（173）直接插入排序
排序思想：整个排序由N - 1趟排序组成。
对于第p = 1, 2, ..N - 1趟排序，算法把
第p + 1(= 2,3,4,..N)个数据(初始位置分别是r[1],r[2],..r[N-1]位置上的数)插入到数组中下标为0, 1, 2, ..., p (<=N-1),共n个位置.的恰当位置，使得数组中的前p + 1(<=N)个元素有序。*/

void insertionSort(int r[], int n)
{
	/**********************************************************
对数组r[]中的n个元素进行直接插入排序
	*********************************************************/
	int p, j;/*p和j都是数组r的下标变量.
	/*r[0]上的数可认为已经是有序数,循环从p=1开始.*/
	for (p = 1; p < n; p++)  // N-1趟排序(从r[1]上的数据开始排.
	{
		const int tmp = r[p];  /* 取出第p+1个元素数据(从1计数),将其保存 而反映到数组下标则要减一,刚好为p,亲测允许const 变量初始化 */

	// 从数组中的第p-1个位置开始(从0开始计数)(一直往前比较,找到合适的位置，若tmp比该位置的元素小，则 
	// 把该元素往后移(对于每次只插入一个元素的插入排序而言这个变更位置的缓冲单元由当前被比较元素空出来,刚好不会影响还未排序的后面部分
		for (j = p; j > 0 && tmp < r[j - 1]; j--)/*找到合适的插入位置j;同时把元素后移;这个过程中,
		p作为右值,不被改变,类似于选择排序(tmp即r[p],每一趟排序共用一个tmp,数组内的元素r[j-1]和数组外的临时常量tmp作比较.);
		而内部j与j-1则类似于冒泡的特点,但这里不是比较,而是直接覆盖值
		 测试:r[0],r[1],*/
		{
			r[j] = r[j - 1];/*0<=j-1,则j>=1;*/
		}

		r[j] = tmp;// 把tmp放入到数组中的恰当位置
	}
}


```

###  主调用程序main

```c
/*main.c*/
#include <stdio.h>

#define N 10
#define ISHEAP 1
/*位于"排序.c"的源文件里的函数*/
void insertionSort(int r[], int n);
void shellSort(int r[], int n);
//void percDown(int r[], int i, int n);

int main()
{
	typedef int elemtype;
	elemtype r[] = { 19,15,13,1,6,7,0,3,2,4 };
	elemtype heapr[] = {-99, 19,15,13,1,6,7,0,3,2,4 };

	printf("testing:\n");
	/*直接插入排序:
   insertionSort(r, 10);*/
   /*shell排序
	shellSort(r, 10);*/
	for (int i = 0; i < N; i++) printf("%d ", r[i]);
	
}

```



###  python版

```python
'''
Description: 
Version: 2.0
Author: xuchaoxin
Date: 2021-03-05 23:25:22
LastEditors: xuchaoxin
LastEditTime: 2021-03-07 18:38:09
'''
from time import time
import random
def insertionSort(arr): 
    """ 利用一个二重循环来实现,i表示待插入元素在原数列中的索引"""
    """ 每执行一次for循环,一个元素就被插入到有序区域中,并且有序区的数列仍然保持有序 """
    for i in range(1, len(arr)): #range(n)产生0到n-1的数列,range(m,n)是m到n左闭右开的数列 
        # i=1,2,3,,,len(arr)-1;
        # 保存当前被排序元素(待插入元素)(防止被覆盖而消失)
        key = arr[i] 
        """ 辅助索引变量j定义为:和待插入元素相比较大小的元素的索引,初始化为i元素的前一个元素 """
        j = i-1
        """ 判断当前的数对(number pair)的大小,并决定是否需要对原有序序列的某部分你数做位置的移动(向后覆盖)"""
        """ 每执行一次while循环,可以将数列中的一个元素向后移动(覆盖) """
        while j >=0 and key < arr[j] : 
                """ 将前面一个元素覆盖掉后一个元素,达到元素后移的效果 """
                arr[j+1] = arr[j] 
                # 下标j是在有序区中从后往前遍历,且j>=0才是有效的索引,(当判断到j<0时,就应该停止向前遍历)
                # 索引j-1必须和arr[j+1]=arr[j]绑定在一起,while循环才能正常运行
                j -= 1
        """ 执行插入操作(key元素找到了合适的插入位置)
        arr[j]元素是第一个比key小的元素,所以,key元素要插入到arr[j+1]位置上,"""
        arr[j+1] = key 
  
""" 测试该insert_sort(List) """
""" arr=[]
for i in range(1000):
    arr.append(random.randint(0,20000)) """
#开始计时(time start)
# func_start=time()
# #invoke the insert_sort()
# insertionSort(arr) 
# #time end
# func_end=time()
# print("the function takes time:",func_end-func_start)


""" 经过验证,该算法正确,这里就不打印全部了 """
# print ("排序后的数组:") 
# for i in range(50): 
#     print ("%d" %arr[i],sep="",end=" ")
# print("......")

```



## 折半插入排序

- 时间复杂度和基本插入排序一样
- 但是利用了有序区的有序特点,在查找插入位置的时候利用折半查找,减少了比较次数
- 但是移动元素的次数没有被优化

## 希尔排序(shell_Insertion_sort:)(缩小增量排序)

- 根据基本插入排序在待排序列基本有序的情况下表现较好,所以shell尝试改变每次调用基本插入排序的问题规模
- 通过逐渐减小增量,
- 让分组中的元素数量逐渐增多,直到一个分组包含了所有初始问题中的待排序列所有元素

- 为了更好的描述算法,强调以下概念

#### 待排序列

- $L=\set{a_i}=a_1,a_2,\cdots,a_n$
- n表示待排序列的长度
- 不妨用L(i)来表示待排序列L中第i个元素

#### 排序完成序列

- $\set{b_i}=b_1,b_2,\cdots,b_n$
  - 即,对$\set{a_i}$排序的结果



#### 增量/步长(step)

- shell排序也叫缩小增量排序
- 足以体现增量这个概念对于shell排序的重要性
- 在shell排序中,我需要给定一个增量序列$\set{d_i};i=1,2,3\cdots ,k$
  - 增量序列中包含了k个增量,k到底有多少个视具体情况而定,但是必须满足一下条件
    - 序列从大到小,即,最大增量为$d_1(<n)$
    - 最小增量$d_k$=1(如果序列中仅有一个增量,那么这个增量只能是1,否则无法完成排序
      - 在这种情况下,shell排序退化成了基础的直接插入排序
- 对于不同的增量序列,shell排序可能表现出来不同的性能
- 但是目前没有确定的最优的确定序列的方法,但是有一些方法可以确定出还不错的增量序列



#### 分组/子表(subList)

- 现在我们知道了增量的概念,那么基于增量,可以对待排序序列的子表的概念
- $对于给定的增量d=d_i,我们把SL(d)={L(i+jd)}=[i,i+d,i+2d,\cdots,i+md]$
  - 其中:
    - $i=1,2,\cdots,d_k$
      - 不妨确定一个i后在讨论k的取值
      - $k=0,1,2,\cdots$
      - $例如,n=10,i=1,d_1=5$
  - 称$SL(d)为L的一个子表$
  - 🎈🎈从子表的形式化描述上,可以看到,子表内的元素是不连续的
    - 子表元素中的元素的下标值构成**等差数列**,公差为d
    - 如果用d去划分L,那么将产生d个互不相同的以d为公差的等差数列为位置下标的子表序列
    - 这里的不连续是对于待排序列L中的元素位置而言的
      - 它们物理上不连续,但是逻辑上可以认为是连续的
    - 当且仅当增量d=1的情况下,划分出来的自保元素才是连续的

#### 子表的数量和长度

- 由于待排序列元素数量是固定的(n)
  - 因此,如果子表数量减少(增量d的减小),划分L(d)对应的每个子表的长度就会增加
    - 实际上,容易察觉到,用增量d去划分L,会产生d个子序列
      - (产生的子表集合L(d)有d个元素(以子表作为元素)
      - 每个子表的长度大约都为$m(d)=\frac{n}{d}$

- shell排序就是先用一个较大的增量$d_1$区划分L,得到大量的长度较小的子表,这样插入排序的性能一般表现的不错
  - 将这$d_1$个子表序列进行直接插入排序,作为第一趟排序的排序结果
- 第二趟排序的时候,可以将d减小一些(比如$d_2$,(划分L产生的子表数量会减少(到$d_2$),但是每个表中的元素数量会增多)

####  例子来啦

- $L=49,38,65,97,76,🎈,13,27,49,55,04$;

  - 尚未排序的状态记为$L_0$

    - | 49   | 38   | 65   | 97   | 76   | 🎈13  | 27   | 49   | 55   | 4    |      |
      | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |      |


    - 有n=10个元素

  - 第一趟:

  - $取d_1=5,将产生5个子表,每个子表含有\frac{10}{5}=2个元素$

    - $49,13$
    - 38,27
    - 65,49
    - 97,55
    - 76,4

  - 分别将这个5个子表进行直接插入排序

    - 13,49
    - 27,38
    - 49,65
    - 55,97
    - 4,76

  - 然而,实际上,我们采用原地排序,所以5个子表中的元素在排序后,依然占用的是原序列的相应位置

    - 看起来就像是交换位置一样,但是实际的排序过程用的是直接插入排序
    - 当然用其他排序方法也不是不行




- 得到L1:

  - | 13   | 27   | 49   | 55   | 4    | 🎈49  | 38   | 65   | 97   | 76   |      |
    | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |      |

    

- 第二趟:

  - 假设去$d_2=3,产生三个子表,长度分别为4,3,3$

    - 错误做法
      - 49,97,27,4
      - 38,76,49
      - 65,13,55
    - 正确做法(应该基于第一趟排序的结果进行第2趟)
      - 13,55,38,76
        - 13,38,55,76
      - 27,4,65
        - 4,27,65
      - 49,49,97
        - 49,49,97

  - 分别将它原地排序,得到L2

    -  | 13   | 4    | 49   | 38   | 27   | 🎈49  | 55   | 65   | 97   | 76   |      |
       | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
       | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |      |

       

- 第三趟,

  - 假设$d_3=1$,产生1个子表(等于全表了已经)
  - 对这个全表进行排序
  - 得到$L_3$有序序列
    - 4,13,27,38,49,49,55,65,76,97

### shellSor性能分析



#### 增量序列函数

- 时间复杂度
  - 在shell排序算法中,将确定增量序列的函数称为`增量序列函数`
  - 增量序列函数影响着shellSort算法的时间复杂度

- 空间复杂度
  - 借助于常数个辅助空间,空间复杂度为O(1)

### 稳定性

- 不稳定
  - 是由于存在子表的划分
- 仅适用于顺序存储的线性表
  - 因为要随机访问元素


## 希尔排序代码

### (C/C++ code)

```c
/*
 * @Description: 
 * @Version: 2.0
 * @Author: xuchaoxin
 * @Date: 2021-10-07 18:15:45
 * @LastEditors: xuchaoxin

 */
//（174）谢尔（Shell）排序
/*排序思想：进行多趟排序。
本文较为详细的说明了希尔排序的算法及其具体的操作过程,但还是建议先对直接插入排序有较为深刻的了解后再阅读本文(阅读过程中可以对比着看直接插入排序和本文的希尔排序)
三重循环:第一重循环是为了让gap能够取不同的值;
内层的for则是为了对各个gap下所得到的分组子序列并行执行插入排序

在每趟排序中，按照给定的位置增量对元素进行逻辑组的划分，

在每个逻辑组内并行地对元素进行直接插入排序。(既然时基于直接插入排序,那么请务必对直接插入排序做的很熟练(shu'lian),不然怎么指望对shell排序熟练(甚至只是理解代码),可以相互参照对比学习两种算法)

每趟排序所用的位置增量随着算法进行而减少，直到最后一趟，所有元素均分在同一组。(此时只有一组)

因此，Shell排序也称为“缩减增量排序”。*/
#include <iostream>
/**********************************************************
使用Shell增量，对数组r[]中的n个元素进行Shell排序
解释中用到的概念:
划分块:这些块的大小为gap(当然,会随着gap的变小而变小),他们是紧挨在一起的
逻辑分组:也就是待排序子序列,每个逻辑分组中的元素不是紧邻的.但是也有规律,同一个组内的元素相距gap的举例
	*********************************************************/
void shellSort(int r[], /* 保存待排序序列的数组 */
               int n)   /* 原待排序列元素个数 */
{
    int i,   /* 索引变量i,用来表示各个逻辑分组中,待被插入到有序区元素的索引(各无序区中各元素的索引) */
        j,   /* 索引变量j,用来表示各个逻辑分组中,有序区元素的索引,用于构成表达式r[j-k*gap](k=0,1,...和tmp(待插入元素)进行比较
        j的取值趋势时变小*/
        gap; /* 用于划分逻辑分组的增量(也是待排序子序列的元素间的间隔) */
    int tmp; /* 用于保存待插入元素(作用如同直接插入排序中的临时变量一样) */

    /* gap初始化为n */
    for (gap = n; gap > 0; gap /= 2) /* 这一层循环控制gap的取值,用于分配Shell增量序列里的元素：欲让gap_i=N/2, N/4,..., 1时进入循环;gap取不同值gap_i时,将依次把全序列分为gap_i个组(gap_i逐渐减小至1,数列被划分的待排序逻辑组的数量也相应的减少至1组(此时执行的shell排序即为直接插入排序)
    而第i趟排序所划分的每个组所含有的元素数目大约为:n/gap_i 
    注意,各个逻辑组中的元素的分布在原序列中不是连续的*/
    {
        /*对根据当前gap所分成的各个组(子序列)进行并行(或者理解为交叉执行,而不是先将某一个逻辑分组排序完再去拍洗一个分组)的直接插入排序*/
        for (i = gap; /* i初始化为第一个逻辑分组中第一个要被插入的元素(无序区中的第一个元素,而不是该逻辑分组的第一个元素)您可以结合直接插入排序来理解(待排序列的第一个元素本身就被置于有序区,从而,第一个需要被执行插入操作的元素就从对应的待排序序列的第2个元素开始啦.)
        这体现在shell排序中,就是从第二个划分块中的元素分别作为各个待排序的第一个需要被插入操作的元素;
        同时,参考直接插入排序,无序区中的元素需要和位于有序区中的元素一个一个地比较过去,才能够将元素插入到有序区中合适地位置 */
             i < n;   /* 直到原序列中最后一个一个元素被排序(插入到对应分组内的正确位置上) */
             i++)     /* i=gap,gap+1,...,n-1 ;//i增加1,就是切换到下一个逻辑分组序列进行排序;在这gap=gap_i个分组间来回循环切换*/
        {
            /* 以增量gap对元素进行分组(只是想法上的分组,并不直接体现在代码上(存储结构上)，并排序,
        并且,每次排序都是几个子序列一同开始(每次经过for都为某个序列的有序部分增加一个元素,而不是先把某一个序列一次性排完才取排下一个子序列 */
            /* 把r[i] 插入到组中的恰当位置，使得下面的元素序列有序：
            (r[j], r[j-gap], r[j-2*gap]...) */
            tmp = r[i]; /* 待排序元素r[i]暂存到tmp,以免有序区中地元素在往后挪动地时候将r[i]覆盖掉而导致信息丢失 */

            /* 依次检查同一逻辑分组中的元素:r[j-gap], r[j-2*gap]...与待插入元素tmp的关系，若tmp小于当前位置的元素，则把当前位置元素r[j-n*gap]往后移gap个位置 */
            /* 执行直接插入排序,通过j-=gap来计算逻辑分组中逻辑相邻的下一个元素在原始序列中的索引 */
            /*关于j>=gap:j是索引变量,我们需要访问的最小索引 j-gap >= 0,故j>=gap,否则r[j-gap]会出错*/
            j = i;
            int left = r[j - gap]; //要求j-gap>=0,(j>=gap)
            /* 为了完成逻辑组内的排序,您可以用三个值待比较元素tmp,引导变量j,有序区中的元素left(用于和tmp直接比较),left在r[j]前面,在逻辑组内相邻,但是在存储结构上不相邻(距离gap),变量j还可以引导tmp插入到正确的位置上(r[j]在最坏情况下要能够定位到该逻辑分组有序区的第一个元素).
            要求在最坏的情况下,left仍然能够取遍有序区的所有值 */
            for (j = i;                  /* 这里j的初始化:i>=gap,所以j=i>=gap;j_max=i_max=n-1 */
                 tmp < left && j >= gap; /* &&是短路与,j<gap的话,就不会执行r[j-gap],故是安全的,如果j>=gap得以执行,说明此时的tmp将成为本回合排序的最小值,会被置于有序区的第一个元素 */
                 )
            {
                r[j] = left; /*location_1处 ;将相对于当前元素的前gap个间隙位置的元素r[j-gap]后移并覆盖到当前位置j处的元素
                如此,r[j-gap]的值就可以被更小的值所覆盖*/
                j -= gap;//更新j
                left = r[j - gap];//更新left
            }                /*离开此for循环时,j比location_1处又小了(即前进了)gap*/
            /* 当第一次成立tmp>r[j-gap]时或j-gap<0之前tmp<r[j-gap]成立,触发tmp的插入操作 */
            r[j] = tmp; /*location_2 (可以将保存在tmp中的待插入元素插入到(对应分组)正确位置上)*/
        }
    }
}
int main()
{
    int a[] = {3, 5, 1, 0, 9, 8};
    int size = sizeof(a) / sizeof(a[0]);
    printf("size=%d\n", size);
    shellSort(a, size);
    for (int i = 0; i < size; i++)
    {
        printf("%d ", a[i]);
    }
}

```

###  早期版本

```cpp
#include <iostream>
/**********************************************************
使用Shell增量，对数组r[]中的n个元素进行Shell排序
	*********************************************************/
void shellSort(int r[], /* 保存待排序序列的数组 */
               int n)   /* 原待排序列元素个数 */
{
    int i,   /* 索引变量i,用来表示各个逻辑分组中,待被插入到有序区元素的索引(各无序区中各元素的索引) */
        j,   /* 索引变量j,用来表示各个逻辑分组中,有序区元素的索引,用于构成r[j-k*gap](k=0,1,...和tmp(待插入元素)进行比较*/
        gap; /* 用于划分逻辑分组的增量 */
             /* 关于IDE:变量说明(文档)放在分隔符(,或;)之后才能智能提示 */
    int tmp; /* 用于保存待插入元素(作用如同直接插入排序中的临时变量一样) */

    /* gap初始化为n */
    for (gap = n; gap > 0; gap /= 2) /* // 用于分配Shell增量序列里的元素：欲让gap=N/2, N/4,..., 1时进入循环;依次将数列分为gap_i个组(gap_i逐渐减小至1,数列所划分的逻辑组的数量也相应的减少至1组(此时的shell排序即为直接插入排序)
    而第i趟排序所划分的每个组所含有的元素数目为:n/gap_i 
    注意,各个逻辑组中的元素的分布在原序列中不是连续的*/
    {
        /*对根据当前gap所分成的各个组(子序列)进行并行执行的直接插入排序*/
        for (i = gap; /* i初始化为第一个逻辑分组中第一个要被插入的元素(无序区中的第一个元素,而不是该逻辑分组的第一个元素) */
             i < n;   /* 直到原序列中最后一个一个元素被排序(插入到对应分组内的正确位置上) */
             i++)     /* i=gap,gap+1,...,n-1 ;//i增加1,就是切换到下一个逻辑分组序列进行排序;在这gap=gap_i个分组间来回循环切换*/
        {
            /* 以增量gap对元素进行分组(只是想法上的分组,并不直接体现在代码上(存储结构上)，并排序,
        并且,每次排序都是几个子序列一同开始(每次经过for都为某个序列的有序部分增加一个元素,而不是先把某一个序列一次性排完才取排下一个子序列 */
            /* 把r[i] 插入到组中的恰当位置，使得下面的元素序列有序：
            (r[j], r[j-gap], r[j-2*gap]...) */
            tmp = r[i]; /* 待排序元素r[i]暂存到tmp */

            /* 依次检查同一逻辑分组中的元素:r[j-gap], r[j-2*gap]...与待插入元素tmp的关系，若tmp小于当前位置的元素，则把当前位置元素r[j-n*gap]往后移gap个位置 */
            /* 执行直接插入排序,通过j-=gap来计算逻辑分组中逻辑相邻的下一个元素在原始序列中的索引 */
            /*关于j>=gap:j是索引变量,我们需要访问的最小索引 j-gap >= 0,故j>=gap,否则r[j-gap]会出错*/
            for (j = i;                        /* 这里j的初始化:i>=gap,所以j=i>=gap;j_max=i_max=n-1 */
                 j >= gap && tmp < r[j - gap]; /* &&是短路与,j<gap的话,就不会执行r[j-gap],故是安全的 */
                 j -= gap)
            {
                r[j] = r[j - gap]; /*location_1处 ;将相对于当前元素的前gap个间隙位置的元素r[j-gap]后移并覆盖到当前位置j处的元素
                如此,r[j-gap]的值就可以被更小的值所覆盖*/
            }                      /*离开此for循环时,j比location_1处又小了(即前进了)gap*/
            /* 当第一次成立tmp>r[j-gap]时或j-gap<0之前tmp<r[j-gap]成立,触发tmp的插入操作 */
            r[j] = tmp; /*location_2 (可以将保存在tmp中的待插入元素插入到(对应分组)正确位置上)*/
        }
    }
}
int main()
{
    int a[] = {3, 5, 1, 0, 6, 9, 8};
    int size = sizeof(a) / sizeof(a[0]);
    printf("size=%d\n", size);
    shellSort(a, size);
    for (int i = 0; i < size; i++)
    {
        printf("%d ", a[i]);
    }
}
```