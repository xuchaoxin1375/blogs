[toc]

## ref

- [散列表 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/哈希表)

## 散列表Hash的概念

- 散列函数(HF):将`查找表`中的关键字映射成该**关键字对应的地址**的函数
  - Hash(key)=Address of key
  - 元素的地址可以是数组下标/索引/内存地址
- 散列冲突:
  - $key_i\neq key_j,Hash(key_i)==Hash(key_j)$
    - 这类情况称为hash冲突
    - $其中,key_i和key_j$是**<u>同义词</u>**(synonym)
    - 同义词之间一定会冲突
    - 非同义词之间也可能冲突
      - 这发生在冲突处理的过程中
- 散列表(HT:HashTable):
  - 可以根据关键字的值而直接访问(直接得到关键字在散列表中的位置)的数据结构

### 性能

- 理想性能:
  - 对散列表HT进行查找的时间复杂度为O(1)
    - 可见,理想情况下,查找时间和表中的元素个数无关

## 散列函数和构造法

### HF特点

- 散列函数(HF),简单记为H
- 定义域必须包括全部要存储的关键字
- HF特点:HF计算出来的地址应该具有以下特点来减少冲突发生
  - 等概率
  - 均匀分布于
  - 整个地址空间

- 在上面的基础上,散列函数应该尽可能简单
  - 以便能够较短时间内就能够根据任意的关键字key计算出散列地址A=HF(key)

### 直接定址法

- 用线性函数作为H
  - 计算出来的地址是线性函数的值
  - 例如
    - $H(key)=key$
    - $H(key)=a\cdot key+b$
    - 以上几种是线性不冲突散列,
      - 这是因为,它们是严格单调的
  - 适用于关键字分布比较连续
  - 否则会产生较多空位,导致空间浪费
- 除留余数法
  - 假定HT表长度m
  - 取一个接近于m的质数p,作为除数
    - 这种取法可以使得每个关键字散列后的地址等概率的映射到空间的任一地址,减少冲突
    - 如果p太小,会导致冲突频发,降低HT性能
- 数字分析法
- 平方取中法

#### 性能比较

- 不同情况下,不同的散列函数具有不同的性能,不能够简单的说那种散列函数最好,只有更合适的说法
- 实际采用何种构造散列函数取<u>决于关键字集合的情况</u>
  - 目标是尽量降低冲突的可能性

# 处理冲突

- $H_i表示处理冲突中,第i次探测到的散列地址$
  - 散列冲突后第一次处理得到$H_1$
  - $如果key存放到H1处依然导致冲突,在二次处理得到H_2$
  - ...
  - 假设当经过k此处理得到的地址$H_k$不再导致冲突,则$H_k$就是关键字要存放的最终地址

## 开放地址法open addressing

- 冲突处理通项公式:

  - $H_i=(H(key)+d_i)\%m$

    - $更直白一点:H_i=(H_0(key)+d_i)\% m$

      - 定义$H_0=H(key)$为初次计算key的散列,是为了强调H(key)不依赖于前一项$H_{i-1}$

    - 或者说$H_i=(H(key)+d_i)\mod m$

    - | $key$ | $H_0$        | $H_1$         | $H_2$         | ...  |
      | ----- | ------------ | ------------- | ------------- | ---- |
      | $x$   | $R=H(x)=H_0$ | $(R+d_1)\% m$ | $(R+d_2)\% m$ |      |

      

  - 设HT表长度m

  - $d_i是的i次处理的增量;\set{d_i}增量序列$;

    - $i=0,1,2,\cdots,k;(k\leqslant m-1)$
    - 发生冲突的时候,从H(key)的下一个位置开始探测

## 增量序列的取法$d_i$

### 线性探测法LP

-  **[线性探测(Linear Probing)](https://zh.wikipedia.org/wiki/线性探测)**:
  - 相当于逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元
  - 这种方法保证，只要表中还有空余位，那么一定能够最终确定存放位置
    - 探测范围可以覆盖到全表
  - 但是容易造成大量元素在**相邻的散列地址**上堆积起来
    - 这是由于同义词之间或者非同一词之间发生冲突引起
  - 采用LP处理冲突,同义词在HT中也未必相邻
    - 这是由于取模(首尾跳跃性)

### 平方探测法QP

- **平方探测(Quadratic Probing)**
  - 相当于发生冲突时<u>探测间隔$|d_i|=i^2(或:d_i=\pm i^2)$</u>
    - $i=1,2,\cdots,k;(k\leqslant \frac{m}{2})$
    - 如果为空，将地址存放进去。
  - 该方法可以较好避免堆积
  - 探测覆盖不了全表单元,但至少覆盖一半

### 伪随机探测RH

- 伪随机数序列，称为 **伪随机探测**。

### 双散列法DH

- **双杂凑**(Double hashing)

- $d_i=i\cdot H_2(key)$

## 拉链法(Chaning)

- 将同义词放在一个链表中
  - 这就比较容易进行插入和删除
  - 指针数组保存指向同义词的链表的指针,本身并不存储元素

## 查找

- 散列的查找过程和构造过程基本一致

### 判断查找失败🎈🎃

- 这在求解查找失败的平均查找长度的时候至关重要

  - Average Search Leagth(of SearchFailed)$ASL_{sf}=\sum\limits_{i=1}PF_i\cdot CF_i$

  - P表示概率,PF表示失败概率,$PF_i表示查找第i类失败情况下的概率$

  - C表示查找/比较次数,CF表示查找失败比较的次数,$CF_i表示确定下来是第i类查找失败需要的比较次数$

    

- 主要关注查找失败的确认/条件
  - 一般的,只有当查找到记录为空的时候才认定查找失败
    - 但是某些时候,我们可以加快判断失败是否已经发生
      - 例如.散列表长度为m中已经插入的元素为n个
        - 不妨将元素分为两类$n=n_0+n_+$
          - $n_0表示该元素在插入的时候,没有冲突,插入之后也没有同义词的元素数量👩$
          - $n_+表示当前的HT已经有同义词$
        - 另外要注意,散列函数不总是能够将关键字映射到散列表中的所有位置
          - 比如除留余数法(A=key%p),散列结果地址只在0~p-1,如果散列表的表长大于p-1,会出现有些位置是散列函数值域意外的位置,这些位置可以留给冲突发生是的元素插入
      - 现在我试图在这个HT中查找元素x,下面我们仅分析查找失败的情况
        - $如果H(x)的地址A_x上存在元素y,x\neq y$
          - $若y\in n_0集合,那么直接认定查找失败$
            - $因为在找下去也是徒劳的,HT中没有第二个被散列到A_x,自然就不可能成功$
          - $但是,如果y\in n_1$,那么第一次匹配失败不足以说明查找失败,因为HT还有其他元素有希望匹配上
            - 只有当冲突处理比较到某个空位置,才宣告失败
  - 或者给定的冲突处理方案中的所有可能位置都访问过还找不到对应值,则查找失败
    - 比如LP探测法,$d_i=0,1,\cdots,m-1全都遍历$还是没有找到关键字,那么查找失败
      - $H_0+d_i足以将权HT的位置全部访问一遍$

## HT的性能

- 由于冲突的存在,需要用平均查找长度ASL作为衡量散列表HT查找效率的度量

### 查找效率三要素

- 散列函数
- 处理冲突的方法
  - 开放地址法
    - 增量确定:
      - LP
      - QP
      - RH
      - DH
  - 拉链法

### 装填因子$\alpha$

- $\alpha=\frac{n}{m}$
  - 其中,n为散列表中现有的记录数
  - m为散列表的长度