---
marp: true
---

# 编程实现多理发师问题

## synopsis

> - In [computer science](https://en.wikipedia.org/wiki/Computer_science), the **sleeping barber problem** is a classic [inter-process communication](https://en.wikipedia.org/wiki/Inter-process_communication) and [synchronization](https://en.wikipedia.org/wiki/Synchronization) problem that illustrates the complexities that arise when there are multiple [operating system](https://en.wikipedia.org/wiki/Operating_system) [processes](https://en.wikipedia.org/wiki/Process_(computing)).[[1\]](https://en.wikipedia.org/wiki/Sleeping_barber_problem#cite_note-1)
>
> - The problem was originally proposed in 1965 by computer science pioneer [Edsger Dijkstra](https://en.wikipedia.org/wiki/Edsger_Dijkstra),[[2\]](https://en.wikipedia.org/wiki/Sleeping_barber_problem#cite_note-little-2) who used it to make the point that general semaphores are often superfluous.[[3\]](https://en.wikipedia.org/wiki/Sleeping_barber_problem#cite_note-ewd-3)

___
## Problem statement(问题描述&分析)
___
### pseudocode(c style)

```c
/*理发师进程*/
void barber()
{
    while(true)
    {
        P(num_wait);   //尝试获得一位顾客，如果没有，去睡觉
        //至此,如果获得了一位顾客,则进一步执行统计量修改:该顾客前往理发椅,所以等待椅就被释放掉,体现在等待椅统计量上,空闲等待椅数量+1(当然,由于统计量是临界资源(对于顾客和理发师进程都是如此,因此修改的时候要通过互斥信号量的方式操作));
        P(accessSeat);   //尝试获得椅子锁，更改空闲椅子数目
        seat_free++;    //空椅子加1
        //释放多个信号量的时候,顺序不重要(但是请求的时候是讲究顺序的(同步信号量在互斥信号量之前,否则可能交叉等待导致死锁))
        V(baberReady);    //理发师准备好了
        V(accessSeat);    //无需继续锁着椅子(统计量)
        理发;
    }
}
```
___

```c

/*顾客进程*/
void customer()
{   
    while(true)
    {
        P(accessSeat);  //试图坐下(等待椅)
        if(seat_free > 0)
        {
            seat_free--;  //坐下
            V(num_wait);  //试图唤醒理发师，
            V(accessSeat);  //不用再锁着椅子
            P(baberReady); //等待理发师ready
            理发;
        }
        else
        {
            V(accessSeat);  //释放加在椅子上的锁
            离开;
        }
    }
}
 

```


___

## 本实验目的

- 主程序中可以输入
  - 椅子的数量、
  - 理发师的数量（可大于1）以及
  - 顾客流量（10~20），

- 多个**顾客线程**和**理发师线程**应该能够**正确的并发执行**。
- 程序应输出**并发执行的过程**，

- 能够**正确统计并显示每个理发师服务的顾客数**，以及**因无座位直接离开的顾客数(有座位的话,顾客还有耐心等,无座没有就不等了)**。


___
### 算法描述与解决方案
___

#### 信号量

- 信号量的使用操作系统通常区分**计数信号量**与**二进制信号量**。
- 计数信号量(countingsemaphore)的值不受限制，而二进制信号量(binarysemaphore)的值只能为0或1。
- 因此，二进制信号量类似于互斥锁。事实上，在没有提供互斥锁的系统上，可以使用二进制信号量来提供互斥。
- 计数信号量可以用于**控制访问具有多个实例的某种资源**。
- 信号量的初值为可用资源数量。
- 当进程需要使用资源时，需要对该信号量执行wait操作(减少信号量的计数)。
- 当进程释放资源时，需要对该信号量执行signal操作(增加信号量的计数)。
- 当信号量的计数为0时，所有资源都在使用中。
- 之后，需要使用资源的进程将会阻塞，直到计数大于0。

___

#### 数据结构

- 主要使用了linux系统提供的信号量(`sem_t`)
  - 用于实习进程的同步&互斥

```c
typedef union
{
  char __size[__SIZEOF_SEM_T];
  long int __align;
} sem_t;

```
___
- linux 系统提供的`timeval`
  - 用户获取微秒级的种子,辅助得到不同的随机数序列

```c
struct timeval
{
  __time_t tv_sec;		/* Seconds.  */
  __suseconds_t tv_usec;	/* Microseconds.  */
};
```


___


### 算法原理
___
#### 实体分析

- 顾客

  - 正在理发的
  - 有座位坐着等的
  - 无座位而离开的

- 理发师

  - > 这里可假设理发师有自己的理发椅座位,!

  - 没有活干,睡觉的(睡觉行为可以通过理发师自我阻塞模拟)

  - 正在干活的

  - 试探有没有下一位顾客的

- 座位

  - 有人占用的
  - 空闲的的

> 三种实体的数量可以通过键盘输入指定

___

#### 资源分析
#####  临界资源

> 为每种临界资源设置对应的计数变量
>
> 为每个计数变量设置互斥信号量(因为计数变量需要互斥地访问)

- 处于等待状态的顾客数量(计数变量)

- 直接离开顾客数量(计数变量)

- > 等待用的椅子数量

  - 由于空闲椅子数量和处于等待状态顾客只需要直到一方,就可以直到另一方,所以二选一即可实现算法,我选择顾客数量
___
####  竞争资源(实体)
- 理发师

- 顾客

____

### 同步&互斥关系

#### 同步关系

- 理发师和顾客是同步关系:理发师等待顾客来，然后为顾客服务，顾客来了之后叫醒理发师，<u>执行上是有先后顺序的，所以应该有两个**同步信号量**，且散在两个进程里；同步关系是对称的

#### 实体(线程)间互斥关系

- 顾客之间有互斥关系(对理发师的访问,一个理发师一次只能为一个顾客服务)
  
- 顾客和理发师之间有互斥关系(访问(读/写)顾客计数变量)
  
- 理发师之间有互斥关系(对顾客的访问,一个顾客一次只能被一个理发师服务)

> 不区分谁服务谁,只关心可用资源数


___

#### 信号量设置

- 理发师barber_sem
- 处于等待状态的顾客customer_sem
- 用于实现互斥的信号量mutex
  - 或者采用空闲座位的数量的统计量numberOfFreeWRSeats
- 专用信号量cc_mutex:用于实现顾客和顾客间的对计数变量的的互斥访问(防止因共用通用互斥量mutex多余的互斥关系)


___
#### 理发师进程&用户进程

- 所有理发师使用相同的程序段
- 所有顾客使用相同的程序段
- 需要两类进程Barber ()和Customer()分别描述理发师和顾客的行为。
___
##### 顾客行为:

- 顾客到店,互斥地访问/检查是否有等待椅子可以入座(或者**判断当前已经处于等待状态的顾客数量(waiting_customers)**和椅子总数量seat_num的大小)

- 试图坐下等待(互斥的访问已有顾客数量,并与椅子总数比较)
- case1:如果有空位:
  - 试图**唤醒理发师(V(num_wait)**,告诉理发师,现在顾客来啦;(同步关系)
  - 互斥地将统计变量(等待理发的顾客数waiting_customers)+1
    - 或者,另一种方案:将空闲位置数量-1自己占用的**等待椅**子
  - **等待**理发师准备完毕来为他执行理发(P(babers))
  - 享受理发过程
  - 完事后顾客线程结束
- case2:没有空位,(释放掉互斥锁)直接离开
___

##### 理发师行为:

- 理发师的工作逻辑是一个循环
- 互斥地检查等待理发的顾客数量(waiting_customers)
  - case1:如果发现没有等待服务的顾客,那么理发师睡眠(等待被顾客唤醒)
  - case2:如果发现尚有顾客在等待服务,那么理发师先主动的广播:我现在空闲(以便顾客线程可以继续至结束)
    - 互斥地将等待的顾客数计数变量(waiting_customers)-1
    - 等待顾客正式的唤醒自己:(顾客通过wait(barbers_sem)来唤醒处于阻塞(睡眠状态)的理发师)
      - 理发师通过wait(customer_sem)接受顾客的唤醒
      - 模拟理发过程(并报告耗时)
    - 更新所有理发师总业绩和当前理发师业绩
    - 进入理发师线程循环的下一轮,依然判断是否等待的需要理发的顾客唤醒他(wait(customer_sem))(这一点和顾客进程不同,理发师要重复劳动,不应该挂掉)

___
###  流程图


![](https://static01.imgkr.com/temp/794db837c0b84777a116175633f044ef.png)

___

![](https://static01.imgkr.com/temp/82c1d7e0262845ebae14c22ea3ff58bb.png)

___



### 相关调用

- Linux信号量工具：
  \#include<semaphore.h>中定义了很多信息量操作中常用的数据结构和系统函数，下面罗列本次实验将用到的：
  **sem_t**：具体信号量的数据结构
  **sem_init** ：用于创建信号量，并能初始化它的值
  **sem_wait**：相当于wait操作
  **sem_post**：相当于signal操作

- POSIX线程相关：
  \#include<pthread.h>中用到的数据类型和函数如：
  **pthread_t**：用于声明线程ID
  **pthread_create** ：创建一个线程
  **pthread_join**：阻塞当前线程，直到另外一个线程运行结束
___


### 实验数据&结果
___
#### 随机时间策略1

- 顾客到来的时间应该有较明显的不确定性,如果使用usleep(big integer)来模拟到来时间,可以达到更好的模拟效果
- 而理发师的理发速度可以相对稳定一些,一般的波动即可
- 理发师的理发速度不宜过快,否则用户一来就可以被理发,不容易观察到满座的的情况

```bash
#( 06/02/22@ 3:17PM )( cxxu@cxxuAli ):~/cppCodes/barber@master✗✗✗
   barber_brief                                
请输入椅子数目:3
请输入理发师数目:2
请输入顾客数目:11
-----@visit_time_gap:31324
********没有顾客,第 2 号理发师正在睡觉!*********
********没有顾客,第 1 号理发师正在睡觉!*********
-----@visit_time_gap:222639
```
___
```
第 1 号顾客进店...
        第 1 号有椅子🆗,坐下等待理发,等待理发的顾客数:1
        🤷‍♂️顾客请求一位理发师!
  💇‍♀️理发师2开始理发,服务人数:1
        😎一位顾客正在理发,还在等待理发的顾客数: 0
-----@visit_time_gap:38952
第 2 号顾客进店...
        第 2 号有椅子🆗,坐下等待理发,等待理发的顾客数:1
        🤷‍♂️顾客请求一位理发师!
  💇‍♀️理发师1开始理发,服务人数:1
        😎一位顾客正在理发,还在等待理发的顾客数: 0
-----@visit_time_gap:119302
```
___
```
第 3 号顾客进店...
        第 3 号有椅子🆗,坐下等待理发,等待理发的顾客数:1
        🤷‍♂️顾客请求一位理发师!
-----@visit_time_gap:109190
第 4 号顾客进店...
        第 4 号有椅子🆗,坐下等待理发,等待理发的顾客数:2
        🤷‍♂️顾客请求一位理发师!
😁一位顾客理发结束!
        @为该顾客理发耗时201
@理发师1被唤醒!  💇‍♀️理发师1开始理发,服务人数:2
        😎一位顾客正在理发,还在等待理发的顾客数: 1
-----@visit_time_gap:79013
第 5 号顾客进店...
        第 5 号有椅子🆗,坐下等待理发,等待理发的顾客数:2
        🤷‍♂️顾客请求一位理发师!
😁一位顾客理发结束!
        @为该顾客理发耗时172
@理发师2被唤醒!  💇‍♀️理发师2开始理发,服务人数:2
        😎一位顾客正在理发,还在等待理发的顾客数: 1
-----@visit_time_gap:40269
第 6 号顾客进店...
        第 6 号有椅子🆗,坐下等待理发,等待理发的顾客数:2
        🤷‍♂️顾客请求一位理发师!

```
___
```
😁一位顾客理发结束!
        @为该顾客理发耗时512
@理发师1被唤醒!  💇‍♀️理发师1开始理发,服务人数:3
        😎一位顾客正在理发,还在等待理发的顾客数: 1
-----@visit_time_gap:90959
第 7 号顾客进店...
        第 7 号有椅子🆗,坐下等待理发,等待理发的顾客数:2
        🤷‍♂️顾客请求一位理发师!
-----@visit_time_gap:191059
第 8 号顾客进店...
        第 8 号有椅子🆗,坐下等待理发,等待理发的顾客数:3
        🤷‍♂️顾客请求一位理发师!
-----@visit_time_gap:136344
第 9 号顾客进店...
💔 没有座位,第 9 号顾客离开!离开人数累计达到:1
-----@visit_time_gap:165379
第 10 号顾客进店...
💔 没有座位,第 10 号顾客离开!离开人数累计达到:2
😁一位顾客理发结束!
        @为该顾客理发耗时646
@理发师2被唤醒!  💇‍♀️理发师2开始理发,服务人数:3
        😎一位顾客正在理发,还在等待理发的顾客数: 2
😁一位顾客理发结束!

```
___
```
        @为该顾客理发耗时49
@理发师2被唤醒!  💇‍♀️理发师2开始理发,服务人数:4
        😎一位顾客正在理发,还在等待理发的顾客数: 1
第 11 号顾客进店...
        第 11 号有椅子🆗,坐下等待理发,等待理发的顾客数:2
        🤷‍♂️顾客请求一位理发师!
😁一位顾客理发结束!
        @为该顾客理发耗时329
@理发师1被唤醒!  💇‍♀️理发师1开始理发,服务人数:4
        😎一位顾客正在理发,还在等待理发的顾客数: 1
😁一位顾客理发结束!
        @为该顾客理发耗时895
@理发师2被唤醒!  💇‍♀️理发师2开始理发,服务人数:5
        😎一位顾客正在理发,还在等待理发的顾客数: 0
😁一位顾客理发结束!
        @为该顾客理发耗时418
😁一位顾客理发结束!
        @为该顾客理发耗时418
第 1 号理发师服务人数:4
第 2 号理发师服务人数:5
理发师服务顾客总数:9
直接离开的顾客总数:2

```
___

