[toc]



# 规格化浮点数以及规格化

* 为了提高浮点数的`精度`,其**尾数**必须为规格化数。
* 🎈下面讨论的**小数**均为**原码**表示
* 如果不是规格化数,就要通过`修改阶码`并`同时左右移尾数`的办法,使其变成规格化数。
* 将非规格化数转换成规格化数的过程称为**规格化**。(等值转换)
  * 对于`基数`不同的浮点数,因其规格化数的`形式不同`,`规格化过程也不同`。

## 不同基数下的浮点数的规格化数判断

* 当基数为2时,`尾数最高位为1`的数为规格化数。
  * 设被规格化的数为$F_{r=2}$
  * 即,规格化数的**尾数**的绝对值不小于$\frac{1}{2}$
  * 规格化时分为左归和右归
    * `尾数左移`1位($F_2$总大小相当于被乘以2,那么为了保持大小不变,必须再除以2,
      * 这可以通过将<u>阶码减1</u>(这种规格化称为向左规格化,简称`左规`);
      * 根据需要,反复执行上述操作
      * 比如对$F_2=2^{3}\cdot0.001$执行2次左归操作,得到$F_2=2^{1}\cdot{0.1}$

    * `尾数右移`1位,阶码加1(这种规格化称为向右规格化,简称`右规`)。
      * 和左归是相反的操作
      * 比如对$F_2=2^{3}\cdot111.01$执行2次右归操作,得到$F_2=2^{5}\cdot{0.1101}$

* 当基数为4=$2^2$时,尾数的`最高两位不全为零`的数为规格化数。
  * 设被规格化的数为$F=F_{r=4}=4^j\cdot{S_fS_1S_2\cdots{S_n}}$
  * 规格化时,尾数**左移2位,阶码减1** ;
  * 尾数**右移2位,阶码加1**。
  * 通俗的讲,就是规格化要考虑到基数,其指数(阶码的+1/-1)就会导致整个数F的大小乘以或者除以4
    * $4=2^2$从而造成尾数S的连续2次的移位

  * 因此,如果最高位两位$S_1S_2=01$,那么是无法仅仅将二进制串左移一位来消掉尾数$S_1=0$的,因为阶码变化1,整个值会变化4倍(或者说除以4);导致操作前后的值不想等,因此,只能够认为,$S_1S_2=01$也是属于基数r=4下的规格化数

* 当基数为8=$2^3$时,尾数的**最高三位不全为零**的数为规格化数。

  * 规格化时,尾数左移三位,阶码减1;
  * 尾数右移三位,阶码加1。

## 🎈小结:规格化数和规格化的推广

* $当基数为r=2^k时,$**尾数的最高k位不全为0**的浮点数是规格化数
  * 左归规格化时,尾数每左移k位,阶码减去1
  * 有规格化时,尾数每右移k位,阶码加上1
* 浮点机中一旦基数确定后就不再变了
* 而且基数是隐含的,故不同基数的浮点数**表示形式**完全相同。
  * 但基数不同,对数的表示**范围和精度**等都有影响。
  * 一般来说,基数r越大
    * 可表示的**浮点数范围越大**
    * 可表示的数的个数越多。
    * 但是**浮点数的精度**反而下降。
      * 如r = 16的浮点数,因其规<u>格化数的尾数最高三位可能出现零</u>,故与其<u>尾数位数相同的r =2的浮点数</u>相比,后者可能比前者<u>多三位精度</u>。

### 🎈规格化浮点数的表示范围

- 规格化数的表示范围和非规格化数的表示范围由所不同
- 主要变化就体现在**尾数S**上
- 根据上面的分析,规格化数的尾数S的绝对值有范围约束:
  - 就是规格化数F的**绝对值**$|S|\in{[\frac{1}{R},1]}$,设$R=2^k$
    * $比如,r=2,规格化后的|S|\in[\frac{1}{2},1]$
    * 对于负规格化浮点数(S<0):
      * $S\in[R^{-1}-1,R^{-1}]$
        * $例如R=4,S\in[-\frac{3}{4},-\frac{1}{4}]=[1.11_2,1.01_2]$
    * 对于正规格话数(S>0):
      * $S\in[\frac{1}{4},\frac{3}{4}]=[0.01_2,1.11_2]$



## 规格化数的补码形式

- 仅讨论基数为$r=2^1$的情况:

  - $规格化数x=x_0.x_1\cdots{x_n}的绝对值|x|\in[\frac{1}{2},1)$

    - 更具体的应该是:

      - $x\in[-1,-\frac{1}{2}]\cup[\frac{1}{2},1)$
      - 可以去到-1是补码定点小数补码能够表示-1这一点为基础
      - 这里不讨论原码表示

    - $x>0时,x=+0.1\cdots$

      - $x\in[\frac{1}{2},1)$
      - $C(x)=T(x)=0.x_1x_2\cdots=0.1\cdots$
        - 其中$x_1=1$
      - $双符号位:C(x)=00.1\cdots$

    - $x<0时$

      - 根据区间的对称性:$x=-0.1\cdots$
      - $设C(-x)=C(-0.1\cdots)=b_0.b_1b_2\cdots=1.?$
        - $b_0$:
          - 由于$-x<0$,我们可以确定$b_0=1$
        - $b_1:$
          - cases1:$b_1=0$
            - $如果x_2\cdots{x_n}中部分二进制串中有1,那么C(-x)=b_1=\overline{x_1}=0$
          - cases2:$b_1=1$
            - $否则,x_1=1$就是小数数值部分的从低位到高位出现的第一个1(其余位都为0)
              - 它使得$b_1\cdots{b_n}=x_1\cdots{x_m}$
              - 即有$b_1=x_1=1$
              - [为什么是这样,查看推导](https://blog.csdn.net/xuchaoxin1375/article/details/118102839)
            - 这种情况下,尾数真值$x=-\frac{1}{2}$
              - $C(x)=1.10\cdots{00}$
            - 🎈为了便于硬件判断,特别规定这种情况(x=$-\frac{1}{2}$)不是规格化数!
            - 🎈尾数真值为-1时,认定为是规格化数
              - 既然不是规格化数,就需要规格化
              - 在讨论算数移位的时候,我们知道,补码的符号位和第一位有效位相等时,配合阶码-1(基数r=2时),执行移位操作不会发生错误,而且保持等值
              - $这就得到了C(x)=1.10\cdots0移位后的结果C(x)=1.0\cdots{0}$
                - 这个真值恰好是-1
                - 定点小数恰好能够表示-1
                - $用双符号位表示C(x)=11.0\cdots{0}$
        - 因此,综上,当x的补码形式C(x)的符号位和第一位数值位不同时,(即$x_0\neq x_1$时),该浮点数是规格化的
      - $双符号位:C(x)=11.0\cdots$

    - 总综合上述结论:当以<u>补码形式表示的位数S的符号位和第一位数值位相异(不同)时,就是规格化数</u>

      

### 补码规格化数下的最值形式



- 补码规格化尾数的==最大负数形式==为  $1.01 \cdots 1$ ,
- 而不是原码的形式  $1.10 \cdots 0_{原}$(对应真值为$-\frac{1}{2}$) ,

- $1.10 \cdots 0$  不是补码规格化数，所以规格化尾数的最大负数是  $-(0.10 \cdots 0+0.0 \cdots 01)_{真}=-0.10 \cdots 01_{真}$ ,
- 而  $(-0.10 \cdots 01)_{补}=1.01 \cdots 1$



### 左规

#### 例子

![1646383455850](https://img-blog.csdnimg.cn/img_convert/230bc596595ea301e893dfc8ee24c5f6.png)

### 右规

#### 伪溢出

* 当**尾数**出现01.x x…×或10.x x…x时,表示**尾数(顶点数)溢出**,这在`定点加减运算`中是不允许的,
* 但在`浮点运算`中这不算溢出,可`通过右规处理`。
  * 右规时尾数右移一位,阶码加1





