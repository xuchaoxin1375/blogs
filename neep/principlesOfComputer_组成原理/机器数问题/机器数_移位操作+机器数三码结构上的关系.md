[toc]

# 定点数的移位运算

## 算数移位

- 算数移位的对象是有符号数(机器数)
  - 移位过程中,**符号位**保持不变
  - 相当于对被移动的**有符号机器数**$x$的真值(二进制形式)做相应的移动

### 算数移位的实质

- $设真值x的机器码为X(x)$
  - X可以取(原码/补码/反码)函数中的任意一个
- $对X(x)进行算数移位,就是为了对真值x进行乘以基数r或者除以基数r的操作$
  - 十进制数中也有类似的操作,只不过通常我们移动的是小数点,来达到类似的效果
  - 二进制计算机以2为基数;十进制数以10为基数
  - 移位之后,真值需要补位(而且总是补0)
    - 左移引起低位缺失,补0
    - 右移引起高位缺失,补0
- 而二进制机器码对真值的0/1串做了处理,因此对应到机器码里的补位需要分别讨论

## 逻辑移位

- 逻辑移位将操作数视为**无符号数**
- 移位和添补规则:
  - 逻辑左移:
    - 高位移丢
    - 低位添0
  - 逻辑右移:
    - 低位移丢
    - 高位添0

### 对比算数移位

- 逻辑移位将寄存器中的数最高位视为数值位,一并参与移动
- 算数右移:(以单符号位为例)
  - 不移动最高位(符号位),被移动的位从第二位开始

#### 例

- 寄存器中的内容为:**<u>x=10110010</u>**
  - 对其进行逻辑右移
    - 01011001
  - 对其进行算数右移
    - 如果将其视为补码,做右移1位操作:1,1011001
  - 为了避免上述x左移最高位丢1,可使用带进位($C_y$)的左移(将**符号位**)移入$C_y$

## 循环移位

- 分为:
  - 带进位标志CF的循环移位(大循环)
  - 不带进位标志的循环移位(小循环)
- 主要特点
  - 移除的数位又被移入到数据中
  - 是否带进位:取决于是否将进位标志CF加入循环移位

- 循环移位特别适合将数据的低字节数据和高字节数据互换

##  二进制移位操作

- 计算机中小数点的位置是事先约定的,

  - 因此,二进制表示的==机器数==在相对于小数点作n 位左移或右移时,**其实质就是**该数乘以或除以 $2^{n}(n=1,2, \cdots, n)$

  - 对于带符号数$s=\pm\sum\limits_{i=0}^{n}x_i2^i$

    - 左移一位(如果产生溢出)相当于乘以2

    - 右移一位(如果不考虑被因移位而被舍去的末尾位),相当于除以2

      



#  🎈单符号位定点小数的移位操作

## 结论 

- 负数的补码左移,低位补0(空位产生于低位)
- 负数的补码右移,高位补1(空位产生于高位)
- ![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062211063166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)



### 声明

- 尽管您不记得该表格了,但是只要您会把不同机器码转为原码(或真值),您就可以通过原码来作为中介,通过原码的移位结果计算回转换前的机器码形式,也可以得到结果.

## 补位解释

- 总结出来的三种机器码的**移位填补规则**
  - 在负数部分,三种机器码的移位添补规律虽然各有不同特点
  - 但是体现在**真值**上的移位效果则较为一致:**<u>都是对真值进行补0</u>**

### 正数

- $由于x的原码,补码,反码相同,即:T(x)=C(x)=C_1(x)$

  - 所以,它们的补位操作一致

  - 我们以**原码**的补位为代表,容易知道,补的数是0

    

### 负数

- $机器数对应的真值x为负数时$

  1. 由于负数的原码数值部分与真值相同,故在移位时只要使符号位不变,其空位均添即可。

  2. 由于负数的反码各位除符号位外与负数的原码正好相反,故移位后所添的代码应与原码相反,即全部添1。

  3. 分析**任意负数x的补码T(x)**可发现
     - 从T(x)**由低位向高位**找到第一个“`1`”时(为了方面描述,称这个1为$x_\alpha$(即,第$\alpha$位小数$x_\alpha=1$))

     - $x_\alpha$左边的各位均**与对应的反码相同**

     - $x_\alpha$右边的各位(包括此$\alpha$在内)均**与对应的原码相同**

       - 🎈这个规律(现象是在移位操作之外就存在的),下面会给出推导过程

     - 故负数的补码左移时,因空位出现在低位,则添补的代码与原码相同,即添0;

     - 右移时因空位出现在高位,则添补的代码应与反码相同,即添1

       

##  🎈例子

- 设**机器数字长为 8 位**  (  含 1 位符号位  ) ,

  -  若整数$A=\pm 26$,1

  -  写出三种机器数左,右移一位和两位后的表示形式及对应的真值,

  -  并分析结果的正确性:

### 正数例子

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120806753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

  - 可见,对于正数,三种机器数移位后符号位均不变


  - 左移时最高数位丢1,结果**出错**;

  - 右移时最低数位丢1 ,影响**精度**。

### 负数例子

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120841344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

#### 🎈负数补码例

- 和移位前的二进制代码做对比

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120927890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

- 以下精度问题规律,可以从原码出发举例体验.

  - 负数的原码左移时,高位丢1,结果出错;右移时,低位丢1,影响精度。

  - 负数的补码左移时,高位丢0,结果出错;右移时,低位丢1,影响精度。

  - 负数的反码左移时,高位丢0,结果出错;右移时,低位丢0,影响精度。



# 🎈 双符号位算数移位

## 结论

- 双符号位具有判断溢出的便利特点
  - 当两位符号位相同(无溢出时)
    - 此时两位符号位都表示**真实符号位**
    - 移位规律按照**单符号位**的移位规律执行(补位)
  - 当两位符号位不同(溢出)
    - 此时**低位符号位**不是真实符号位!
      - 可将其理解为数值位
      - 此时对该位数进行右移,不会导致高位缺失!
      - 因此不需要补位,只需要将低符号位一并右移即可
      - 最后高符号位复制一份,覆盖低符号位即可
    - **低位符号位需要参与移动**,**高位符号位不参于移动**

## 解释



- 为了更加更好的理解,稍做推导

- $$
  设双符号位数x,y(补码):
  \\C(x)=x_{-1}x_0,x_1\cdots
  \\C(y)=y_{-1}y_{0},y_1\cdots
  \\C(s)=x+y=s_{-1}s_{0},s_1\cdots
  \\假设x,y是同号(y_{-1}=y_{0}=x_{-1}=x_{0}),同时x+y会引发进位:
  \\即:x_1+y_1+C_{2}\in\set{2,3}
  \\C_i表示从最低位(C_n)执行加法进位直到第i位相加产生进位
  \\(C_i将参与x_{i-1}+y_{i-1}+C_i运算)
  \\这种情况下,s_0=x_0+y_0+C_1产生的进位是有数值含义(位权)
  \\应该让s_0参与移位(通常在浮点数右归中操作)
  \\s_{-1}代表结果的真实符号位
  $$

  

- 符号位不参与移动

  - 符号位是单独处理(保持),
  - 在单符号位的**算数移位**中也是不参于移位的)

- 下面介绍的两数相加进位规律告诉我们,双符号位最高位为什么是最终(两数相加减真实正确结果)的符号位

  - 两数相减在计算机中也是转换为加法运算,因此仅讨论加法
  - 该规律只是原因之一,可以结合真值表来完整证明

## 例(补码双符号位)

- 一般双符号位移位在补码上用的比较多,(双符号位法计算**补码浮点数**加/减法中的规格化中会遇到)

- 对下面的双符号位小数(**补码**形式)进行移位操作
  - 00.11000
    - 00.01100
  - 11.110001
    - 11.1110001
  - 01.110001
    - 00.1110001
  - 10.110001
    - 11.0110001



#  🎈负数的补码与原码和反码在二进制串的结构上的关系

- 补码的左右移位的填补规则依赖于如下规律

- 下面仅讨论<u>定点小数</u>的情况,整数的情况手法类似,结论适用

- 对于$x<0$;

  - 机器字长为n+1;符号位占走1位,有n位留给数值位

  - 原码$T(x)=1.x_1x_2\cdots{x_m}\cdots{x_n}$

    - 假设从低位到高位观察T(x)的小数部分,第一个值为1的位值出现在$x_m$这个位置上

    - 换句话说,如果没有<u>精度/机器字长补齐</u>要求,那么$x_{m+1}\cdots{x_n}$这部分的小数位都是0,它们可以不写

  - $反码C_1(x)=1.\overline{x_1}\ \overline{x_2} \cdots{\overline{x_m}}\cdots{\overline{x_n}\ }$
  
    - $$
      1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_m}}\cdots{\overline{x_n}\ }
      =1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_{m-1}}}\underset\blacktriangle{0}
      \underbrace{1\cdots{11}}_{\overline{x_{m+1}}\cdots\overline{x_n}}
      $$

      

  - 补码$C(x)=c_0.c_1\cdots{c_n}=x_0.c_1\cdots{c_n}$:
  
    - $$
      C(x)
      =C_1(x)+2^{-n}
      =1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_{m-1}}}\underset\blacktriangle{0}
      \underbrace{1\cdots{11}}_{\overline{x_{m+1}}\cdots\overline{x_n}}
      +2^{-n}
      \\=1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_{m-1}}}\underset\blacktriangle{1}
      \underbrace{{0}\cdots{00}}_{\overline{x_{m+1}}\cdots\overline{x_n}}
       
      $$

  - 🎈可见,$x_m$是无论是$T(x)还是C(x)$

    - 从低位开始向高位扫描的过程中最早出现的码值1都是同一个位置($x_m$)出

  - 🎈同时:
  
    - 真值x的补码C(x)的数值位分为<u>两部分</u>:
      - $c_1\cdots{c_{m-1}}=\overline{x_1}\ \overline{x_2}\cdots 
        \overline{x_{m-1}}$
        - 即,这部分和**反码**相同
        - 为了便于描述,记$A=c_1\cdots{c_{m-1}}$
      - ${ c_m}\cdots{c_n}$=$x_m\cdots{x_n}$
        - 部分和**原码**相同
        - 记$B=c_m\cdots{c_n}$
    - m的常规取值范围为$[1,n]$
    - 极端情况下:
      - $A的长度是0,B的长度为n:$
      - $m\leqslant{1}时,无论x的正负,补码和原码具有一样的形式(C(x)=T(x))$
        - 这种情况下可以在分为两种具体情况:
          - $m=-\infin$
            - 意思是数值位最高位到最低位全部为0
            - 不使用$m=0$表示是为了和符号位区分开来
            - 即$C(x)=x_0.0\cdots{00};x=0$
              - 或$C(x)=x_0,0\cdots0;x=0$
          - $m=1$
            - 意思是数值位最高位为1,其余数值位全为0
            - 即$C(x)=x_0.10\cdots{00}$,$x=\pm\frac{1}{2}$
              - 或$C(x)=x_0,10\cdots{00}$,$x=\pm{2^{n-1}},n是数值位位数$
      - $m\geqslant{n+1}$
        - 这种情况下,
  
  - 🎈上面两个结论对于$x>0$的是时候也显然是成立的(因为$x>0$时,原码补码反码一致!)
  

## 高位部分

- 一般的,我们对补码$C(x)$所对应的真值大小比较感兴趣
  - 这关乎到溢出判断和规格化操作的判断
- 然而体现数的大小,主要看从高位比较到低位
- 🎄下面的讨论比较啰嗦,个人认为上面的讨论更加有品位,而且更加体现概率统计的习惯
- 根据上述结论,数值位第一位开始到第m-1位$x_1\cdots{x_{m-1}}$这部分是x的反码A(x)相同
  - 对这部分每位取反,即可得到原码在这部分位置的取值(也就是高位小数位的取值)
- 设:$C(x)=x_0.x_1\cdots{x_n}$
  - $x_1\cdots{x_n}$至少有一个bit取1($x\neq{0}$)
    - $x_1=0$
      - $x_2\cdots{x_n}中至少有一个1$
        - $T(x)=x_0.1\cdots,|x|\geqslant{\frac{1}{2}}$
    - $x_1=1$
      - $x_2\cdots{x_n}$至少有一个bit取1
        - $T(x)=x_0.0\cdots;|x|<\frac{1}{2}$
      - 否则
        - $T(x)=C(x)=x_0.10\cdots{00};|x|={\frac{1}{2}}$
  - $x_1\cdots{x_n}$全部取0,$x=0$

### 例

- 将小数$x$的小数数值部分,从高位到低位分别编为$x_1\cdots{x_n}$
  - $x_i代指第i位小数,i\in\set{1,2,\cdots{,n}}$
  - $x=x_0.x_1\cdots{x_n}$
- $x=-0.11011,小数位数为n=5;$
  - $最低位的1出现在m=5(即x_5)处$
  - 原码$T(x)=1.11011$
  - 补码$C(x)=1.00100+2^{-5}=1.00100+0.00001=1.00101$
- $x=-0.01\cdots,小数点尾数大于2,小于等于n$
  - $T(x)=1.01\cdots$
  - $C(x)=1.1\cdots$
    - 根据上面的规律(同一个真值x的原码和补码和反码在结构上的关联:)
      - $m\geqslant{2}$
      - $设C(x)=x_0,b_1b_2\cdots{b_n}$
      - $C(x)的最低位1应该出现在第m位小数(x_m=1)$
      - 更重要的是,同时有$b_1\cdots{b_{m+1}}=\overline{x_1}\cdots{\overline{x_{m-1}}}$
        - 本例中,$m\geqslant{2}$,那么$m-1\geqslant{1}$
        - 随意,至少能够保证$b_1=\overline{x_1}$,即$b_1=1$
        - 从而,得到$C(x)=1.1\cdots$的断言

## 允许移位(正确移位)的条件

- 讨论在什么情况下移位不会导致数据丢失而发生错误

### 补码

- 左移:
  - 当符号位和最高数据位一致的时候,进行补码**左移1位**不会操作数据丢失
    - 可以分类讨论
    - 也可以反方向讨论:
      - $x\neq{0}$:
        - 只有在真值$x的最高位有效数据位不会丢失的左移,对应补码的左移行为$
        - $x=x_0,x_1x_2\cdots$
          - $x_1=1时,左移1bit会发生错误$(丢失高位数据)
          - $x_1=0时,左移1bit不会导致关键数据丢失$(类似于对非规格化数做一次左归操作)
            - 这种情况下,对应到补码的移动,需要讨论正负两种大类情况
              - $x_0=0$
                - $即x=+0.01...;C(x)=T(x)=0.01\cdots$
                - 可见,$x_1=0$
              - $x_0=1$
                - $x=-0.01...;C(x)=1.1\cdots$
                - 可见,$x_1=1$
        - 可见,当真值x不为0时,**符号位和最高数据位一致的时候**,进行补码**左移1位**不会操作数据丢失
      - $x=0时,C(x)中,x_1对应为0$
        - 由于x=0,所以左移位操作丢失0不会造成错误
      - $综上,只要C(x)=c_0.c_1\cdots满足c_0=c_1,那么左移1位不会造成错误$



### 两数相加进位规律

- 两个n位数相加,结果位数不超过n+1位

  - 推导

  - $$
    x+y\leqslant|x+y|\leqslant|x|+|y|
    \\
    两个最大的n位r进制数的求和结果:
    \\记q=r-1(就是表示最大的数码)
    \\例如:如果r=10(十进制),那么q=9)
    \\最小n位数:r^{n-1}=\overbrace{1\underbrace{0\cdots{00}}_{n-1个0}}^{n位数}
    \\最大的n位数:r^n-1=\underbrace{q\cdots{qq}}_{n个q}
    \\最小n+1位数:r^n
    \\
    \\例如n=2,10和99分别是最小2位数和最大两位数
    \\
    \\2个最大n位数相加:
    \\A=(r^n-1)+(r^n-1)=2(r^n-1)
    \\最大n位数的r倍
    \\B=r(r^n-1)=\underbrace{q\cdots{qq}}_{n个q}0
    \\(A<B)
    \\最小n+2位数:
    \\C=r^{n+1}
    \\\frac{C}{B}=\frac{r(r^n-1)}{2(r^n-1)}
    =\frac{r}{2}
    \\容易知道,当r\geqslant2时:B\leqslant{C}
    \\从而A<B\leqslant{C},即A<C
    \\因此,两个n位数相加,位数无法达到n+2位,最多达到n+1位
    $$

    



## 二进制数其他规律

- [PC_二进制数的性质/模2的性质/进位计数法/进制数之间的通用转换办法/任意进制数间的转换原理(python)/二进制幂展开表示法_xuchaoxin1375的博客-CSDN博客_将十进制小数转换为r进制小数的方法是](https://blog.csdn.net/xuchaoxin1375/article/details/108696292)





