[toc]

# 定点数的移位运算

## 算数移位

- 算数移位的对象是有符号数(机器数)
  - 移位过程中,**符号位**保持不变
  - 相当于对被移动的**有符号机器数**$x$的真值(二进制形式)做相应的移动

## 逻辑移位

- 逻辑移位将操作数视为无符号数
- 移位和添补规则:
  - 逻辑左移:
    - 高位移丢
    - 低位添0
  - 逻辑右移:
    - 低位移丢
    - 高位添0

## 循环移位

- 分为:
  - 带进位标志CF的循环移位(大循环)
  - 不带进位标志的循环移位(小循环)
- 主要特点
  - 移除的数位又被移入到数据中
  - 是否带进位:取决于是否将进位标志CF加入循环移位

- 循环移位特别适合将数据的低字节数据和高字节数据互换

##  二进制移位操作

- 计算机中小数点的位置是事先约定的,

  - 因此,二进制表示的==机器数==在相对于小数点作n 位左移或右移时,**其实质就是**该数乘以或除以 $2^{n}(n=1,2, \cdots, n)$

  - 对于带符号数$s=\pm\sum\limits_{i=0}^{n}x_i2^i$

    - 左移一位(如果产生溢出)相当于乘以2

    - 右移一位(如果不考虑被因移位而被舍去的末尾位),相当于除以2

      

### 补位

#### 正数



- 由于移位后会出现空位,因此需要**补位**操作,下面对不同情况进行讨论
- $对于正数x$
  - $由于x的原码,补码,反码相同,即:T(x)=C(x)=C_1(x)$,所以,它们的补位操作一致
    - 这种情况下,我们以原码的补位为代表,容易知道,补的数是0,

#### 负数

- 三种机器码的移位操作的结果代码所对应的**真值大致相同**(参看最后的例子)
- 总结出来的三种机器码的**移位填补规则**
  - 在负数部分,三种机器码的移位添补规律虽然各有不同特点
  - 但是体现在**真值**上的移位效果(结合移位定义)则较为一致

#  结论:

## 声明
- 尽管您不记得该表格了,但是只要您会把不同机器码转为原码(或真值),您就可以通过原码来作为中介,通过原码的移位结果计算回转换前的机器码形式,也可以得到结果.

  - 负数的补码左移,低位补0(空位产生于低位)
  - 负数的补码右移,高位补1(空位产生于高位)
  - ![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062211063166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

  

## 解释
- 机器数(对应的真值)为正时,不论是左移还是右移,添补代码均为0
- $机器数对应的真值x为负数时$

  1. 由于负数的原码数值部分与真值相同,故在移位时只要使符号位不变,其空位均添即可。
  2. 由于负数的反码各位除符号位外与负数的原码正好相反,故移位后所添的代码应与原码相反,即全部添1。
  3. 分析**任意负数x的补码T(x)**可发现
     1. 从T(x)**由低位向高位**找到第一个“`1`”时(为了方面描述,称这个1为$x_\alpha$(即,第$\alpha$位小数$x_\alpha=1$))
     2. $x_\alpha$左边的各位均**与对应的反码相同**
     3. $x_\alpha$右边的各位(包括此$\alpha$在内)均**与对应的原码相同**
     4. 🎈这个规律(现象是在移位操作之外就存在的),下面会给出推导过程
     5. 故负数的补码左移时,因空位出现在低位,则添补的代码与原码相同,即添0;
     6. 右移时因空位出现在高位,则添补的代码应与反码相同,即添1

###  负数的补码与原码和反码在二进制串的结构上的关系

- 补码的左右移位的填补规则依赖于如下规律
- 下面仅讨论<u>定点小数</u>的情况,整数的情况手法类似,结论适用

- 设$负数x的$;机器字长为n+1;符号位占走1位,有n位留给数值位

  - 原码$T(x)=1.x_1x_2\cdots{x_m}\cdots{x_n}$

    - 假设从低位到高位观察T(x)的小数部分,第一个值为1的位值出现在$x_m$这个位置上

    - 换句话说,如果没有<u>精度/机器字长补齐</u>要求,那么$x_{m+1}\cdots{x_n}$这部分的小数位都是0,它们可以不写

  - $反码C_1(x)=1.\overline{x_1}\ \overline{x_2} \cdots{\overline{x_m}}\cdots{\overline{x_n}\ }$

    - $$
      1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_m}}\cdots{\overline{x_n}\ }
      =1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_{m-1}}}\underset\blacktriangle{0}
      \underbrace{1\cdots{11}}_{\overline{x_{m+1}}\cdots\overline{x_n}}
      $$

    - 

  - 补码$C(x)$:

    - $$
      C(x)
      =C_1(x)+2^{-n}
      =1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_{m-1}}}\underset\blacktriangle{0}
      \underbrace{1\cdots{11}}_{\overline{x_{m+1}}\cdots\overline{x_n}}
      +2^{-n}
      \\=1.\overline{x_1}\ \overline{x_2} 
      \cdots{\overline{x_{m-1}}}\underset\blacktriangle{1}
      \underbrace{{0}\cdots{00}}_{\overline{x_{m+1}}\cdots\overline{x_n}}
       
      $$

  - 🎈可见,$x_m$是无论是$T(x)还是C(x)$

    - 从低位开始向高位扫描的过程中最早出现的码值1都是同一个位置($x_m$)出

  - 🎈同时:

    - 真值x的补码的数值位分为<u>两部分</u>:
      - $\overline{x_1}\ \overline{x_2}\cdots 
        \overline{x_{m-1}}$部分和**反码**相同
      - ${ x_m}\cdots{x_n}$部分和**原码**相同
    - 极端情况下,有一部分的长度是0,另一部分长度为n

  - 🎈上面两个结论对于$x>0$的是时候也显然是成立的(因为$x>0$时,原码补码反码一致!)

### 例

- 将小数$x$的小数数值部分,从高位到低位分别编为$x_1\cdots{x_n}$
  - $x_i代指第i位小数,i\in\set{1,2,\cdots{,n}}$
  - $x=x_0.x_1\cdots{x_n}$
- $x=-0.11011,小数位数为n=5;$
  - $最低位的1出现在m=5(即x_5)处$
  - 原码$T(x)=1.11011$
  - 补码$C(x)=1.00100+2^{-5}=1.00100+0.00001=1.00101$
- $x=-0.01\cdots,小数点尾数大于2,小于等于n$
  - $T(x)=1.01\cdots$
  - $C(x)=1.1\cdots$
    - 根据上面的规律(同一个真值x的原码和补码和反码在结构上的关联:)
      - $m\geqslant{2}$
      - $设C(x)=x_0,b_1b_2\cdots{b_n}$
      - $C(x)的最低位1应该出现在第m位小数(x_m=1)$
      - 更重要的是,同时有$b_1\cdots{b_{m+1}}=\overline{x_1}\cdots{\overline{x_{m-1}}}$
        - 本例中,$m\geqslant{2}$,那么$m-1\geqslant{1}$
        - 随意,至少能够保证$b_1=\overline{x_1}$,即$b_1=1$
        - 从而,得到$C(x)=1.1\cdots$的断言

## 允许移位(正确移位)的条件

- 讨论在什么情况下移位不会导致数据丢失而发生错误

### 补码

- 左移:
  - 当符号位和最高数据位一致的时候,进行补码**左移1位**不会操作数据丢失
    - 可以分类讨论
    - 也可以反方向讨论:
      - $x\neq{0}$:
        - 只有在真值$x的最高位有效数据位不会丢失的左移,对应补码的左移行为$
        - $x=x_0,x_1x_2\cdots$
          - $x_1=1时,左移1bit会发生错误$(丢失高位数据)
          - $x_1=0时,左移1bit不会导致关键数据丢失$(类似于对非规格化数做一次左归操作)
            - 这种情况下,对应到补码的移动,需要讨论正负两种大类情况
              - $x_0=0$
                - $即x=+0.01...;C(x)=T(x)=0.01\cdots$
                - 可见,$x_1=0$
              - $x_0=1$
                - $x=-0.01...;C(x)=1.1\cdots$
                - 可见,$x_1=1$
        - 可见,当真值x不为0时,**符号位和最高数据位一致的时候**,进行补码**左移1位**不会操作数据丢失
      - $x=0时,C(x)中,x_1对应为0$
        - 由于x=0,所以左移位操作丢失0不会造成错误
      - $综上,只要C(x)=c_0.c_1\cdots满足c_0=c_1,那么左移1位不会造成错误$

## 双符号位移位

- 双符号位移位只有低位符号位需要参与移动,高位符号位不参于移动

#### 二进制数其他规律

- [PC_二进制数的性质/模2的性质/进位计数法/进制数之间的通用转换办法/任意进制数间的转换原理(python)/二进制幂展开表示法_xuchaoxin1375的博客-CSDN博客_将十进制小数转换为r进制小数的方法是](https://blog.csdn.net/xuchaoxin1375/article/details/108696292)

#  🎈例子

- 设**机器数字长为 8 位**  (  含 1 位符号位  ) ,

  -  若整数$A=\pm 26$,1

  - 写出三种机器数左,右移一位和两位后的表示形式及对应的真值,

  - 并分析结果的正确性:

- 解:

## 正数

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120806753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

  - 可见,对于正数,三种机器数移位后符号位均不变


  - 左移时最高数位丢1,结果**出错**;

  - 右移时最低数位丢1 ,影响**精度**。

## 负数

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120841344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

### 🎈负数补码例

- 和移位前的二进制代码做对比

- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622120927890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

- 以下精度问题规律,可以从原码出发举例体验.

  - 负数的原码左移时,高位丢1,结果出错;右移时,低位丢1,影响精度。

  - 负数的补码左移时,高位丢0,结果出错;右移时,低位丢1,影响精度。

  - 负数的反码左移时,高位丢0,结果出错;右移时,低位丢0,影响精度。





