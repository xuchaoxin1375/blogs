# 机器数_浮点数加减运算

- 浮点数计算特点是阶码和尾数分开计算
- 根据假设条件/给定条件:
  - 阶码一般为整数,可能使用的是**移码**或者**补码**来表示
  - 尾数一般为绝对值小于1的**规格化数**(**定点原码**表示或者**定点补码**)

- 🎈一般默认阶码和尾数都是用**补码**来表示

## 对阶

- 使得两个操作数的小数点位置对齐
  - 表现为两个数的阶码相等
  
- 步骤:
  - 设两个规格化浮点数(强调规格化是为了便于讨论)为:(书面书写,就不必使用严格的机器标准IEEE 754)
    - $a=E_aS_a$
    
    - $b=E_bS_b$
    
    - $设E_a<E_b$
    
    - 基数默认为2,浮点数的阶码和尾数分别用E,S表示
    
      
    
  - 求阶差$\delta$
  
  - 然后小阶向大阶看齐
    - $尾数S_a向右移1位,E_a更新为E_a+1$
    - $重复执行\delta次,就可以使得a,b的阶对齐(E_a=E_b)$

## 尾数求和

- 按照定点数的加减方法进行求和
  - 相当于做连个定点数加/减法
- 此阶段得到的结果不一定是规格化的

## 规格化结果

- 前一步操作得到的结果进行规格化,其手法在浮点数的表示中介绍过
- 但是这里考虑规<u>格化数的补码形式</u>



## examples

- $$
  x=0.1101\times{2^{01}}
  \\y=(-0.1010)\times{2^{11}}
  \\两个数的阶码和尾数均以补码形式保存
  \\除了基数2,其余数都是二进制形式
  \\\\
  2个浮点数的补码:(为了便于判断溢出,阶码和尾数都采用双符号位形式)
  \\以分号分割阶码和尾数;E或者j表示阶码;S表示尾数
  \\C(x)=00,01;00.1101
  \\C(y)=00,11;11,0110
  $$

  

  - 对阶

    - $$
      阶差C(\delta)=C(E_x)-C(E_y)=C(E_x)+C(-E_y)=00,01+11,01=11,10
      \\T(\delta)=11,01+1=11,10
      \\\delta=-2
      \\计算阶差的真值方法不唯一(直接从给定的x,y真值算更快捷)
      $$

      


# 加法/减法运算



## 浮点数规格化问题实例

### 基本规格化问题

![1646305647184](https://img-blog.csdnimg.cn/img_convert/954dd941d35ac9e9619905e2f8c31225.png)

### 十进制数的浮点数和定点数的表示形式示例

基于原码的规格化数(单符号位)

![1646306839531](https://img-blog.csdnimg.cn/img_convert/4ae407499ed2eda41357f31a2bd58516.png)

## 浮点数加减规格化综合问题

### 浮点数加减法预处理分析

* 由于浮点数尾数的小数点均固定在第一数值位前,所以尾数的加减运算规则与定点数的完.全相同。
* 但由于其`阶码的大小`又直接反映尾数有效值小数点的`实际位置`,

  * 因此当两浮点数阶码不等时,因两尾数小数点的实际位置不一样,尾数部分无法直接进行加减运算。
  * 为此,浮点数加减运算必须按以下几步进行

(1) 对阶,使两数的小数点位置对齐。(阶数决定小数点实际位置)

* 对阶的目的是使两操作数的小数点位置对齐,即使两数的阶码相等。
* 为此,首先要求出`阶差`,再按`小阶向大阶看齐`的原则,使`阶小的尾数`向`右移`位,
  * 每右移一位,阶码加1,直到两数的阶码相等为止。
  * 右移的次数正好等于阶差。
* 尾数右移时可能会发生数码丢失,影响精度。

(2) 尾数求和,将对阶后的两尾数按定点加减运算规则求和(差)
(3) 规格化,为增加有效数字的位数,提高运算精度,必须将求和  (差)后的尾数规格化。
(4) 舍入,为提高精度,要考虑尾数右移时丢失的数值位。
(5) 溢出判断, 即判断结果是否溢出

设两个浮点数

$$
\begin{array}{l}
x=S_{x} \cdot r^{j_{x}} \\
y=S_{y} \cdot r^{j_{y}}
\end{array}
$$

S为尾数,其余部分为阶数

### 综合示例:浮点数加法与右规

![1646383935018](https://img-blog.csdnimg.cn/img_convert/07a9d8f8ac971ce2fa530b61ab144769.png)

将`双符号位`的`符号位一同右移`
然后`在符号位上补位`(正数机器数(补码)就补0)

下一个加法例子中也是类似

![1646383975809](https://img-blog.csdnimg.cn/img_convert/adf10def7c68162bd7e586a332af72c8.png)

### 浮点数减法示例

![1646393929643](https://img-blog.csdnimg.cn/img_convert/9fb2168c36b53b2934f61ae7e9d8e171.png)

![1646393966485](https://img-blog.csdnimg.cn/img_convert/8169bacdebf10b63b6497e84aa84c91c.png)

