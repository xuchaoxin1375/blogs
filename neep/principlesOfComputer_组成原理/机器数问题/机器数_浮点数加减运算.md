# 机器数_浮点数加减运算

- 浮点数计算特点是阶码和尾数分开计算
- 根据假设条件/给定条件:
  - 阶码一般为整数,可能使用的是**移码**或者**补码**来表示
  - 尾数一般为绝对值小于1的**规格化数**(**定点原码**表示或者**定点补码**)

- 🎈一般默认阶码和尾数都是用**补码**来表示

## 对阶

- 使得两个操作数的小数点位置对齐
  - 表现为两个数的阶码相等
  
- 步骤:
  - 设两个规格化浮点数(强调规格化是为了便于讨论)为:(书面书写,就不必使用严格的机器标准IEEE 754)
    - $a=E_aS_a$
    
    - $b=E_bS_b$
    
    - $设E_a<E_b$
    
    - 基数默认为2,浮点数的阶码和尾数分别用E,S表示
    
      
    
  - 求阶差$\delta$
  
  - 然后小阶向大阶看齐
    - $尾数S_a向右移1位,E_a更新为E_a+1$
    - $重复执行\delta次,就可以使得a,b的阶对齐(E_a=E_b)$

## 尾数求和

- 按照定点数的加减方法进行求和
  - 相当于做连个定点数加/减法
- 此阶段得到的结果不一定是规格化的

## 规格化

- 前一步操作得到的结果进行规格化,其手法在浮点数的表示中介绍过
- 但是这里考虑规<u>格化数的补码形式</u>
  - [PC_规格化数及尾数相关表示形式和范围_xuchaoxin1375的博客-CSDN博客_规格化尾数](https://blog.csdn.net/xuchaoxin1375/article/details/118107477)


## 舍入

- 依然以补码的角度考虑

### 0舍1入

- 类似于十进制(真值)的四舍五入
- 只有右归(末尾(若干)小数)被移丢时,才有考虑**舍入**的必要(有意义)

- 基本原理是,补码函数C(x)在正数区间和负数区间内部:
  - $|C(x_1)|<|C(x_2)|\Leftrightarrow{x_1<x_2}$
  - 假设**右移**的时候,被移去的小数的位段是$x_m\cdots{x_n}$
    - 那么根据$x_m$:
      - 如果$x_m=1$则+1(入)
      - 否则+0 

#### 例

- $$
  假设某个求和结果:
  \\(x-y)_补=11,00;10.110001
  \\根据双符号位的性质,上述结果是一个溢出(负溢出)值
  \\需要进行右归
  \\(x-y)_补=11,00;11.011000\ \underset{\clubsuit} 1
  \\(注意,溢出的双符号位在右移时,只有低位参与右移,
  \\并将缺失的低位符号用高位符号补位,得到不溢出的结果)
  \\现在发现被右移操作移出去的(最高)bit是1,于是根据0舍1入,
  \\对其进行末尾数码+1处理
  \\
  \begin{aligned}
  &&11.011000&
  \\&+&1&
  \\\hline
  &&11.011001&
  \end{aligned}
  \\所以(x-y)_补=11,00;11.011001
  $$

  - [PC_二进制移位/定点数移位/算数移位及其移位后的空位添补规则+补码原码反码在结构上的联系_xuchaoxin1375的博客-CSDN博客](https://blog.csdn.net/xuchaoxin1375/article/details/118102839)

## 溢出判断

- 舍入操作中的:**舍0入1法**可能会执行尾码加1操作
  - 这可能引发连续进位导致溢出
  - 因此,舍入后可能还要在判断溢出
    - 如果发现溢出,需要重新规格化(**右归**)(而不会是左归)
  - 规格化可以消除尾数部分的溢出(可以称为**伪溢出**)现象
  - 当规格化完成后,在看看阶码是否处在合理的范围内
- 浮点数的溢出更重要的是**规格化尾数后的阶码是否溢出**
  - 假设阶码用两位符号位表示,那么根据补码的溢出判定方法:
    - 浮点数$F=2^{j}\cdot{S}$
    - 阶码(指数)的补码$C(j)$的两位符号位不同时认为发生溢出
    - $C(j)=01,\cdots$
      - 这种情况是浮点数发生上溢(对应于阶码正溢出)
      - 一般浮点溢出指定是上溢(本情况)
      - 这种情况需要溢出处理
    - $C(j)=10,\cdots$
      - 这种情况是浮点数发生下溢(对应于阶码负溢出)
      - 浮点数F被处理为机器零(真值十分接近0)

### 例

- $$
  (x-y)_补=11,00;11.011001
  \\其阶符为11
  \\因此认定为无溢出
  x-y=2^{-3}\cdot{-0.100111}
  $$

  

## 双符号位浮点数的补码表示范围

- 下面是规格化后的范围(补码)
- 若机器数为补码,尾数为规格化形式
  - 并假设:
    - 阶符取2位,
    - 阶码的数值部分取7位
    - 数符取2位
    - 尾数的数值部分取n位
  - 则它们能表示的补码在数轴上的表示范围 
    - ![在这里插入图片描述](https://img-blog.csdnimg.cn/a5aeb9db0779493fb1307614f7094286.png)
    - $ A  最小负数  2^{+127} \times(-1)$ 
    -  $B  最大正数  2^{+127} \times\left(1-2^{-n}\right)$ 
    -  $a  最大负数  2^{-128} \times\left(-2^{-1}-2^{-n}\right)$ 
    -  $b  最小正数  \quad 2^{-128} \times 2^{-1}$ 
  - 由于四个临界值都是补码形式,对应的真值范围和之前讨论过的真值(非规格化)浮点数范围有所不同
    - 可以发现,它们的阶码部分还是对称的!
    - 另外,最大的特点在于,补码能够表示的最大负数(对应于上面的指数部分):
      - $-2^{-n}=-0.0\cdots{01}_{n-1个0}$
      - $-2^{n}=-10\cdots{00}_{n个0}$
      - $C(-2^{-n})=1.0\cdots{00_{n个0}}$
      - $C(-2^n)=1,0\cdots00_{n个0}$
      - 也就是说,给定7个数值位,可以表示最大负数为$-2^{7}=-2^{7}$

## examples

### 例(基于补码的例)

- $$
  x=0.1101\times{2^{01}}
  \\y=(-0.1010)\times{2^{11}}
  \\两个数的阶码和尾数均以补码形式保存
  \\除了基数2,其余数都是二进制形式
  \\\\
  2个浮点数的补码:(为了便于判断溢出,阶码和尾数都采用双符号位形式)
  \\以分号分割阶码和尾数;E或者j表示阶码;S表示尾数
  \\C(x)=00,01;00.1101
  \\C(y)=00,11;11,0110
  $$

  

  - 对阶

    - $$
      阶差C(\delta)=C(E_x)-C(E_y)=C(E_x)+C(-E_y)=00,01+11,01=11,10
      \\T(\delta)=11,01+1=11,10
      \\\delta=-2
      \\计算阶差的真值方法不唯一(直接从给定的x,y真值算更快捷)
      $$

      

## 真值+浮点数+定点数的转问题



### 基本规格化问题

![1646305647184](https://img-blog.csdnimg.cn/img_convert/954dd941d35ac9e9619905e2f8c31225.png)

### 十进制数的浮点数和定点数的表示形式示例

基于原码的规格化数(单符号位)

![1646306839531](https://img-blog.csdnimg.cn/img_convert/4ae407499ed2eda41357f31a2bd58516.png)

## 🎈浮点数加减规格化综合

### 浮点数加减法预处理分析小结

* 由于浮点数尾数的小数点均固定在第一数值位前,所以尾数的加减运算规则与定点数的完.全相同。
* 但由于其`阶码的大小`又直接反映尾数有效值小数点的`实际位置`,

  * 因此当两浮点数阶码不等时,因两尾数小数点的实际位置不一样,尾数部分无法直接进行加减运算。
  * 为此,浮点数加减运算必须按以下几步进行

(1) 对阶,使两数的小数点位置对齐。(阶数决定小数点实际位置)

* 对阶的目的是使两操作数的小数点位置对齐,即使两数的阶码相等。
* 为此,首先要求出`阶差`,再按`小阶向大阶看齐`的原则,使`阶小的尾数`向`右移`位,
  * 每右移一位,阶码加1,直到两数的阶码相等为止。
  * 右移的次数正好等于阶差。
* 尾数右移时可能会发生数码丢失,影响精度。

(2) 尾数求和,将对阶后的两尾数按定点加减运算规则求和(差)
(3) 规格化,为增加有效数字的位数,提高运算精度,必须将求和  (差)后的尾数规格化。
(4) 舍入,为提高精度,要考虑尾数右移时丢失的数值位。
(5) 溢出判断, 即判断结果是否溢出

- 设两个浮点数


$$
\begin{array}{l}
x=S_{x} \cdot r^{j_{x}} \\
y=S_{y} \cdot r^{j_{y}}
\end{array}
$$

- S为尾数,其余部分为阶数

### 浮点数加法例

![1646383935018](https://img-blog.csdnimg.cn/img_convert/07a9d8f8ac971ce2fa530b61ab144769.png)

![1646383975809](https://img-blog.csdnimg.cn/img_convert/adf10def7c68162bd7e586a332af72c8.png)

### 浮点数减法示例

![1646393929643](https://img-blog.csdnimg.cn/img_convert/9fb2168c36b53b2934f61ae7e9d8e171.png)

![1646393966485](https://img-blog.csdnimg.cn/img_convert/8169bacdebf10b63b6497e84aa84c91c.png)

