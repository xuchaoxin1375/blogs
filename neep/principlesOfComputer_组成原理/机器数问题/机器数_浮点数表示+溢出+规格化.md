[toc]



#  浮点数

- 根据小数点的位置是否固定,分为定点数和浮点数

- 定点数采用不同机器数编码(<u>原码/补码/移码</u>)的情况

  - 定点数
    - **定点补码整数**表示**整数**

  - 浮点数
    - 浮点数不再使用补码来表示,而是用<u>原码和移码</u>组合表示
      - **定点原码小数**表示**浮点数的尾数**(定点小数)
      - **移码**表示浮点数**阶码部分**(<u>移码整数</u>)
  - 参考IEEE 754标准

## ref

- [PC_定点数/浮点数的溢出:上溢和下溢_xuchaoxin1375的博客-CSDN博客_上溢和下溢有什么区别](https://blog.csdn.net/xuchaoxin1375/article/details/118100746)


## 浮点数表示

* 浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。
* 这样，在位数有限的情况下，既`扩大了数的表示范围`，又`保持`了数的`有效精度`。
  * 例如，用定点数表示电子的质量或太阳的质量是非常不方便的。
  * 使用浮点是可以较好表示

### 浮点数形式分析

- 一个浮点数可以分为两大部分:**阶数;尾数**

  - **阶数:{(阶符),(阶码数值)};**
    - 阶符
    - 阶码
  - **尾数:{(数符).(数码数值)}** 的书写形式(即尾数分为数符和数码)
    - 数符
    - 数码

  - <u>计算机中,基数是默认值为2,不用写出来</u>

### 书面形式的一般浮点数

- 对于r进制的浮点数,可以表示为:

  - $$
    N=S\times{r^j}
    $$

    - $其中$
      - $S是尾数$(可正可负)
        - 可以采用定点原码小数表示
      - $j$为阶码(指数)(也就是基数r的指数)(可正可负)
        - 可以采用移码整数
      - $r$是基,在计算机中,通常r=2,即二进制(也可以去2的其他幂,比如4,8,...)

- 在计算机中,为了提高数据的精度,以及便于比较

  - 规定浮点数的**尾数**用<u>纯小数的形式</u>
    - $S\in(0,1)$
  - 比如$a=0.11\times{2^{101_2}}$
    - $b=0.011\times{2^{101_2}}$

#### 🎈二进制规格化浮点数

- 为了进一步规范浮点数(**保证尽可能高的精度**)提出**规格化数(浮点数)**

  - <u>**最高位是1的浮点数**</u>就是规格话数,例如
    - $a=0.11\times{2^{101_2}}$,而b就不是
    - $c=101.11\times{2^{101_2}}$这个也不是,因为它位数是纯小数的条件的都不满足

- 对于基数不同的浮点数,其规格化数的标准有所不同,规格化的过程也有所不同

### 计算机中的二进制浮点数形式

#### 非标准形式讨论浮点数

- 通常,机器中的浮点数形如:

  - $$
    F=j_f\underbrace{j_1\cdots{j_m}}_{阶码(数值部分)}S_f\underbrace{S_1\cdots{S_n}}_{尾数的数值部分}
    $$

    

    - 该形式可以看做两大部分:

      - $阶数(阶码)j=j_fj_1\cdots{j_m}$
        - $j_f是阶符$
        - j是**整数**,反映了浮点数的表示**范围**和**小数点的位置**
      - 尾数$S=S_fS_1\cdots{S_n}$
        - $S_f$是数符
        - S是**纯小数**,反映了浮点数的**精度**,位数的符号$S_f$代表了浮点数的**正负**

      - 小数点:
        - 尾数是纯小数,其小数点位于$S_j$和$S_1$之间
        - 阶码j是顶点整数,也要自己的小数点(位于$j_m$和$S_f$之间)
          - 但是实际决定F的范围的,是阶码整体j

  - 回顾书面形式的浮点数:$F=S\times{r^j}$

    - S就是尾数
    - j就是阶码
    - 基数r被默认为2

#### IEEE标准中的结构

- 和非标准结构大致类似,但是数符$S_f$被提前了到结构的第一部分(参看文末部分)



## 🎈🎈🎈浮点数的表示范围(非规格化时)

- 设浮点数`阶码的数值位取m位`,`尾数的数值位取n位`,当浮点数为非规格化数时,它在数轴上的表示范围:


![1646303050232](https://img-blog.csdnimg.cn/img_convert/b35536513bcd3fe124cff3be4a41c4d9.png)

- $浮点数=阶数\times 尾数$

### n位数值位的小数和整数最值

- 下面的讨论是基于**真值**(与具体机器数编码相独立)

- 纯小数:

  - $$
    |p|\in(0,1)
    \\
    |p|\in[2^{-n},1-2^{-n}]
    \\-|p|\in[2^{-n}-1,-2^{-n}]
    \\\\
    \\2^{-n}=0.\underbrace{0\cdots{01}}_{n-1个0,末尾1}
    \\1-2^{-n}=(0.\underbrace{1\cdots{11}}_{n个1})_2=\sum\limits_{i=1}^{n}2^{-i}
    $$
    
  - 纯小数对应于浮点数的尾数(的数值位部分)

- 整数:

  - $$
    |z|=0,1,2,\cdots,2^{n}-1
    \\
    -|z|=1-2^{n},\cdots{0}
    $$
    
  - 对应于浮点数阶码(数值位部分)

- 设浮点数$F=j_fj_1\cdots{j_m}S_fS_1\cdots{Sn}$

  - 即,阶码数值位部分有m位,尾数数值部分n位

  - 浮点数的取值范围具有对称性

  - 下面仅对正数的一侧做讨论

    - 最小浮点数(浮点数最小绝对值):
      - 注意到,浮点数的正负性是由尾数的数符位$S_f$决定的
        - 阶码总是正数(尽管阶符可以是负的
          - 指数函数($2^{j}$总是有大于0的函数值,$2^x$是个递增函数,
          - 所以,当j取得最小值$2^{-1\cdots{11}}=2^{-(2^{m}-1)}$
          - $同时尾数S取到最小值0.0\cdots{01}=2^{-n}$

      - 最小**阶码**($2^{-(2^m-1)}$乘以最小尾数:(最接近0的正浮点数数)
        - $J_{Min}|S|_{Min}=2^{-(2^{m}-1)}2^{-n}$

      - $最大阶码(2^{(+(2^m-1))})乘以最大尾数(2^{-n}-1)$
        - $J_{Max}|S|_{Max}=2^{(2^{m-1})}(2^{-n}-1)$

  - 以上就是正半轴的情况,负半轴取符号得到对称的边界值

    - 最大负浮点数:(最接近0的负浮点数)
      - $-J_{Min}|S|_{Min}=-(2^{-(2^{m}-1)}2^{-n})$
    - 最小负浮点数:(最远离0的负浮点数)
      - $-J_{Max}|S|_{Max}=-(2^{(2^{m-1})}(2^{-n}-1))$

  - 特点:

    - 观察上述最值,发现阶码的数值部分绝对值是最大的m位二进制数

    - $$
      2^{-1\cdots{11}}\times0.0\cdots{01}
      \\
      2^{+1\cdots{11}}\times0.1\cdots{01}
      \\
      -2^{-1\cdots{11}}\times0.0\cdots{01}
      \\
      -2^{+1\cdots{11}}\times0.1\cdots{01}
      $$

      

### 🎈浮点数表示范围和溢出

- 判断浮点数溢出,是通过比较**阶码**来进行

- 上溢:
  - 这个好理解,当浮点数的阶码大于最大阶码时,就是发生上溢,这种情况下机器停止运行,进行中断溢出处理
  - **正上溢**和**负上溢**,绝对值都是向无穷大方向发展而发生的
- 下溢:
  - 当浮点数阶码小于最小阶码时,称为下溢
  - **正下溢**和**负下溢**的绝对值都是向0靠近而发生的
  - 注意,浮点数可以取到0
    - 但是,由于精度的限制(尾数位数有限),很接近0但不等于0的数是表示不了的(存在一个类似于盲区的区域)
    - 即,在值落在0的邻域时,可能发生下溢
    - 此时的数绝对值十分小,通常的,将**尾数**各位强制置为0,按照**机器零**处理

## 🎈规格化数

- [PC_规格化数及尾数相关表示形式和范围_xuchaoxin1375的博客-CSDN博客_规格化尾数](https://blog.csdn.net/xuchaoxin1375/article/details/118107477?csdn_share_tail={"type"%3A"blog"%2C"rType"%3A"article"%2C"rId"%3A"118107477"%2C"source"%3A"xuchaoxin1375"})



# 🎈🎃定点数vs浮点数

- 当浮点机和定点机中的位数相同
  - 范围:浮点数的表示范围比定点数大得多
    - 定点数和浮点数都可以表示
      - 整数
      - 小数
    - 在定点机中,由于小数点位置固定不变,当机器处理的数不是**纯小数**或者**纯整数**的时候,需要乘以一个**比例因子**,否则会产生**溢出**
    - 采用定点小数的机器称为**定点机**
      - 数值部分的位数n决定了定点机中数的表示范围
      - 如果**机器数**采用**原码**:
        - 小数定点机中的表示范围是$-(1-2^{-n})\sim{1-2^{-n}}$(对称)
        - 整数定点机中数的表示范围:$-(2^n-1)\sim{2^n-1}$
  - 精度:当浮点数是规格化数时,其相对进度也比定点数高得多
    - 这要分情况:比如对于x=0.1001011 101010...,y=0.00000000010110....
      - 对于两台相同字长(8位)的定点机A和浮点机B:
      - x用A表示精度更高
        - 因为x已经是规格化数,定点机的所有bit都可以用来表示尾数的各个位数,可以达到最高精度
      - y用B表示精度更高
        - 前提是y要进行规格化,这样可以将有效位表示到更后面.
  - 运算效率:定点数运算比较快
    - 浮点数运算要分为阶码部分和位数部分的运算
    - 而且运算结果都要规格化,(浮点数的运算步骤比定点数多)
  - 溢出判断:
    - 浮点数的溢出判断是对**规格化数**的阶码进行判断
    - 定点数是对数值本身进行判断
      - 比如,<u>小数定点机</u>中的数,其绝对值如果大于1,就是溢出
        - 为了避免溢出,处理非纯小数前,需要选择比例因子,比较麻烦
        - 原因是定点数的小数点被规定在符号位之后,且不可移动
      - 浮点数的表示范围大,仅当上溢才会停止运算,一般不考虑比例因子的选择
  - 定点机可以通过软件实现浮点运算或者外加浮点扩展硬件

# IEEE 754标准的浮点数格式

$$
\\
\begin{array}{|l|l|l|}
\hline 
S_f & E & S_{1\sim{n}} \\
\hline
数符&阶码部分(移码整数)&尾数数值位(用定点原码)
\\\hline
\end{array}
\\
\begin{array}{|l|c|c|}
\hline S_f(数符) & \text { 阶码(含阶符) } & \text { 尾数 } \\
\hline
\end{array}
$$

- $$
  \begin{array}{lcccc} 
  & \text { 符号位 } S & \text { 阶码 } & \text { 尾数 } & \text { 总位数 } \\
  \text { 短实数 } & 1 & 8 & 23 & 32 \\
  \text { 长实数 } & 1 & 11 & 52 & 64 \\
  \text { 临时实数 } & 1 & 15 & 64 & 80
  \end{array}
  $$

  

- 其中,S为数符,它表示浮点数的正负,但与其有效位(尾数)是分开的。

- 阶码用移码表示,阶码的真值都被加上一个常数(偏移量),


* 如短实数,长实数和临时实数的偏移量用十六进制数表示分别为7FH,3FFH和3FFFH。
* 尾数部分`通常`都是规格化表示,即非“O”的有效位最高位总是“1”,但在IEEE标准中,有效位呈如下形式。
  1▲ffff……-fff
  其中▲表示假想的二进制小数点。
* 在实际表示中,对短实数和长实数,`这个整数位的1省略`,称`隐藏位`;
* 对于临时实数不采用隐藏位方案

### 表格

|                             Name                             |     Common name     | Base | Significand bits[[b\]](https://en.wikipedia.org/wiki/IEEE_754#cite_note-15) or digits | Decimal digits | Exponent bits | Decimal E max | Exponent bias[[14\]](https://en.wikipedia.org/wiki/IEEE_754#cite_note-DAE-16) |  E min  |  E max  |   Notes   |
| :----------------------------------------------------------: | :-----------------: | :--: | :----------------------------------------------------------: | :------------: | :-----------: | :-----------: | :----------------------------------------------------------: | :-----: | :-----: | :-------: |
| [binary16](https://en.wikipedia.org/wiki/Half-precision_floating-point_format) |   Half precision    |  2   |                              11                              |      3.31      |       5       |     4.51      |                         $2^4−1 = 15$                         |   −14   |   +15   | not basic |
| [binary32](https://en.wikipedia.org/wiki/Single-precision_floating-point_format) |  Single precision   |  2   |                              24                              |      7.22      |       8       |     38.23     |                        $2^7−1 = 127$                         |  −126   |  +127   |           |
| [binary64](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) |  Double precision   |  2   |                              53                              |     15.95      |      11       |    307.95     |                      $2^{10}$−1 = 1023                       |  −1022  |  +1023  |           |
| [binary128](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format) | Quadruple precision |  2   |                             113                              |     34.02      |      15       |    4931.77    |                      $2^{14}$−1 = 16383                      | −16382  | +16383  |           |
| [binary256](https://en.wikipedia.org/wiki/Octuple-precision_floating-point_format) |  Octuple precision  |  2   |                             237                              |     71.34      |      19       |    78913.2    |                     $2^{18}−1 = 262143$                      | −262142 | +262143 | not basic |
| [decimal32](https://en.wikipedia.org/wiki/Decimal32_floating-point_format) |                     |  10  |                              7                               |       7        |     7.58      |      96       |                             101                              |   −95   |   +96   | not basic |
| [decimal64](https://en.wikipedia.org/wiki/Decimal64_floating-point_format) |                     |  10  |                              16                              |       16       |     9.58      |      384      |                             398                              |  −383   |  +384   |           |
| [decimal128](https://en.wikipedia.org/wiki/Decimal128_floating-point_format) |                     |  10  |                              34                              |       34       |     13.58     |     6144      |                             6176                             |  −6143  |  +6144  |           |

### 例

* 下表列出了十进制数178.125的实数表示。
  * ![](https://img-blog.csdnimg.cn/img_convert/fd44e904cbf7246aa92761142329dac9.png)

### 从真值算得其IEEE754表示形式

- 设真值为x
  - $例如x=+178.125$,采用32为IEEE754规格的32位规格(8位用来保存阶码)
  - $真值的二进制形式=+10110010.001$
    - 按原码规格化该浮点数:
      - $x=0.10110010001\times{2^{+8}}$
      - $x=1.0110010001\times{2^{+7}}$
        - 可以将这种形式称为IEEE754规格化
        - 这种形式的规格化数落在[1,2)区间内
        - 即,开头总是1,这样可以不用可以用个位(bit)来存储这个1,从而可以而外的多表示移位小数(提高一点精度)
        - 其中:
          - $阶码E=+7$
          - $尾数数值位M=.0110010001$
            - 由于IEEE的隐藏1处理,因此尾数最终从$1.0110010001变为.0110010001$
            - 小数点还是先出来,但是机器中不保存小数点
            - $0 \leqslant M<1$
  - 基于IEEE规格化形式的二进制串,进行阶码和位数的机器数化编码:
    - 符号位:整数用0表示,负数用1表示,本例为正数,用0编码($S_f=0$)
    - 用移码来编码基数的指数(阶码),$E=O(+7)=2^7+7=10000000_2+111_2=10000111$
    - 用定点小数原码来编码IEEE规格化尾数数值部分,$M=T(M)=0110010001$

### 从IEEE754表示形式计算其表示的真值

- 设B=偏置值:

  - $$
    B_i=\begin{cases}
    127,&\text{i=1,single precision,8bit阶码}
    \\1023,&\text{i=2,double precision,11bit阶码}
    \end{cases}
    \\
    \begin{aligned}
    \\x&=(-1)^{S_f}\times{1.M}\times{2^{E-B_i}}
    \\|x|&=1.M\times{2^{E-B_i}}
    \end{aligned}
    \\其中,1.M=1+M,(M\in[0,1))
    \\注意这里的1.M的1不是符号位(符号位是用单独的数符S_f表示的)
    \\IEEE的规格化尾数的绝对值(换原被隐藏的1),也就是(1.M)取值落在[1,2)的范围内
    \\1.M是非负的(或者是无符号的),它的符号位在头部(S_f)
    $$
    

## 🎈IEEE 754浮点数的表示范围

### IEEE浮点数的精度和范围

一旦浮点数的位数确定后,合理分配`阶码`和`尾数`的`位数`,直接影响浮点数的表示`范围和精度`。

* 通常对于短实数(总位数为32位),阶码取8位(含阶符1位) ,尾数取24位(含数符1位);
* 对于长实数(总位数为64位),阶码取11位(含阶符1位) ,尾数取53位(含数符1位);
* 对于临时实数(总位数为80位),阶码取15位(含阶符1位) ,尾数取65位(含数符1位)。

### 阶码全为0/1的情况

- 全0阶码同时全0尾数,表示$\pm0$,符号取决于数符$S_f$
  - 通常它们等效
- 全1阶码全0尾数,表示$\pm\infin$
  - 引入无穷大是为了使得计算过程中出现异常,依然能够进行下去

### 阶码不为全0也不为全1的情况

#### 短浮点数

- 1+8+23

  - 最小绝对值

    - $$
      E=1,M=0;
      \\对应的真值min=1.M\times{2^{E-B_1}}=1.0\times2^{1-127}=1.0\times{2^{-126}}
      $$

  - 最大绝对值:

    - $$
      \\
      \begin{aligned}
      E&=(2^8-1)-1
      \\&=1\cdots{11}-1
      \\&=1\cdots{10}=254
      \\M&=1-2^{-23}
      \end{aligned}
      \\对应的真值为:
      max=1.M\times{2^{E-B_1}}
      =(2-2^{-23})\times2^{254-127}
      ={(2-2^{-23})}\times2^{127}
      $$

      

#### 长浮点数

- 1+11+52

  - 最小绝对值

    - $$
      E=1,M=0;
      \\对应的真值min=1.M\times{2^{E-B_2}}=1.0\times2^{1-1023}=1.0\times{2^{-1022}}
      $$

  - 最大绝对值:

    - $$
      \\
      \begin{aligned}
      E&=(2^{11}-1)-1
      \\&=1\cdots{10}=2046
      \\M&=1-2^{-52}
      \end{aligned}
      \\对应的真值为:
      max=1.M\times{2^{E-B_2}}
      =(2-2^{-52})\times2^{2046-1023}
      \\={(2-2^{-52})}\times2^{1023}
      $$

      

## 机器零

* 当一个浮点数`尾数为0`时(不论其阶码为何值)或`阶码等于或小于它所能表示的最小数`时(不管其尾数为何值)机器都把该浮点数作为零看待,并称之为“`机器零`”。
* 如果浮点数的阶码用移码表示,尾数用补码表示
  * 则当阶码为它所能表示的最小数$-2^{m}$(式中 m为阶码的位数,此时该浮点数已经被当作机器零)且尾数为0时,其阶码(移码)全为0,尾数(补码)也全为0,这样的机器零为000...0000

## 移码

- 浮点数的表示中,采用移码的原因

  - 使用补码不容易直接判断数的大小

  - 使用移码可以**直接判断出机器数对应的真值之间的大小关系**

  - 移码只能够表示**整数**

- $[x]_{移}在数轴上的表示总是\geqslant0$

- 假设:

  - $真值x的移码的二进制串为O(x)=x_0,x_1\cdots{x_n}$

    - $$
      O(x)=2^n+x,(x\in[-2^{n},2^n-1])
      \\O(x)\in[0,2^{n+1}-1]
      \\以n+1位二进制无符号数表示[0\cdots{00}_2,1\cdots{11}_2]
      $$

    - 如果数值位不足n位,则补0对齐

    - 计算移码的偏置值通常取的就是$2^n$
  
  - 有的地方偏置值取$2^n-1$
  
    

### 移码和真值相互转换以及表示范围

- 从移码计算真值:
  - $x=O^{-1}(O(x))=O(x)-2^n$
    - $x\in[-2^{n},2^n-1]$
  - 此时将O(x)理解为无符号数
  - $O(x)\in[0,2^{n+1}-1]$

- 相同位数下,移码可以表示的数(真值)的范围和补码一样
- ![](https://img-blog.csdnimg.cn/img_convert/0dcdb32ca1446d63cb52edfa5ea19bff.png)

![](https://img-blog.csdnimg.cn/img_convert/5b0fbaa71cc32f5a479126cf1c8d6718.png)

* 此外,由移码的定义可见，当n = 5时,其最小的真值为$x = -2^{5}=- 100000_{二进制}$，则$[ - 100000]_{移} =2^{5}+ x = 100000 - 100000 = 0,00000$,即最小真值的移码为全0,这符合人们的习惯。
* 利用移码的这一特点,当浮点数的阶码用移码表示时,就能很方便地`判断阶码的大小`

# C语言和浮点数类型

- C语言中的浮点数类型及类型转换.
- C语言中的float和double类型分别对应于IEEE 754**单精度浮点数(32bit)**和**双精度浮点数(64bit)**。
  - `long double`类型对应于扩展双精度浮点数,但`long double`的长度和格式随编译器和处理器类型的不同而有所不
    同。
- 在C程序中等式的赋值和判断中会出现强制类型转换
  - 以char> int>long> double和float>double最为常见，
  - 从前到后**范围和精度**都从小到大，转换过程没有损失。
- 从int转换为float时(通常,它们都是32bit)，虽然不会发生溢出
  - 但int可以保留32位，float保留24位(包括隐藏位)，可能有数据舍入(可能影响精度)
    - 具体是:当int类型的$25\sim{31}$bit这些位非0,就无法被无损的转换为浮点数
    - 因此,如果可以用整形表示的数尽量用整形,不经可以保证精度也可以保证运算效率
  - 若从int转换为double则不会出现精度受损
    - 应为double类型的精度达到53位明显大于31位(不计符号位)
      - double的有效位数更多，因此能保留精确值。
    - 因此不能够笼统的认为,整数转为浮点数,精度一定下降(要区分单精度和双精度)
    - 就算是单精度,也要考虑被转换的数的结构!
  - long到double同样可能会随失精度(但是不总是损失)
- 从double 转换为float 时，因为float 表示范围更小，因此可能发生**溢出**。
  - 此外，由于有效位数变少，因此可能被舍入。
- 从float或double转换为int时，因为int没有小数部分
  - 所以数据可能会向0方向被截断(仅保留整数部分)，影响精度。
    - 浮点数x向0方向阶段,就是绝对值被**向下取整**了
    - $123.45\to{123}$
    - $-123.45\to{-123}$
  - 另外，由于int的表示范围更小，因此可能发生溢出。
    - 31位数值位的上限$2^{31}-1$
    - 单精度的float具有8位阶码(7位数值位,上限为$2^{2^{7}-1}=2^{127}$
    - 双精度的范围就更大了,达到$2^{1023}$
    - 可见差距十分悬殊

