@[toc]

@[toc]

# 浮点数表示/补码运算:定点数加减法/浮点数加减法

## 浮点数表示

* 浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。
* 这样，在位数有限的情况下，既`扩大了数的表示范围`，又`保持`了数的`有效精度`。
  * 例如，用定点数表示电子的质量或太阳的质量是非常不方便的。
  * 使用浮点是可以较好表示

### IEEE 754标准的浮点数格式

![1646287126006](https://img-blog.csdnimg.cn/img_convert/cb14d638adcf5927e1a2389a623003d2.png)

![](https://img-blog.csdnimg.cn/img_convert/a943cbd2dc87b8c9eece89be61e0b1e2.png)

> 其中,S为数符,它表示浮点数的正负,但与其有效位(尾数)是分开的。
>
> 阶码用移码表示,阶码的真值都被加上一个常数(偏移量),
>
> * 如短实数,长实数和临时实数的偏移量用十六进制数表示分别为7FH,3FFH和3FFFH。
> * 尾数部分`通常`都是规格化表示,即非“O”的有效位最高位总是“1”,但在IEEE标准中,有效位呈如下形式。
>   1▲ffff……-fff
>   其中▲表示假想的二进制小数点。
> * 在实际表示中,对短实数和长实数,`这个整数位的1省略`,称`隐藏位`;
> * 对于临时实数不采用隐藏位方案,
> * 下表列出了十进制数178.125的实数表示。
>   * ![](https://img-blog.csdnimg.cn/img_convert/fd44e904cbf7246aa92761142329dac9.png)

### 非标准形式讨论浮点数

通常,浮点数被表示成
$N =S \times r^{j}$
式中,

* S为尾数(可正可负),
* j为阶码(可正可负),
* r是基数(或基值)。

> 在计算机中,基数可取2，4、8或16等。

> * 为了提高数据精度以及便于浮点数的比较,在计算机中规定`浮点数的尾数`用`纯小数形式`,
> * 此外,将`尾数(小数)最高位为1的浮点数`称为`规格化数`,即 $N =0. 110101\times 2^{100}$为浮点数的规格化形式(100为4的二进制形式)。
> * 浮点数表示成规格化形式后,其`精度最高`。

![1646288069544](https://img-blog.csdnimg.cn/img_convert/ae1f08025f35acf993fef504ff5d542f.png)

* 浮点数由阶码j和尾数S两部分组成。
  * `阶码是整数`,阶符$j_{f}$和`阶码的位数m`合起来反映`浮点数的`表示范围及`小数点的实际位置`;
  * `尾数是小数`,其`位数n反映了浮点数的精度`;
  * 尾数的符号$S_{f}$代表浮点数的正负

### 浮点数形式分析

分段:**阶数;尾数**

具体展开为:**阶数:{(阶符),(阶码数值)};尾数:{(数符).(数码数值)}** 的书写形式(即尾数分为数符和数码)
基数是默认值为2,可以不体现出来
`阶符`和`数符`可以取0/1

### 浮点数的表示范围(非规格化时)

设浮点数`阶码的数值位取m位`,`尾数的数值位取n位`,当浮点数为非规格化数时,它在数轴上的表示范围:

![1646303050232](https://img-blog.csdnimg.cn/img_convert/b35536513bcd3fe124cff3be4a41c4d9.png)

$浮点数=阶数\times 尾数$

### 浮点数的精度和范围

一旦浮点数的位数确定后,合理分配`阶码`和`尾数`的`位数`,直接影响浮点数的表示`范围和精度`。

* 通常对于短实数(总位数为32位),阶码取8位(含阶符1位) ,尾数取24位(含数符1位);
* 对于长实数(总位数为64位),阶码取11位(含阶符1位) ,尾数取53位(含数符1位);
* 对于临时实数(总位数为80位),阶码取15位(含阶符1位) ,尾数取65位(含数符1位)。

### 浮点数的规格化

* 为了提高浮点数的`精度`,其尾数必须为规格化数。
* 如果不是规格化数,就要通过`修改阶码`并`同时左右移尾数`的办法,使其变成规格化数。
* 将非规格化数转换成规格化数的过程称为规格化。
  * 对于`基数`不同的浮点数,因其规格化数的`形式不同`,`规格化过程也不同`。

#### 左规/右规

* 当基数为2时,`尾数最高位为1`的数为规格化数。

  * 规格化数的尾数的绝对值不小于$\frac{1}{2}$
  * 规格化时,`尾数左移`一位,阶码减1(这种规格化称为向左规格化,简称`左规`);
  * `尾数右移`一位,阶码加1(这种规格化称为向右规格化,简称`右规`)。
* 当基数为4时,尾数的最高两位不全为零的数为规格化数。

  * 规格化时,尾数左移两位,阶码减1 ;
  * 尾数右移两位,阶码加1。
* 当基数为8时,尾数的最高三位不全为零的数为规格化数。

  * 规格化时,尾数左移三位,阶码减1;
  * 尾数右移三位,阶码加1。

> * 浮点机中一旦基数确定后就不再变了
> * 而且基数是隐含的,故不同基数的浮点数表示形式完全相同。
>   * 但基数不同,对数的表示范围和精度等都有影响。
>   * 一般来说,基数r越大,可表示的浮点数范围越大,而且所表示的数的个数越多。
>   * 但r越大,浮点数的精度反而下降。
>   * 如r = 16的浮点数,因其规格化数的尾数最高三位可能出现零,故与其尾数位数相同的r =2的浮点数相比,后者可能比前者多三位精度。

#### 双符号位规格化

![1646382660768](https://img-blog.csdnimg.cn/img_convert/a316e5d5deecf23f7bb8e94c75c348f1.png)

可见,当尾数的最高数值位与符号位不同时,即为规格化形式

> 但对S<0时,有两种情况需特殊处理。

* $s=-\frac{1}{2}$,则$[S]_{补}=11.100\cdots 0,$
  此时对于真值$-\frac{1}{2}$,而言,它满足式(6.19),对于补码$[S]_{补}$,而言,不满足6.21的形式

> 为了便于硬件判断,特规定$-\frac{1}{2}$不是规格化的数(对补码而言)。

* $s = -1$,则$[S]_{补} = 11.00…0$,因小数补码允许表示-1,故-1视为规格化的数。

#### 左规

例子

![1646383455850](https://img-blog.csdnimg.cn/img_convert/230bc596595ea301e893dfc8ee24c5f6.png)

#### 右规

* 当尾数出现01.x x…×或10.x x…x时,表示尾数溢出,这在`定点加减运算`中是不允许的,
* 但在`浮点运算`中这不算溢出,可`通过右规处理`。
* 右规时尾数右移一位,阶码加1。

## 机器零

* 当一个浮点数`尾数为0`时(不论其阶码为何值)或`阶码等于或小于它所能表示的最小数`时(不管其尾数为何值)机器都把该浮点数作为零看待,并称之为“`机器零`”。
* 如果浮点数的阶码用移码表示,尾数用补码表示
  * 则当阶码为它所能表示的最小数$-2^{m}$(式中 m为阶码的位数,此时该浮点数已经被当作机器零)且尾数为0时,其阶码(移码)全为0,尾数(补码)也全为0,这样的机器零为000...0000

## 移码

使用补码不容易直接判断数的大小
使用移码可以直接判断出机器数对应的真值之间的大小关系
$[x]_{移}$在数轴上的表示总是>=0
![](https://img-blog.csdnimg.cn/img_convert/0dcdb32ca1446d63cb52edfa5ea19bff.png)

![](https://img-blog.csdnimg.cn/img_convert/5b0fbaa71cc32f5a479126cf1c8d6718.png)

* 此外,由移码的定义可见，当n = 5时,其最小的真值为$x = -2^{5}=- 100000_{二进制}$，则$[ - 100000]_{移} =2^{5}+ x = 100000 - 100000 = 0,00000$,即最小真值的移码为全0,这符合人们的习惯。
* 利用移码的这一特点,当浮点数的阶码用移码表示时,就能很方便地`判断阶码的大小`

# 加法/减法运算

加法/减法可能会产生溢出,因此还伴随着溢出判断等处理

## 定点数加法/减法运算

### 补码加法公式

![](https://img-blog.csdnimg.cn/img_convert/3a65e33fe5a80b87ad833e1aec2113d2.png)

### 补码减法公式

![](https://img-blog.csdnimg.cn/img_convert/3d81a9814535e4c050ffe100b2ae65db.png)

> * 因此,若机器数采用补码,当求A – B时,只需先求$[ -B]_{补}$(称$[ –B]_{补}$,为“求补”后的减数),就可按补码加法规则进行运算。
> * 而$[ -B]_{补}$由$[B]_{补}$`连同符号位在内,每位取反,末位加1`而得
>   * (由于B可以是正数也可以是负数)。
>   * B和-B在的原码(真值)的二进制形式上仅相差一个符号位
>   * 例如,$B=-6=1,110;-B=6=0,110;$
>     * $[-B]_{补}=[6]_{补}=0,110;$
>     * $[B]_{补}=[-6]_{补}=1,010;$
>     * 求(一个数的)`相反数`的补数(码):`数B的相反数`的补数(即-B的补数)确实可以通过将`B的补码`的`包括符号位在内的所有位取反再末尾+1`得到.
>       * 即,采取的策略是用一个补码求另一个补码
>     * 事实上(上述规律的一个具体情况),求一个`负数`的补码,也可以通过求其相反数的补码的手法来得到(比如-6的补码,通过将其相反数+6补码的所有位取反再末尾+1得到;(可以将这种情况视为求相反数的补码的特例)
>       * 用原码求补码的策略需要先判断真值的正负,如果是负数,执行操作:将该负数(真值)的原码的符号位之外的位的按位取反末尾+1)

### [-B的补数]和[B的补数的相反数]的关系

$$
[-B]_{补}=-[B]_{补}

$$

我们知道,等号左边的形式是很常用的

在补码减法公式那里有:

![1646388896138](https://img-blog.csdnimg.cn/img_convert/fd6311917931e471a0bd004a77b12070.png)

我们只需要令`A=B`

$$
[B-B]_{补}=[B]_{补}+[-B]_{补}\\
又因为LHS(等号左边)=0;所以\\
[B]_{补}+[-B]_{补}=0\\从而\\
-[B]_{补}=[-B]_{补}

$$

这在浮点数加减法做对阶的时候会经常用到.

当然,我们知道,计算机引入二进制补码是为了方便将减法操作转换为加法操作.

(后面的浮点数加减法会给出例子)

前面还提到,$[ -B]_{补}$由$[B]_{补}$`连同符号位在内,每位取反,末位加1`

### 定点数加法

#### 基本示例

![](https://img-blog.csdnimg.cn/img_convert/e75868277036e965914f06169249262b.png)

![1646369883570](https://img-blog.csdnimg.cn/img_convert/07e2ce21189fff8ea7b751d18c60ebf4.png)

![1646370211559](https://img-blog.csdnimg.cn/img_convert/80b231e4e1a5772080c5f14990168348.png)

> 不论操作数是正还是负,在做`补码加减法`时,只需将`符号位和数值部分`一起参加运算，并且`将符号位产生的进位自然丢掉`即可。

#### 溢出问题

* 一般来说,溢出现象的产生是由于加/减法操作使得结果的绝对值变得过大,以至于机器字长无法表示,具体可能可能由
  * 同号相加
  * 异号相减
    * 例如 (5-(-6)); (-5-6))
* 不会溢出的情况(这些情况下,运算结果的绝对值不会超过两个操作数绝对值中的任何一个)
  * 同号相减
  * 异号相加

![1646370540390](https://img-blog.csdnimg.cn/img_convert/b7aa908190ebec4763f2b2acb5f7617e.png)

和一般的最左边的1做丢弃处理不同,本例中,丢弃掉最高位1后,两个负数(补码)相加的结果出现正数的结果,显然不对

## 溢出判断

### 用一位符号位判断溢出

* 对于加法
  * 只有在正数加正数和负数加负数两种情况下才可能出现溢出,符号不同的两个数相加是不会溢出的。
* 对于减法
  * 只有在正数减负数或负数减正数两种情况下才可能出现溢出,符号相同的两个数相减是不会溢出的。

> 下面以机器字长为4位(含1位符号位)为例,说明机器是如何判断溢出的。
>
> * 机器字长为4位的补码所对应的真值范围为-8~+7,运算结果一旦超过这个范围即为溢出。
> * 表6.7列出了四种溢出情况。
>   * 由于减法运算在机器中是用加法器实现的,因此可得出如下结论:不论是作加法还是减法，只要实际参加操作的两个数符号相同,结果又与原操作数的符号不同,即为溢出。

![1646372081727](https://img-blog.csdnimg.cn/img_convert/3afaccb3fa48395223dfcd6a81adfe9f.png)

该结果位溢出所致.

同号相加可能导致溢出,但是也可能未溢出

![1646372245414](https://img-blog.csdnimg.cn/img_convert/61cbebd2a180020358e7281d2780e65c.png)

> 上例化为十进制时,真值运算表示($-\frac{1}{2}+(-\frac{1}{2}))=-1$

> 由$[A+B]_{补码}$= 1.0000,而且对应的真值:A + B= - 1,由此可见,用`补码表示定点小数时`,它能表示–1的值。

* 计算机中采用1位符号位判断时,为了节省时间,通常用`符号位产生的进位`与`最高有效位产生的进位`==异或操作==后,按其结果进行判断。
* (若异或结果为1 ,即为溢出;异或结果为0,则无溢出。
* 例6.12中符号位有进位(1),最高有效位无进位(0),即$1\oplus0 = 1$,故溢出。
* 例6.13中符号位有进位(1),最高有效位也有进位(1),即$1\oplus1=0$,故无溢出。

### 变形补码判断溢出

![1646377310356](https://img-blog.csdnimg.cn/img_convert/e9572e96fa131cba93928b8545a95cd8.png)

* 变形补码判断溢出的原则是:
  * 当2位符号位不同时,表示溢出,
  * 否则,无溢出。
* 不论是否发溢出,高位(第1位)符号位永远代表真正的符号。

![1646377168720](https://img-blog.csdnimg.cn/img_convert/ce0dea523125203ddce3f6bcba13520a.png)

此时,符号位为“01”,表示溢出,又因第1位符号位为“0”,表示结果的真正符号为正,故“01”表示`正溢出`。

![1646377523312](https://img-blog.csdnimg.cn/img_convert/1ac949bdf746549ce1577fffa2bcf38a.png)

* 符号位为“10”,表示溢出。由于第1位符号位为1 ,则表示负溢出。
  上述结论对于整数也同样适用。
* 在浮点机中,当`阶码`用`两位符号位`表示时,判断溢出的原则与小数的完全相同。

### 溢出判断总结

可以根据真值表转换为逻辑表达式:

![1646376797186](https://img-blog.csdnimg.cn/img_convert/221220a6195e96989cc86a43a1d6ca2d.png)

![1646377728404](https://img-blog.csdnimg.cn/img_convert/8d9136c1b0d2f9fc3f4f51e1ff688949.png)

![1646377749283](https://img-blog.csdnimg.cn/img_convert/f451879941b8de8511a6b4cb1b765017.png)

![1646377784518](https://img-blog.csdnimg.cn/img_convert/7268a35de3c1b3c34c0649801e2a3c59.png)

## 浮点数规格化问题实例

### 基本规格化问题

![1646305647184](https://img-blog.csdnimg.cn/img_convert/954dd941d35ac9e9619905e2f8c31225.png)

### 十进制数的浮点数和定点数的表示形式示例

基于原码的规格化数(单符号位)

![1646306839531](https://img-blog.csdnimg.cn/img_convert/4ae407499ed2eda41357f31a2bd58516.png)

## 浮点数加减规格化综合问题

### 浮点数加减法预处理分析

* 由于浮点数尾数的小数点均固定在第一数值位前,所以尾数的加减运算规则与定点数的完.全相同。
* 但由于其`阶码的大小`又直接反映尾数有效值小数点的`实际位置`,

  * 因此当两浮点数阶码不等时,因两尾数小数点的实际位置不一样,尾数部分无法直接进行加减运算。
  * 为此,浮点数加减运算必须按以下几步进行

(1) 对阶,使两数的小数点位置对齐。(阶数决定小数点实际位置)

* 对阶的目的是使两操作数的小数点位置对齐,即使两数的阶码相等。
* 为此,首先要求出`阶差`,再按`小阶向大阶看齐`的原则,使`阶小的尾数`向`右移`位,
  * 每右移一位,阶码加1,直到两数的阶码相等为止。
  * 右移的次数正好等于阶差。
* 尾数右移时可能会发生数码丢失,影响精度。

(2) 尾数求和,将对阶后的两尾数按定点加减运算规则求和(差)
(3) 规格化,为增加有效数字的位数,提高运算精度,必须将求和  (差)后的尾数规格化。
(4) 舍入,为提高精度,要考虑尾数右移时丢失的数值位。
(5) 溢出判断, 即判断结果是否溢出

设两个浮点数

$$
\begin{array}{l}
x=S_{x} \cdot r^{j_{x}} \\
y=S_{y} \cdot r^{j_{y}}
\end{array}

$$

S为尾数,其余部分为阶数

### 综合示例:浮点数加法与右规

![1646383935018](https://img-blog.csdnimg.cn/img_convert/07a9d8f8ac971ce2fa530b61ab144769.png)

将`双符号位`的`符号位一同右移`
然后`在符号位上补位`(正数机器数(补码)就补0)

下一个加法例子中也是类似

![1646383975809](https://img-blog.csdnimg.cn/img_convert/adf10def7c68162bd7e586a332af72c8.png)

### 浮点数减法示例

![1646393929643](https://img-blog.csdnimg.cn/img_convert/9fb2168c36b53b2934f61ae7e9d8e171.png)

![1646393966485](https://img-blog.csdnimg.cn/img_convert/8169bacdebf10b63b6497e84aa84c91c.png)

# 浮点数表示/补码运算:定点数加减法/浮点数加减法

## 浮点数表示

* 浮点数表示法是指以适当的形式将比例因子表示在数据中，让小数点的位置根据需要而浮动。
* 这样，在位数有限的情况下，既`扩大了数的表示范围`，又`保持`了数的`有效精度`。
  * 例如，用定点数表示电子的质量或太阳的质量是非常不方便的。
  * 使用浮点是可以较好表示

### IEEE 754标准的浮点数格式

![1646287126006](https://img-blog.csdnimg.cn/img_convert/cb14d638adcf5927e1a2389a623003d2.png)

![](https://img-blog.csdnimg.cn/img_convert/a943cbd2dc87b8c9eece89be61e0b1e2.png)

> 其中,S为数符,它表示浮点数的正负,但与其有效位(尾数)是分开的。
>
> 阶码用移码表示,阶码的真值都被加上一个常数(偏移量),
>
> * 如短实数,长实数和临时实数的偏移量用十六进制数表示分别为7FH,3FFH和3FFFH。
> * 尾数部分`通常`都是规格化表示,即非“O”的有效位最高位总是“1”,但在IEEE标准中,有效位呈如下形式。
>   1▲ffff……-fff
>   其中▲表示假想的二进制小数点。
> * 在实际表示中,对短实数和长实数,`这个整数位的1省略`,称`隐藏位`;
> * 对于临时实数不采用隐藏位方案,
> * 下表列出了十进制数178.125的实数表示。
>   * ![](https://img-blog.csdnimg.cn/img_convert/fd44e904cbf7246aa92761142329dac9.png)

### 非标准形式讨论浮点数

通常,浮点数被表示成
$N =S \times r^{j}$
式中,

* S为尾数(可正可负),
* j为阶码(可正可负),
* r是基数(或基值)。

> 在计算机中,基数可取2，4、8或16等。

> * 为了提高数据精度以及便于浮点数的比较,在计算机中规定`浮点数的尾数`用`纯小数形式`,
> * 此外,将`尾数(小数)最高位为1的浮点数`称为`规格化数`,即 $N =0. 110101\times 2^{100}$为浮点数的规格化形式。
> * 浮点数表示成规格化形式后,其`精度最高`。

![1646288069544](https://img-blog.csdnimg.cn/img_convert/ae1f08025f35acf993fef504ff5d542f.png)

* 浮点数由阶码j和尾数S两部分组成。
  * `阶码是整数`,阶符$j_{f}$和`阶码的位数m`合起来反映`浮点数的`表示范围及`小数点的实际位置`;
  * `尾数是小数`,其`位数n反映了浮点数的精度`;
  * 尾数的符号$S_{f}$代表浮点数的正负

### 浮点数形式分析

分段:**阶数;尾数**

具体展开为:**阶数:{(阶符),(阶码数值)};尾数:{(数符).(数码数值)}** 的书写形式(即尾数分为数符和数码)
基数是默认值为2,可以不体现出来
`阶符`和`数符`可以取0/1

### 浮点数的表示范围(非规格化时)

设浮点数`阶码的数值位取m位`,`尾数的数值位取n位`,当浮点数为非规格化数时,它在数轴上的表示范围:

![1646303050232](https://img-blog.csdnimg.cn/img_convert/b35536513bcd3fe124cff3be4a41c4d9.png)

$浮点数=阶数\times 尾数$

### 浮点数的精度和范围

一旦浮点数的位数确定后,合理分配`阶码`和`尾数`的`位数`,直接影响浮点数的表示`范围和精度`。

* 通常对于短实数(总位数为32位),阶码取8位(含阶符1位) ,尾数取24位(含数符1位);
* 对于长实数(总位数为64位),阶码取11位(含阶符1位) ,尾数取53位(含数符1位);
* 对于临时实数(总位数为80位),阶码取15位(含阶符1位) ,尾数取65位(含数符1位)。

### 浮点数的规格化

* 为了提高浮点数的`精度`,其尾数必须为规格化数。
* 如果不是规格化数,就要通过`修改阶码`并`同时左右移尾数`的办法,使其变成规格化数。
* 将非规格化数转换成规格化数的过程称为规格化。
  * 对于`基数`不同的浮点数,因其规格化数的`形式不同`,`规格化过程也不同`。

#### 左规/右规

* 当基数为2时,`尾数最高位为1`的数为规格化数。

  * 规格化数的尾数的绝对值不小于$\frac{1}{2}$
  * 规格化时,`尾数左移`一位,阶码减1(这种规格化称为向左规格化,简称`左规`);
  * `尾数右移`一位,阶码加1(这种规格化称为向右规格化,简称`右规`)。
* 当基数为4时,尾数的最高两位不全为零的数为规格化数。

  * 规格化时,尾数左移两位,阶码减1 ;
  * 尾数右移两位,阶码加1。
* 当基数为8时,尾数的最高三位不全为零的数为规格化数。

  * 规格化时,尾数左移三位,阶码减1;
  * 尾数右移三位,阶码加1。

> * 浮点机中一旦基数确定后就不再变了
> * 而且基数是隐含的,故不同基数的浮点数表示形式完全相同。
>   * 但基数不同,对数的表示范围和精度等都有影响。
>   * 一般来说,基数r越大,可表示的浮点数范围越大,而且所表示的数的个数越多。
>   * 但r越大,浮点数的精度反而下降。
>   * 如r = 16的浮点数,因其规格化数的尾数最高三位可能出现零,故与其尾数位数相同的r =2的浮点数相比,后者可能比前者多三位精度。

#### 双符号位规格化

![1646382660768](https://img-blog.csdnimg.cn/img_convert/a316e5d5deecf23f7bb8e94c75c348f1.png)

可见,当尾数的最高数值位与符号位不同时,即为规格化形式

> 但对S<0时,有两种情况需特殊处理。

* $s=-\frac{1}{2}$,则$[S]_{补}=11.100\cdots 0,$
  此时对于真值$-\frac{1}{2}$,而言,它满足式(6.19),对于补码$[S]_{补}$,而言,不满足6.21的形式

> 为了便于硬件判断,特规定$-\frac{1}{2}$不是规格化的数(对补码而言)。

* $s = -1$,则$[S]_{补} = 11.00…0$,因小数补码允许表示-1,故-1视为规格化的数。

#### 左规

例子

![1646383455850](https://img-blog.csdnimg.cn/img_convert/230bc596595ea301e893dfc8ee24c5f6.png)

#### 右规

* 当尾数出现01.x x…×或10.x x…x时,表示尾数溢出,这在`定点加减运算`中是不允许的,
* 但在`浮点运算`中这不算溢出,可`通过右规处理`。
* 右规时尾数右移一位,阶码加1。

## 机器零

* 当一个浮点数`尾数为0`时(不论其阶码为何值)或`阶码等于或小于它所能表示的最小数`时(不管其尾数为何值)机器都把该浮点数作为零看待,并称之为“`机器零`”。
* 如果浮点数的阶码用移码表示,尾数用补码表示
  * 则当阶码为它所能表示的最小数$-2^{m}$(式中 m为阶码的位数,此时该浮点数已经被当作机器零)且尾数为0时,其阶码(移码)全为0,尾数(补码)也全为0,这样的机器零为000...0000

## 移码

使用补码不容易直接判断数的大小
使用移码可以直接判断出机器数对应的真值之间的大小关系
$[x]_{移}$在数轴上的表示总是>=0
![](https://img-blog.csdnimg.cn/img_convert/0dcdb32ca1446d63cb52edfa5ea19bff.png)

![](https://img-blog.csdnimg.cn/img_convert/5b0fbaa71cc32f5a479126cf1c8d6718.png)

* 此外,由移码的定义可见，当n = 5时,其最小的真值为$x = -2^{5}=- 100000_{二进制}$，则$[ - 100000]_{移} =2^{5}+ x = 100000 - 100000 = 0,00000$,即最小真值的移码为全0,这符合人们的习惯。
* 利用移码的这一特点,当浮点数的阶码用移码表示时,就能很方便地`判断阶码的大小`

# 加法/减法运算

加法/减法可能会产生溢出,因此还伴随着溢出判断等处理

## 定点数加法/减法运算

### 补码加法公式

![](https://img-blog.csdnimg.cn/img_convert/3a65e33fe5a80b87ad833e1aec2113d2.png)

### 补码减法公式

![](https://img-blog.csdnimg.cn/img_convert/3d81a9814535e4c050ffe100b2ae65db.png)

> * 因此,若机器数采用补码,当求A – B时,只需先求$[ -B]_{补}$(称$[ –B]_{补}$,为“求补”后的减数),就可按补码加法规则进行运算。
> * 而$[ -B]_{补}$由$[B]_{补}$`连同符号位在内,每位取反,末位加1`而得
>   * (由于B可以是正数也可以是负数)。
>   * B和-B在的原码(真值)的二进制形式上仅相差一个符号位
>   * 例如,$B=-6=1,110;-B=6=0,110;$
>     * $[-B]_{补}=[6]_{补}=0,110;$
>     * $[B]_{补}=[-6]_{补}=1,010;$
>     * (求(一个数的)`相反数`的补码)数B的相反数的补数(-B的补数)确实可以通过将`B的补码`的`包括符号位在内的所有位取反再末尾+1`得到-B的补数
>       * 即,采取的策略是用一个补码求另一个补码
>     * 事实上,求一个`负数`的补码,也可以用求相反数的补码的手法来得到(比如-6的补码,通过将+6补码的所有位取反再末尾+1得到;(可以将这种情况视为求相反数的补码的特例)
>       * 用原码求补码的策略需要先判断真值的正负,如果是负数,执行该真值负数原码的符号位之外的位的按位取法末尾+1)

### [-B的补数]和[B的补数的相反数]的关系

$$
[-B]_{补}=-[B]_{补}

$$

我们知道,等号左边的形式是很常用的

在补码减法公式那里有:

![1646388896138](https://img-blog.csdnimg.cn/img_convert/fd6311917931e471a0bd004a77b12070.png)

我们只需要令`A=B`

$$
[B-B]_{补}=[B]_{补}+[-B]_{补}\\
又因为LHS(等号左边)=0;所以\\
[B]_{补}+[-B]_{补}=0\\从而\\
-[B]_{补}=[-B]_{补}

$$

这在浮点数加减法做对阶的时候会经常用到.

当然,我们知道,计算机引入二进制补码是为了方便将减法操作转换为加法操作.

(后面的浮点数加减法会给出例子)

前面还提到,$[ -B]_{补}$由$[B]_{补}$`连同符号位在内,每位取反,末位加1`

$$
[B]_补=b_1b_2\cdots b_n;\\
[-B]_补=\overline{b_1}\ \overline{b_2}\ \cdots \ \overline{b_n}+1;\\其中b_1b_2\cdots b_3是0/1串(b_1)是符号位;\\B是真值,而且正负都适用;

$$

### 定点数加法

#### 基本示例

![](https://img-blog.csdnimg.cn/img_convert/e75868277036e965914f06169249262b.png)

![1646369883570](https://img-blog.csdnimg.cn/img_convert/07e2ce21189fff8ea7b751d18c60ebf4.png)

![1646370211559](https://img-blog.csdnimg.cn/img_convert/80b231e4e1a5772080c5f14990168348.png)

> 不论操作数是正还是负,在做`补码加减法`时,只需将`符号位和数值部分`一起参加运算，并且`将符号位产生的进位自然丢掉`即可。

#### 溢出问题

* 一般来说,溢出现象的产生是由于加/减法操作使得结果的绝对值变得过大,以至于机器字长无法表示,具体可能可能由
  * 同号相加
  * 异号相减
    * 例如 (5-(-6)); (-5-6))
* 不会溢出的情况(这些情况下,运算结果的绝对值不会超过两个操作数绝对值中的任何一个)
  * 同号相减
  * 异号相加

![1646370540390](https://img-blog.csdnimg.cn/img_convert/b7aa908190ebec4763f2b2acb5f7617e.png)

和一般的最左边的1做丢弃处理不同,本例中,丢弃掉最高位1后,两个负数(补码)相加的结果出现正数的结果,显然不对

## 溢出判断

### 用一位符号位判断溢出

* 对于加法
  * 只有在正数加正数和负数加负数两种情况下才可能出现溢出,符号不同的两个数相加是不会溢出的。
* 对于减法
  * 只有在正数减负数或负数减正数两种情况下才可能出现溢出,符号相同的两个数相减是不会溢出的。

> 下面以机器字长为4位(含1位符号位)为例,说明机器是如何判断溢出的。
>
> * 机器字长为4位的补码所对应的真值范围为-8~+7,运算结果一旦超过这个范围即为溢出。
> * 表6.7列出了四种溢出情况。
>   * 由于减法运算在机器中是用加法器实现的,因此可得出如下结论:不论是作加法还是减法，只要实际参加操作的两个数符号相同,结果又与原操作数的符号不同,即为溢出。

![1646372081727](https://img-blog.csdnimg.cn/img_convert/3afaccb3fa48395223dfcd6a81adfe9f.png)

该结果位溢出所致.

同号相加可能导致溢出,但是也可能未溢出

![1646372245414](https://img-blog.csdnimg.cn/img_convert/61cbebd2a180020358e7281d2780e65c.png)

> 上例化为十进制时,真值运算表示($-\frac{1}{2}+(-\frac{1}{2}))=-1$

> 由$[A+B]_{补码}$= 1.0000,而且对应的真值:A + B= - 1,由此可见,用`补码表示定点小数时`,它能表示–1的值。

* 计算机中采用1位符号位判断时,为了节省时间,通常用`符号位产生的进位`与`最高有效位产生的进位`==异或操作==后,按其结果进行判断。
* (若异或结果为1 ,即为溢出;异或结果为0,则无溢出。
* 例6.12中符号位有进位(1),最高有效位无进位(0),即$1\oplus 0 = 1$,故溢出。
* 例6.13中符号位有进位(1),最高有效位也有进位(1),即$1\oplus1=0$,故无溢出。

### 变形补码判断溢出

![1646377310356](https://img-blog.csdnimg.cn/img_convert/e9572e96fa131cba93928b8545a95cd8.png)

* 变形补码判断溢出的原则是:
  * 当2位符号位不同时,表示溢出,
  * 否则,无溢出。
* 不论是否发溢出,高位(第1位)符号位永远代表真正的符号。

![1646377168720](https://img-blog.csdnimg.cn/img_convert/ce0dea523125203ddce3f6bcba13520a.png)

此时,符号位为“01”,表示溢出,又因第1位符号位为“0”,表示结果的真正符号为正,故“01”表示`正溢出`。

![1646377523312](https://img-blog.csdnimg.cn/img_convert/1ac949bdf746549ce1577fffa2bcf38a.png)

* 符号位为“10”,表示溢出。由于第1位符号位为1 ,则表示负溢出。
  上述结论对于整数也同样适用。
* 在浮点机中,当`阶码`用`两位符号位`表示时,判断溢出的原则与小数的完全相同。

### 溢出判断总结

可以根据真值表转换为逻辑表达式:

![1646376797186](https://img-blog.csdnimg.cn/img_convert/221220a6195e96989cc86a43a1d6ca2d.png)

![1646377728404](https://img-blog.csdnimg.cn/img_convert/8d9136c1b0d2f9fc3f4f51e1ff688949.png)

![1646377749283](https://img-blog.csdnimg.cn/img_convert/f451879941b8de8511a6b4cb1b765017.png)

![1646377784518](https://img-blog.csdnimg.cn/img_convert/7268a35de3c1b3c34c0649801e2a3c59.png)

## 浮点数规格化问题实例

### 基本规格化问题

![1646305647184](https://img-blog.csdnimg.cn/img_convert/954dd941d35ac9e9619905e2f8c31225.png)

### 十进制数的浮点数和定点数的表示形式示例

基于原码的规格化数(单符号位)

![1646306839531](https://img-blog.csdnimg.cn/img_convert/4ae407499ed2eda41357f31a2bd58516.png)

## 浮点数加减规格化综合问题

### 浮点数加减法预处理分析

* 由于浮点数尾数的小数点均固定在第一数值位前,所以尾数的加减运算规则与定点数的完.全相同。
* 但由于其`阶码的大小`又直接反映尾数有效值小数点的`实际位置`,

  * 因此当两浮点数阶码不等时,因两尾数小数点的实际位置不一样,尾数部分无法直接进行加减运算。
  * 为此,浮点数加减运算必须按以下几步进行

(1) 对阶,使两数的小数点位置对齐。(阶数决定小数点实际位置)

* 对阶的目的是使两操作数的小数点位置对齐,即使两数的阶码相等。
* 为此,首先要求出`阶差`,再按`小阶向大阶看齐`的原则,使`阶小的尾数`向`右移`位,
  * 每右移一位,阶码加1,直到两数的阶码相等为止。
  * 右移的次数正好等于阶差。
* 尾数右移时可能会发生数码丢失,影响精度。

(2) 尾数求和,将对阶后的两尾数按定点加减运算规则求和(差)
(3) 规格化,为增加有效数字的位数,提高运算精度,必须将求和  (差)后的尾数规格化。
(4) 舍入,为提高精度,要考虑尾数右移时丢失的数值位。
(5) 溢出判断, 即判断结果是否溢出

设两个浮点数

$$
\begin{array}{l}
x=S_{x} \cdot r^{j_{x}} \\
y=S_{y} \cdot r^{j_{y}}
\end{array}

$$

S为尾数,其余部分为阶数

### 综合示例:浮点数加法与右规

![1646383935018](https://img-blog.csdnimg.cn/img_convert/07a9d8f8ac971ce2fa530b61ab144769.png)

将`双符号位`的`符号位一同右移`
然后`在符号位上补位`(正数机器数(补码)就补0)

下一个加法例子中也是类似

![1646383975809](https://img-blog.csdnimg.cn/img_convert/adf10def7c68162bd7e586a332af72c8.png)

### 浮点数减法示例

![1646393929643](https://img-blog.csdnimg.cn/img_convert/9fb2168c36b53b2934f61ae7e9d8e171.png)

![1646393966485](https://img-blog.csdnimg.cn/img_convert/8169bacdebf10b63b6497e84aa84c91c.png)
