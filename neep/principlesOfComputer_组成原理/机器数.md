@\[toc\]

## 原码,补码,反码规律总结

* (适用于整数以及小数)
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062115195816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)
* 这里提到的:反码为`原码的每位求反`不包括数值化后的`符号位`.
* 虽然这里说,真值为负数的时候,转换为机器数的形式后,其符号位都用"1"表示,但是得到这个`1`是有一个过程的(特别是按照国外有些教材的转换手法)
  * 事实上,这里的总结,仅仅是后面形式化转换公式的一种简单描述(即,其根据是形式化定义,但不如形式化定义那样完备,对于某些临界情况,使用公式会是更好的选择)
  * 譬如+0/-0的补码形式,采用公式的做法可以得出全0

## 移码的特点

* 移码和补码的关系
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621221751188.png)
* ![1646041931111](https://s2.loli.net/2022/02/28/zFVWPBZEsLJ9AbQ.png)
* ![1646041920408](https://s2.loli.net/2022/02/28/SBG8zKts1QWUZaw.png)

## 不同角度解读机器数

> 原码/补码/反码/移码都是有符号数

* 同一个`二进制代码`以不同种的机器数规则来解读,可能对应着不同的真值(真值取值范围)
* 同一个`二进制代码`,它对应的`有符号机器数`的符号位`都是一致`的(机器数形式之间的转换不影响`符号位`)
* 手工转换不同的机器数时,可以围绕着`二进制代码`做不同程度的映射变换;

## 示例(真值与各种机器数的转换/对应关系)

> 注意

- 表格中的十进制数都是真值(将同一个`二进制代码`以不同的机器数方式解读的时候对应的真值是不同的)
- 即,将二进制代码转换为十进制真值
- 执行的是:根据`二进制机器数`求对应的`十进制真值`

二进制代码转为无符号(十进制)数是最为直白的一种转换方式(按权展开求和即可,将这种操作记为`操作A`)

二进制代码以原码的角度解读,所作的转换工作也挺直白的(最简单的有符号数),相较于转为无符号数,只是`保留最高位作为符号位`,其余位(非符号位)按照上述`操作A`进行转换)

二进制代码以`补码`规则解读得到的真值的计算流程可以建立在(但该操作仅限于二进制):==原码(取反+1)==(也可以直接基于`反码`+1)的基础上:

* 先按照上述方法,将原始的`二进制代码`
  * 划分最高位为`符号位`(不动它)
  * `其余位`则作为`数值位部分`
* 将`数值位`部分的各个位`按位取反`,`最后再加1`(均以二进制形式表达)
  * 但有特殊情况(1000...0)这种形式的(比如下表中补码的`-128`)/以及(+0/-0)的补码(根据形式化公式来计算)
  * 真值`-128`如果要用字长为8的机器是无法直接表示(因为如果包括符号位在内,需要至少9位才能够存放的下)
* * 加法过程中可能会使得`数值位中的最高位`再进位到`符号位`(比如计算$\[-0\]\_{补}$)(溢出字长的bit将被丢弃)
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621183246351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

`对于真值为正数`的情况而言,我们只需要将符号位设置为0,在将真值抄下即可

(但是注意要和给定寄存器位数对齐,不足的根据真值是小数还是整数在某一侧补0对齐)

## 补码:

* 补码之所以有利于加减法的统一,是因为,求补码的手段可以通过对原码各个数值位取反加一;
* 而对于手算补码,可以采用取反加一(针对于二进制的规律)

更通用的,通过补码的定义,可以采用手工二进制减法来计算负数的补码

* 手工算采用`取反加一`更加快速(当然啦,这是针对负数的规律,如果是正数的话不需要多加处理,但是注意机器寄存器位数,可能需要补0对齐),
* 此外,取反加一的规律是基于负数的二进制原码形式的,尤其是(负数的原码,
* 寄存器位对齐(必要时补零),另外,纯小数也适用于取反加一的规律,仍然要注意寄存器位对齐)

## 关于补码的表示范围:

* 尽管我们有以上总结的结论来求某个真值的补码,但原始的补码公式在理解补码的表示范围是比较有用:
  例如,我们取寄存器(机器字长位8位,其中数值位n=7位)

## 机器数&真值

带有`+`或者`-`号的数称为`真值`
将两种符号数值化(为0/1)后的数称为`机器数`(主要有4种编码/表示方法)

执行真值(十进制)和各种机器数(二进制)的转换的时候,通常都以二进制形式作为桥梁(求机器数的各公式中的真值x在使用的时候转换为二进制形式)

特别的,给出机器字长的时候,转换后进行补零对齐

## 原码&真值

* 原码是最简单的机器数,其和真值的关系就是`原码的数值位部分`就是`真值的绝对值`
* 形式化定义中,位数n是指,机器字长中用于表示数值位部分的位数(对于单符号位,机器字长ML=1+n;(机器字长=符号位+数值位)
  * 例如,给定的机器字长位8bit,则n=8-1=7
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/61a88ac55da34862b71a9af3e65c60a2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)
* 判断真值整数x的位数n时不考虑`±`符号,而且是x的二进制表示(n可以理解为真值绝对值的二进制表示的位数)

公式中考虑了符号位,即,将公式的右值转换为二进制代码,最高位自然就是符号位.(转化后的有符号数的位数将是`n+1`位)

这里提到的形式化定义公式在计算的时候可以都看作是无符号数(绝对值)之间的计算(加法/减法,尤其是后面一种形式)(公式的设计已经将符号位考虑在数值计算中,只需要在最终结果的二进制形式中划分最高位为符号位即可)

在你用公式求真值的时候也是按绝对值来处理(做减法)

## 补码&补数&模

![在这里插入图片描述](https://img-blog.csdnimg.cn/80698d0096854707a091d4c2b0cd48fa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)如上分析,负数求补码的时候,手工求模的一种方式就是:只需要加上一个模即可(不限于二进制)

* 一个负数可以用它的`正补数`来代替,这个`正补数`:(可以用模加上负数本身`求得这个正补数`)。(当然,默认的,负数的绝对值不超过模,否则对其进行取模运算,然后将的到的结果执行上述操作,下文一样)
* 一个正数和一个负数互为补数时，它们绝对值之和即为模数。
* 正数的补数即该正数本身。
  将补数的概念用到计算机中，便出现了补码这种机器数。

对于二进制,我们有更高效的方法(对真值(\<0)的原码数值位部分取反＋1即可)

## 补码的形式化定义

基于寄存器字长rbs=(1+n)的划分结构:
rbs:register bits
以下公式中的x均为真值

贯穿这些机器数的核心概念:

* 真值的绝对值
* 绝对值(无符号)的二进制代码的位数n
* 模(对于补数)

### 纯整数:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621161723319.png)
根据前面的模&补数的分析,这里的公式(x\<=0)的情况的公式就好理解,当然,注意这里的模是$ 2^{n+1}$而不是$2^{n}$;就是负数加模(模+负数)

### 纯小数

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621161801794.png)

### 补码的其他计算方法

![1646041307271](https://s2.loli.net/2022/02/28/pnrOBYvFQbXs3Vu.png)

### 补码中的0只有一种表示形式?

\> 或者说,真值0的补码只有一种形式

* 下面的实例说明,真值0(`+0`和`-0`)的补码形式是一致的

![在这里插入图片描述](https://img-blog.csdnimg.cn/082df91e8ea84d44a048250b39894a48.png)

* 对于机器数(补码),符号是参加运算的,数值位的加法进位会进位到符号位,因为进位而超过机器字长的部分将会被丢弃,从而产生了和模的效果
* 对于`+0`,视为正数处理,即补码和原码一致,都是全0
* `-0`的真值可以通过形式化定义的公式来求(临界情况)

## 如果是双符号位(变形补码)

即,寄存器字长以`rbs=2+n`划分符号位和数值位,那么对于整数

### 小数

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622161307625.png)

### 整数

主要说明负数:x\<0,$[x]_{补_{双符号位}}$=$ 2^{寄存器位数}+x=2^{2+n}+x=2^{2+n}-|x|$

## \-128类似问题

按照前讲的,如果考虑符号位的话,8位数是不够表示带符号位的真值-128的

-128的(真值)绝对值的二进制表示为:1000,0000
考虑符号位,岂不是1,1000,0000?

> 然而,对于8位字长的限制下,补码可以表示到-128

原码的1000,0000表示负0(8位有符号数原码表示不了-128)
而补码中0就是0000,0000(空出来的-0(1,000,0000)被用于表示最小负数(最大绝对值负数)

# wikipedia中补码相关介绍

**补码** （英语：**2's complement**）是一种用[二进制](https://zh.wikipedia.xn--3js309f.xn--kpry57d/wiki/%E4%BA%8C%E9%80%B2%E4%BD%8D)表示有符号数的方法，也是一种将数字的正负号变号的方式，常在[计算机科学](https://zh.wikipedia.xn--3js309f.xn--kpry57d/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)中使用。

补码以有`符号比特(符号位)`的二进制数定义。

* `正数和0`的补码就是`该数字本身`(绝对值(或者说视为无符号值)的二进制形式)再补上最高比特0。\> \* `负数`的补码则是`将其对应正数`\==按位取反再加1==。(注意,是先确定其对应的`正数(原码)`取反(连通符号位都取反)再加一(意味着严格\<0的数的补码符号位(最高位)会是1)
* 补码系统的最大优点是可以在[加法](https://zh.wikipedia.xn--3js309f.xn--kpry57d/wiki/%E5%8A%A0%E6%B3%95)或[减法](https://zh.wikipedia.xn--3js309f.xn--kpry57d/wiki/%E6%B8%9B%E6%B3%95)处理中，不需因为数字的正负而使用不同的计算方式。
* 只要一种加法电路就可以处理各种有号数加法，而且减法可以用一个数加上另一个数的补码来表示，
* 因此只要有`加法电路`及`补码电路`即可完成各种有号数加法及减法，在`电路设计上相当方便`。
* 另外，补码系统的0就只有一个表示方式，这和[反码](https://zh.wikipedia.xn--3js309f.xn--kpry57d/wiki/%E4%B8%80%E8%A3%9C%E6%95%B8)系统不同（在反码系统中，0有二种表示方式），因此在判断数字是否为0时，只要比较一次即可。

右侧的表是一些8-bit补码系统的整数。

![1646031456989](https://s2.loli.net/2022/02/28/6ptDxUi5eHwB3RF.png)

它的可表示的范围包括-128到127，总共256（= $ 2^{8}$ ）个整数。

- 我们说,补码表示法中,真值0的补码表示法的形式只有一种(0,0...0)(对应于原码表示法中的`正零`;
- 除0之外的其它的数是一一对应,补码中(1,0...0)被空出来了(即原码中表示的`负零`的那个码在补码体系中对应的真值是多少?
- 它可以表示给定机器字长的最小(负)整数(表示范围中的下限)

## 特别的补码

有两个数字的补码等于本身：

* 一个是0
* 另一个为该比特内可表示`有符号位区分的`二进制形式的`下界负数`（即1000...形式的补码值）。
* `国外介绍的反码系统和国内教材介绍的有所区别`
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/e85b66964be94c4089aad96117375611.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

## 补码的工作原理

![1646041398552](https://s2.loli.net/2022/02/28/kwWUl5DNfqrSoOY.png)

* 所以模256下的加减法，用0, 1, 2,…, 254,255表示其值，或者用−128, −127,…, −1, 0, 1, 2,…,127是完全等价的。
* −128与128，−127与129，…，−2与254，−1与255可以互换而加减法的结果不变。
* 从而，把8位（octet）的高半部分（即二进制的1000 0000到1111 1111）解释为−128到−1，
* 同样也实现了模256的加减法，而且所需要的CPU加法运算器的电路实现与8位无符号整数并无不同。

> 实际上对于8比特的存储单元，把它的取值[00000000,…, 11111111]解释为[0, 255]，或者[-1, 254]，或者[-2, 253]，或者[-128, 127]，或者[-200, 55]，甚至或者[500, 755]，`对于加法硬件实现`并无不同。

## 根据某个数的补码求其相反数的补码

* (本例将给出结论,可以省去过渡到原码的步骤)
* 由补码求原码,可以对补码再次求补,即可得到原码
  原因还是可以通过补码的形式化(公式)定义来证明得到
  一般将寄存器中保存的有符号机器数做如下划分(划分位1+n)

注意bit上的数值对应的权重!
在利用公式验证时也要正确理解n的含义(不是寄存器位数,1+n才是寄存器位数)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621190502943.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621184755296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)

## 求真值的某种机器码的解题步骤

* 首先当然是要判断正负号
* 如果是个正数那可太走运啦,直接就利用:原码=反码=补码这一规律(相当于不用求,必要时用0补齐字长位)
* 对于负数,三种机器码有相应的计算规律

## 补码问题示例

### 分别用原码,补码和移码表示浮点数

$设浮点数格式为 : 阶码 5 位 ( 含 1 位阶符 ) , 尾数 11 位 ( 含 1 位数符 )$

$写出 \frac{51}{128},-\frac{27}{1024}, 7.375 ,- 86.5所对应的机器数.要求如下$
(1):源码
(2):补码
(3):移码
共四组(1)(2)(3),分别对应于x1,x2,x3,x4的解答:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621221605647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)


# 基于补码的加减计算

补码加减运算的基本公式

### 补码加法的基本公式如下:

$整数  \quad[A]_{补}+[B]_{补}=[A+B]_{补}\left(\bmod 2^{n+1}\right)$
$小数  \quad[A]_{\text {补 }}+[B]_{补}=[A+B]_{补}(\bmod 2)$
即补码表示的两个数在进行加法运算时,可以把符号位与数值位同等处理,
只要结果不超出机器能表示的数值范围,
运算后的结果按  $ 2^{n+1}$  取模  (  对于整数  )
或按 2 取模  (  对于小数  ) ,
就能得到本次加法的运算结果。

可根据补码定义,按两个操作数的四种正负组合情况加以证明。

### 对于减法

因  A-B=A+(-B)
则  $[A-B]_{补}=[A+(-B)]_{补}$
由补码加法基本公式可得
整数$\quad[A-B]_{补}=[A]_{补}+[-B]_{补}\left(\bmod 2^{n+1}\right)$
小数$\quad[A-B]_{\text {补 }}=[A]_{\text {补}}+[-B]_{\text {补 }}(\bmod 2)$

#### 补码之间的减法:

此外,还成立:

$$
[A]_{补}-[B]_{补}=[A]_{补}+(-[B]_{补})\\
=[A]_{补}+[-B]_{补}=[A-B]_{补}

$$

这里的A,B都是真值.

因此,若机器数采用补码, 当求  A-B  时, 只需先求  $[-B]_{补}$
(称  $[-B]_{\text {补}}$为 “求补”后的减数),就可以按照补码加法进行运算
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210622125456818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1Y2hhb3hpbjEzNzU=,size_16,color_FFFFFF,t_70)
