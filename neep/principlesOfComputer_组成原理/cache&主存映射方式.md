@[toc]

## 直接映射

* 我们将cache简称为缓存
* `每个主存块`只与 `一个缓存块`相对应,映射关系式为

  * $i = j\ mod\ C$
  * 其中，i为缓存块号,j为主存块号,C为缓存块数。
    * 设主存共有$M=2^m$个子块,cache含有$2^c$个子块($C=2^c)$(区分C,c;m>c)
    * 自然,区分不同缓存块的地址用c位二进制数来编码区分,用m位来区分主存的不同块
      * 下面提到的b位则是字块内部的存储单元的地址
  * 映射结果表明 `每个缓存块`对应 `若干个主存块`
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/fa8a625d3e8d438ab1d17f270f88b749.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

- ❤️这个表格稍微提一下
  - 上面说到,$C=2^c$,$M=2^m$;$\frac{M}{C}=m-c$,当然,m,c都是正整数(m>c),它们的差值也是正整数
  - 这意味着,主存的块数是cache块数的整倍数;(从这个语境下看,主存的最后一块会恰好的被映射到cache上的最后一块cache块.)
  - 又因为,我们是从0开始计数的,所以最后一块主存块$2^m-1$将被映射到cache块的最后块$C-1$上.
  - 或者从周期(函数)的角度(周期为T=C),可以方便的根据周期,把缓存块号最为该映射上结果序列上的第一个主存块号,再依次+C,得到映射到该cache块的主存块序列(比如,0,C,2C,3C,...,$2^m-C$)

> 这里需要稍微约定一下观点.
>
> - 计算机的运行主要依赖于cpu和主存
>   - cache作为一种高速中间设备主要用来提升性能(然而它不是运行中的必要一环)
>   - cpu根据数据(比如操作数)的地址,到对应地址位置去取数据
>     - 这时用到的主存地址可以分为三部分t+c+b
>     - 前m=(t+c)位可以精确到主存中的某个块
>     - 后b位可以进入到指定的主存块中进行字(节)的定位
>   - 没有cache的时候,cpu就直接到主存的正确的 `地址`处去取数据
>   - 现在有了cache,cpu会将这个原本要到主存访问的(主存)`地址`和cache中做对比(主要根据上述主存地址划分中的 `中间c位`字段计算得到对应映射的cache行(块);
>     - 再进行对比高t位的对比(如果对比结果发现相同,且对应的cache块的数据部分中的数据是有效的(根据有效位是否为1判定)(这时视为命中),那么就不用在进一步到主存中去取数,直接将命中的cache块中的数据取出来使用

* 
* 在缓存中 `主存地址高m位`被分成两部分:

  * `低c位`是指Cache 的字块地址,
  * `高t位`$(t = m-c)$是指 `主存字块标记tag `,它被记录在 `建立了对应关系的缓存块`的“标记"位中。
    * 这里$t=m-c$是指($2^t=\frac{2^m}{2^c})$;主存块数是cache块数的$2^t$倍(这个倍数用二进制数表示恰好需要t位)
    * 但这仅仅只是一种逻辑划分(我们刚好地使用主存地址的高t位作为标记)
  * 当 `缓存`接到CPU送来的 `主存地址 `后,只需根据 `中间c个bit `的字段(假设为00…01)找到 `Cache字块1(或者说,下图所示的cache行1) `,然后根据字块1的“标记”`是否与主存地址的高t位相符 `来判断(下图中的 `t位比较器`硬件做的这个事情)
    * 之所以这么做,是因为,一块cache块,会被多块主存块映射(譬如上表格中所示,0号cache块可以被$0号,C号,2C,..2^m$,那么如何区分?,就依赖于预保留出来的前t位来做一个块内判断
  * * 若符合,且有效位为“1”(即成功命中)(有效位 `用来识别Cache存储块中的数据是否有效`,因为有时Cache中的数据是无效的,❤️
      * 例如,在初始时刻Cache应该是“空”的,其中的内容是无意义的(这样,即使判断标记和主存地址一致,取出的数据也是无意义的(标记不是数据本身),
      * 有效位为1,表示该Cache 块已和主存的某块建立了对应关系(即已命中),则可根据b位地址从Cache中取得信息;
    * 若不符合,或有效位为“0”(即不命中),则 `从主存读入新的字块`来替代旧的字块,同时将信息送往CPU,并修改cache“标记”。
      * 如果原来有效位为“0”,还得将有效位置成“1”。

### 优点

* 实现简单,只需 `利用主存地址的某些位`直接判断,即可确定所需字块是否在缓存中

### 缺点

* 直接映射方式的缺点是不够灵活,因每个主存块只能固定地对应某个缓存块,即使缓存内还空着许多位置也不能占用,使缓存的存储空间得不到充分的利用。
* 此外,如果程序恰好要 `重复访问`对应 `同一缓存块位置`的 `不同主存块`,就要不停地进行替换,从而降低命中率。
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/17425a5019194c088b71777d0a8dc146.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHVjaGFveGluMTM3NQ==,size_15,color_FFFFFF,t_70,g_se,x_16)

### 小结

![🥰03/07/2022 20:03:12](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/20220307200306.png)

![🥰03/07/2022 20:03:44](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/20220307200343.png)

![1646657005307.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646657005307.png)

![1646656842434.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646656842434.png)

## 全相联映射

* 全相联映射允许主存中每一字块映射到Cache中的任何一块位置上。
* 这种映射方式可以从已被占满的Cache中替换出任一旧字块。
* 显然,这种方式灵活,命中率也更高缩小了块冲突率。
* 与直接映射相比,它的 `主存字块标记`从t位增加到 `t+c`位,这就使Cache“标记”的位数增多,而且访问Cache时主存字块标记需要和Cache的全部“标记”位进行比较,才能判断出所访问主存地址的内容是否已在Cache 内。
* 这种比较通常采用“按内容寻址”的相联存储器来完成。
* 总之,这种方式所需的逻辑电路甚多,成本较高,实际的Cache还要采用各种措施来减少地址的比较次数。

![1646657418935.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646657418935.png)

![1646657946575.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646657946575.png)

![1646657998977.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646657998977.png)

## 组相联映射

* 组相联映射是对直接映射和全相联映射的一种折中。
  * r->row(row array of cache)
* 它把Cache分为Q(=$2^q=\frac{2^c}{2^r}=2^{c-r}$)组,`每组有R块`(=C/Q=$2^r$;Q<C),并有以下关系:
  - $$
    i = j\ mod \ Q
    $$
  - 用q位(q=c-r)二进制数来区分不同的cache组(每个组内有R块)
    - 下图为例便于理解,将每组中的子块并排画到同一行)
    - r=1,对应的组内cache块数$R=2^r=2^1=2$块
  - 其中,i为缓存的 `组号`,j为主存的块号。
  - 某一主存块按 `模Q`将其映射到缓存的 `第i组`内
  - 可以认为,小写字母也是数量的一个指标(指数度量$log_2$)
  - $Q<C$,模变小了,直接相联的部分变得容易重合(有较高的组间冲突率,组内冲突特点类似全相联),但是组内采用全相联,有较高的cache利用率

![1646657717835.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646657717835.png)

![1646657731011.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646657731011.png)

![1646657753933.png](https://cdn.jsdelivr.net/gh/xuchaoxin1375/pictures@main/images/1646657753933.png)

### summary

组相联下:

* 组间直接相连,组内全相联
* 极端情况位:
  * 每个组只有一个cache,(分组的数量达到最多,仅直接相联有作用)
  * 分组数量q达到最少(仅一个分组,组内数量达到最多,此时仅全相联有作用))
  *
